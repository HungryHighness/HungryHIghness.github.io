<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dictionary源码解析 | 好饿殿の小屋</title><meta name="keywords" content="c#"><meta name="author" content="好饿殿"><meta name="copyright" content="好饿殿"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Dictionary源码解析 前置知识 Hash算法 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随">
<meta property="og:type" content="article">
<meta property="og:title" content="Dictionary源码解析">
<meta property="og:url" content="http://hungryhighness.github.io/2022/02/23/Dictionary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="好饿殿の小屋">
<meta property="og:description" content="Dictionary源码解析 前置知识 Hash算法 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg">
<meta property="article:published_time" content="2022-02-23T08:26:01.000Z">
<meta property="article:modified_time" content="2022-05-02T12:50:15.651Z">
<meta property="article:author" content="好饿殿">
<meta property="article:tag" content="c#">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://hungryhighness.github.io/2022/02/23/Dictionary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dictionary源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-02 20:50:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">好饿殿の小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Dictionary源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-23T08:26:01.000Z" title="发表于 2022-02-23 16:26:01">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-02T12:50:15.651Z" title="更新于 2022-05-02 20:50:15">2022-05-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Dictionary源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Dictionary源码解析">Dictionary源码解析</h1>
<h2 id="前置知识">前置知识</h2>
<h3 id="Hash算法">Hash算法</h3>
<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>
<p>所有的Hash函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“Hash碰撞”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。</p>
<p>常见构造Hash函数的算法：</p>
<ol>
<li>直接寻址法：取key的某个线性函数值为哈希地址。即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>∗</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>+</mo><mi>b</mi><mtext>，</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>为常量</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(key) = a*key+b，(a,b为常量)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">，</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">为常量</span><span class="mclose">)</span></span></span></span></li>
<li>数字分析法：比方有一组数据，其中每个数据都由十位数字组成。通过观察可得，每一组数据中前五位有大量重复数据，这样后五位就可以看作是随机的，即可选后五位作为哈希地址。</li>
<li>平方取中法：取key平方后的中间几位作为哈希地址。</li>
<li>折叠法：将key分成位数相同的几部分(最后一部分位数可以不同)，然后叠加和作为哈希地址。比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12345</mn></mrow><annotation encoding="application/x-tex">12345</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12345</span></span></span></span>即可拆成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mo>+</mo><mn>34</mn><mo>+</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">12+34+5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">34</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>。</li>
<li>除留余数法：选定一个统一的基数p，对所有键取余，从而得到对应的哈希地址。即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">H(key) = key\mod {p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span>。p的选择一般为素数或为表长。</li>
</ol>
<blockquote>
<p>对于为什么取素数可以看下面链接，我们的目标是让key和p的最大公约数都为1。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20806796">Hash时取模一定要模质数吗？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="Hash桶">Hash桶</h3>
<p>将生成的HashCode分段拆开，每一段称为一个桶，常见的桶便是对结果取余。比如源码中这一段<code>return ref buckets[hashCode % (uint)buckets.Length]</code>。</p>
<h3 id="Hash碰撞">Hash碰撞</h3>
<p>一个哈希函数能够将键转化为数组索引。算法的第二步是<strong>碰撞处理</strong>。也就是处理两个或者多个键的散列值相同的情况。</p>
<h4 id="拉链法">拉链法</h4>
<p>将大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>的数组中的每一个元素指向一条链表，链表中每个节点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法，因为发生冲突的元素都被存储在链表中。</p>
<p>这个方法的基本思想就是选择足够大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，使所有链表都尽可能保证高效的查找。</p>
<blockquote>
<p>当然，这里<code>M</code>并不是越大越好，选择一个足够大的即可。</p>
</blockquote>
<p>查找分为两步：</p>
<ol>
<li>根据散列值找到对应的链表</li>
<li>沿着链表顺序查找相应的键</li>
</ol>
<h4 id="线性探测法">线性探测法</h4>
<p>用大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>的数组保存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个键值对，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M &gt; N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。我们需要依靠数组中的<strong>空位</strong>解决碰撞冲突。基于这种策略的方法被统称为开放地址散列表。</p>
<p>其中最简单的方法叫做线性探测法：</p>
<p>当发生碰撞时，我们直接检查散列表的下一个位置。这样的线性探测可能会产生三种结果：</p>
<ul>
<li>命中，该位置的键和被查找的键相同</li>
<li>未命中，键为空（该位置没有键）</li>
<li>继续查找，该位置的键和被查找的键不同</li>
</ul>
<h2 id="Dictionary构造器">Dictionary构造器</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">struct</span> Entry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">uint</span> hashCode; </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 0-based index of next entry in chain: -1 means end of chain</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> next; <span class="comment">//下一个元素的下标索引</span></span><br><span class="line">    <span class="keyword">public</span> TKey key;     <span class="comment">// Key of entry</span></span><br><span class="line">    <span class="keyword">public</span> TValue <span class="keyword">value</span>; <span class="comment">// Value of entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先引入了<code>Entry</code>结构体，这是<code>Dictionary</code>中存放数据的最小单位。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; : <span class="title">IDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;, <span class="title">IDictionary</span>, <span class="title">IReadOnlyDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;,</span><br><span class="line">    <span class="title">ISerializable</span>, <span class="title">IDeserializationCallback</span> <span class="keyword">where</span> <span class="title">TKey</span> : <span class="title">notnull</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[]? _buckets; <span class="comment">//Hash桶</span></span><br><span class="line">    <span class="keyword">private</span> Entry[]? _entries; <span class="comment">//Entry数组，用于存放元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _count; <span class="comment">//当前Entries的index位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _freeList; <span class="comment">// 被删除Entry在Entries中的下标index</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _freeCount; <span class="comment">// 有多少被删除的Entry</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _version; <span class="comment">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class="line">    <span class="keyword">private</span> IEqualityComparer&lt;TKey&gt;? _comparer; <span class="comment">// 比较器</span></span><br><span class="line">    <span class="keyword">private</span> KeyCollection? _keys; <span class="comment">// 存放key的集合</span></span><br><span class="line">    <span class="keyword">private</span> ValueCollection? _values; <span class="comment">// 存放Value的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> StartOfFreeList = <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>(<span class="params"><span class="built_in">int</span> capacity, IEqualityComparer&lt;TKey&gt;? comparer</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (capacity &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Initialize(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> &amp;&amp; comparer != EqualityComparer&lt;TKey&gt;.Default) <span class="comment">// first check for null to avoid forcing default comparer instantiation unnecessarily</span></span><br><span class="line">    &#123;</span><br><span class="line">        _comparer = comparer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special-case EqualityComparer&lt;string&gt;.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.</span></span><br><span class="line">    <span class="comment">// We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the</span></span><br><span class="line">    <span class="comment">// hash buckets become unbalanced.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(TKey) == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        IEqualityComparer&lt;<span class="built_in">string</span>&gt;? stringComparer = NonRandomizedStringEqualityComparer.GetStringComparer(_comparer);</span><br><span class="line">        <span class="keyword">if</span> (stringComparer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _comparer = (IEqualityComparer&lt;TKey&gt;?)stringComparer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> size = HashHelpers.GetPrime(capacity);</span><br><span class="line">    <span class="built_in">int</span>[] buckets = <span class="keyword">new</span> <span class="built_in">int</span>[size];</span><br><span class="line">    Entry[] entries = <span class="keyword">new</span> Entry[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class="line">    _freeList = <span class="number">-1</span>;</span><br><span class="line">    _buckets = buckets;</span><br><span class="line">    _entries = entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Dictionary</code>在构造的时候做了以下几件事</p>
<ol>
<li>设置<code>size</code>为大于容量的一个最小质数（见目录中HashHelpers源码）。</li>
<li>初始化<code>int[] buckets</code>，大小为<code>size</code>,用来进行Hash碰撞。</li>
<li>初始化<code>Entry[] entries</code>，大小为<code>size</code>，用来存储字典的内容，并且标识下一个元素的位置。</li>
</ol>
<h2 id="部分API">部分API</h2>
<h3 id="Add">Add</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> modified = TryInsert(key, <span class="keyword">value</span>, InsertionBehavior.ThrowOnExisting);</span><br><span class="line">    Debug.Assert(modified); <span class="comment">// If there was an existing key and the Add failed, an exception will already have been thrown.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Add这里的英文注释写的很清晰，如果有一个现有的key，并且添加失败了，那么将会抛出一个异常，接下来去看<code>TryInsert()</code>方法。</p>
<p>因<code>TryInsert()</code>过长，这里选择拆开讲解，完整版见目录。</p>
<p>首先，先看输入参数<code>TryInsert(key, value, InsertionBehavior.ThrowOnExisting)</code>。</p>
<p>这里面<code>key</code>和<code>value</code>都没什么可说的，但是第三个参数可以拉出来看看。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="built_in">enum</span> InsertionBehavior : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    OverwriteExisting, <span class="comment">// 如果存在重复Key重新赋值</span></span><br><span class="line">    ThrowOnExisting, <span class="comment">// 如果存在重复Key抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个参数将会在一会源码中看到用途，现在有个印象即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class="line">    <span class="built_in">uint</span> hashCode = (<span class="built_in">uint</span>)((comparer == <span class="literal">null</span>) ? key.GetHashCode() : comparer.GetHashCode(key));</span><br></pre></td></tr></table></figure>
<p>根据<code>key</code>的值或者<code>comparer</code>来计算<code>hashCode</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uint</span> collisionCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">ref</span> <span class="built_in">int</span> bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">hashCode</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> i = bucket - <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">GetBucket</span>(<span class="params"><span class="built_in">uint</span> hashCode</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] buckets = _buckets!;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_64BIT</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span> buckets[HashHelpers.FastMod(hashCode, (<span class="built_in">uint</span>)buckets.Length, _fastModMultiplier)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ref</span> buckets[hashCode % (<span class="built_in">uint</span>)buckets.Length];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>hashCode</code>计算出应该选择哪个桶。</p>
<p>接卸来大致逻辑可以简单拆成</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(comparer == <span class="literal">null</span>) <span class="comment">//是否自己实现了比较器</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span>(TKey).IsValueType)&#123;&#125; <span class="comment">//Key是否是值类型</span></span><br><span class="line">	<span class="keyword">else</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;&#125; <span class="comment">//下面看这个else的内容</span></span><br></pre></td></tr></table></figure>
<p>在具体代码内部中其实都差不多，所以这里选择看实现比较器的部分(也就是注释中说的哪个<code>else</code>)。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">        <span class="comment">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class="line">            &#123;</span><br><span class="line">                entries[i].<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class="line">            &#123;</span><br><span class="line">                ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = entries[i].next;</span><br><span class="line"></span><br><span class="line">        collisionCount++;</span><br><span class="line">        <span class="keyword">if</span> (collisionCount &gt; (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">            <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">            ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部一个死循环，这部分循环有个点是比较隐藏的，那就是如何跳出这个碰撞检测。</p>
<p>如果不发生碰撞冲突，<code>int i = bucket - 1</code>根据这个结果即可算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。发生碰撞的话就要分类讨论了，具体可以看源码。当然最终跳出的方案不是返回一个值就是将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>赋值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后看这里的逻辑，在<code>uint</code>也就是无符号整数型下，<code>i</code>的大小将会是最大的，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>的底层表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11111111</mn></mrow><annotation encoding="application/x-tex">11111111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11111111</span></span></span></span>。</p>
<blockquote>
<p>当然实际肯定不是八位，这里只是为了简单描述。</p>
<p>具体是为什么可以看一下csapp或者原码、反码、补码的知识。</p>
</blockquote>
<p>在这里就出现了上面提到过的参数<code>InsertionBehavior</code>枚举。很明显，如果允许覆盖就覆盖，不允许就抛出异常。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> index;</span><br><span class="line"><span class="keyword">if</span> (_freeCount &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    index = _freeList;</span><br><span class="line">    Debug.Assert((StartOfFreeList - entries[_freeList].next) &gt;= <span class="number">-1</span>, <span class="string">&quot;shouldn&#x27;t overflow because `next` cannot underflow&quot;</span>);</span><br><span class="line">    _freeList = StartOfFreeList - entries[_freeList].next;</span><br><span class="line">    _freeCount--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> count = _count;</span><br><span class="line">    <span class="keyword">if</span> (count == entries.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        Resize();</span><br><span class="line">        bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">hashCode</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index = count;</span><br><span class="line">    _count = count + <span class="number">1</span>;</span><br><span class="line">    entries = _entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择合适的位置放入数据。</p>
<p><code>freeCount和freeList</code>在后面<code>Remove</code>中再说，不过同样都是为了选择位置。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ref</span> Entry entry = <span class="keyword">ref</span> entries![index];</span><br><span class="line">entry.hashCode = hashCode;</span><br><span class="line">entry.next = bucket - <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line">entry.key = key;</span><br><span class="line">entry.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">bucket = index + <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line">_version++;</span><br></pre></td></tr></table></figure>
<p>最终<code>Add()</code>调用结束后的数值记录。</p>
<h3 id="Remove">Remove</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">TKey key</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_buckets != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">uint</span> collisionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">uint</span> hashCode = (<span class="built_in">uint</span>)(_comparer?.GetHashCode(key) ?? key.GetHashCode());</span><br><span class="line">    <span class="keyword">ref</span> <span class="built_in">int</span> bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">hashCode</span>)</span>;</span><br><span class="line">    Entry[]? entries = _entries;</span><br><span class="line">    <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">int</span> i = bucket - <span class="number">1</span>; <span class="comment">// Value in buckets is 1-based</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>下一段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>同样还是同过key获取HashCode之后找到桶的位置。<code>last</code>用于确定最后一个元素的位置。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ref</span> Entry entry = <span class="keyword">ref</span> entries[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp;</span><br><span class="line">        (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//下一段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last = i;</span><br><span class="line">    i = entry.next;</span><br><span class="line"></span><br><span class="line">    collisionCount++;</span><br><span class="line">    <span class="keyword">if</span> (collisionCount &gt; (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">        <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">        ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历在同一个桶的<code>entry</code>直到找到目标元素，或者是碰撞次数过多抛出异常。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp; (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;   <span class="comment">// 代表当前是桶的最后一个元素，那么直接赋值即可</span></span><br><span class="line">        bucket = entry.next + <span class="number">1</span>; <span class="comment">// Value in buckets is 1-based</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;	<span class="comment">// 代表当前元素处于链表中间，如果直接删掉会导致链表断开，所以让其头尾相连</span></span><br><span class="line">        entries[last].next = entry.next;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 这里去看entry源码部分</span></span><br><span class="line">    entry.next = StartOfFreeList - _freeList;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// entry内部数据初始化</span></span><br><span class="line">    <span class="keyword">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TKey&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        entry.key = <span class="literal">default</span>!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TValue&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        entry.<span class="keyword">value</span> = <span class="literal">default</span>!;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 让freeList等于当前位置</span></span><br><span class="line">    _freeList = i;</span><br><span class="line">    _freeCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就提到了<code>freeList</code>的作用，可以使下一次<code>Add</code>选择该位置</p>
<h3 id="FindValue">FindValue</h3>
<p>因为还是要区分是否存在比较器来分类讨论，依旧选择存在。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uint</span> hashCode = (<span class="built_in">uint</span>)comparer.GetHashCode(key);</span><br><span class="line"><span class="built_in">int</span> i = GetBucket(hashCode);</span><br><span class="line">Entry[]? entries = _entries;</span><br><span class="line"><span class="built_in">uint</span> collisionCount = <span class="number">0</span>;</span><br><span class="line">i--; <span class="comment">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">    <span class="comment">// Test in if to drop range check for following array access</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> ReturnNotFound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry = <span class="keyword">ref</span> entries[i];</span><br><span class="line">    <span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp; comparer.Equals(entry.key, key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> ReturnFound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = entry.next;</span><br><span class="line"></span><br><span class="line">    collisionCount++;</span><br><span class="line">&#125; <span class="keyword">while</span> (collisionCount &lt;= (<span class="built_in">uint</span>)entries.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line"><span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line"><span class="keyword">goto</span> ConcurrentOperation;</span><br></pre></td></tr></table></figure>
<p>经历了前面增删，这个查找其实变得就很清晰。说白了就是在桶里面跑一边找到就返回，找不到就寄。</p>
<p>不过需要注意的是这里面用了很多<code>goto</code>建议在目录大致过一遍即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部</span></span><br><span class="line">ConcurrentOperation:</span><br><span class="line">	ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">ReturnFound:</span><br><span class="line">	<span class="keyword">ref</span> TValue <span class="keyword">value</span> = <span class="keyword">ref</span> entry.<span class="keyword">value</span>;</span><br><span class="line">Return:</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">ref</span> <span class="keyword">value</span>;</span><br><span class="line">ReturnNotFound:</span><br><span class="line">	<span class="keyword">value</span> = <span class="keyword">ref</span> Unsafe.NullRef&lt;TValue&gt;();</span><br><span class="line"><span class="keyword">goto</span> Return;</span><br></pre></td></tr></table></figure>
<p>说实话，这是我第一次见到<code>goto</code>。。。</p>
<h3 id="Resize">Resize</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"></span>)</span> =&gt; Resize(HashHelpers.ExpandPrime(_count), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>HashHelpers.ExpandPrime(_count)</code>方法可以在目录中源码寻找，不过这里大致就理解成<strong>大于两倍大小的最小素数</strong>就行了</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//精简版，完整版看目录</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"><span class="built_in">int</span> newSize, <span class="built_in">bool</span> forceNewHashCodes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Entry[] entries = <span class="keyword">new</span> Entry[newSize];</span><br><span class="line">    <span class="built_in">int</span> count = _count;</span><br><span class="line">    Array.Copy(_entries, entries, count);</span><br><span class="line">    <span class="comment">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class="line">    _buckets = <span class="keyword">new</span> <span class="built_in">int</span>[newSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (entries[i].next &gt;= <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">ref</span> <span class="built_in">int</span> bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">entries[i].hashCode</span>)</span>;</span><br><span class="line">            entries[i].next = bucket - <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line">            bucket = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _entries = entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出扩容操作其实就是，申请新的<code>Entry</code>和<code>buckets</code>，之后将现有的元素拷贝进去。</p>
<h2 id="索引器">索引器</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TValue <span class="keyword">this</span>[TKey key]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ref</span> TValue <span class="keyword">value</span> = <span class="function"><span class="keyword">ref</span> <span class="title">FindValue</span>(<span class="params">key</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Unsafe.IsNullRef(<span class="keyword">ref</span> <span class="keyword">value</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThrowHelper.ThrowKeyNotFoundException(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> modified = TryInsert(key, <span class="keyword">value</span>, InsertionBehavior.OverwriteExisting);</span><br><span class="line">        Debug.Assert(modified);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>既查找是否有<code>key</code>。</p>
<p><code>set</code>即插入。注意参数为<code>InsertionBehavior.OverwriteExisting</code>，所以可以覆盖元素。</p>
<h2 id="迭代器">迭代器</h2>
<p>这里虽然我还没有写！！但是在<code>foreach</code>中是可以删除元素的，不能增加元素，看了源码，会发现删除不会修改版本号。！！</p>
<h2 id="源码目录">源码目录</h2>
<h3 id="HashHelpers类部分源码">HashHelpers类部分源码</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Licensed to the .NET Foundation under one or more agreements.</span></span><br><span class="line"><span class="comment">// The .NET Foundation licenses this file to you under the MIT license.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System.Collections</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">HashHelpers</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">uint</span> HashCollisionThreshold = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is the maximum prime smaller than Array.MaxLength.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MaxPrimeArrayLength = <span class="number">0x7FFFFFC3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> HashPrime = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Table of prime numbers to use as hash table sizes.</span></span><br><span class="line">        <span class="comment">// A typical resize algorithm would pick the smallest prime number in this array</span></span><br><span class="line">        <span class="comment">// that is larger than twice the previous capacity.</span></span><br><span class="line">        <span class="comment">// Suppose our Hashtable currently has capacity x and enough elements are added</span></span><br><span class="line">        <span class="comment">// such that a resize needs to occur. Resizing first computes 2x then finds the</span></span><br><span class="line">        <span class="comment">// first prime in the table greater than 2x, i.e. if primes are ordered</span></span><br><span class="line">        <span class="comment">// p_1, p_2, ..., p_i, ..., it finds p_n such that p_n-1 &lt; 2x &lt; p_n.</span></span><br><span class="line">        <span class="comment">// Doubling is important for preserving the asymptotic complexity of the</span></span><br><span class="line">        <span class="comment">// hashtable operations such as add.  Having a prime guarantees that double</span></span><br><span class="line">        <span class="comment">// hashing does not lead to infinite loops.  IE, your hash function will be</span></span><br><span class="line">        <span class="comment">// h1(key) + i*h2(key), 0 &lt;= i &lt; size.  h2 and the size must be relatively prime.</span></span><br><span class="line">        <span class="comment">// We prefer the low computation costs of higher prime numbers over the increased</span></span><br><span class="line">        <span class="comment">// memory allocation of a fixed prime number i.e. when right sizing a HashSet.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span>[] s_primes =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">89</span>, <span class="number">107</span>, <span class="number">131</span>, <span class="number">163</span>, <span class="number">197</span>, <span class="number">239</span>, <span class="number">293</span>, <span class="number">353</span>, <span class="number">431</span>, <span class="number">521</span>, <span class="number">631</span>, <span class="number">761</span>, <span class="number">919</span>,</span><br><span class="line">            <span class="number">1103</span>, <span class="number">1327</span>, <span class="number">1597</span>, <span class="number">1931</span>, <span class="number">2333</span>, <span class="number">2801</span>, <span class="number">3371</span>, <span class="number">4049</span>, <span class="number">4861</span>, <span class="number">5839</span>, <span class="number">7013</span>, <span class="number">8419</span>, <span class="number">10103</span>, <span class="number">12143</span>, <span class="number">14591</span>,</span><br><span class="line">            <span class="number">17519</span>, <span class="number">21023</span>, <span class="number">25229</span>, <span class="number">30293</span>, <span class="number">36353</span>, <span class="number">43627</span>, <span class="number">52361</span>, <span class="number">62851</span>, <span class="number">75431</span>, <span class="number">90523</span>, <span class="number">108631</span>, <span class="number">130363</span>, <span class="number">156437</span>,</span><br><span class="line">            <span class="number">187751</span>, <span class="number">225307</span>, <span class="number">270371</span>, <span class="number">324449</span>, <span class="number">389357</span>, <span class="number">467237</span>, <span class="number">560689</span>, <span class="number">672827</span>, <span class="number">807403</span>, <span class="number">968897</span>, <span class="number">1162687</span>, <span class="number">1395263</span>,</span><br><span class="line">            <span class="number">1674319</span>, <span class="number">2009191</span>, <span class="number">2411033</span>, <span class="number">2893249</span>, <span class="number">3471899</span>, <span class="number">4166287</span>, <span class="number">4999559</span>, <span class="number">5999471</span>, <span class="number">7199369</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsPrime</span>(<span class="params"><span class="built_in">int</span> candidate</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((candidate &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> limit = (<span class="built_in">int</span>)Math.Sqrt(candidate);</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> divisor = <span class="number">3</span>; divisor &lt;= limit; divisor += <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((candidate % divisor) == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> candidate == <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetPrime</span>(<span class="params"><span class="built_in">int</span> min</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(SR.Arg_HTCapacityOverflow);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> prime <span class="keyword">in</span> s_primes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prime &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span> prime;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Outside of our predefined table. Compute the hard way.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = (min | <span class="number">1</span>); i &lt; <span class="built_in">int</span>.MaxValue; i += <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (IsPrime(i) &amp;&amp; ((i - <span class="number">1</span>) % HashPrime != <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns size of hashtable to grow to.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ExpandPrime</span>(<span class="params"><span class="built_in">int</span> oldSize</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> newSize = <span class="number">2</span> * oldSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Allow the hashtables to grow to maximum possible size (~2G elements) before encountering capacity overflow.</span></span><br><span class="line">            <span class="comment">// Note that this check works even when _items.Length overflowed thanks to the (uint) cast</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">uint</span>)newSize &gt; MaxPrimeArrayLength &amp;&amp; MaxPrimeArrayLength &gt; oldSize)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Assert(MaxPrimeArrayLength == GetPrime(MaxPrimeArrayLength), <span class="string">&quot;Invalid MaxPrimeArrayLength&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> MaxPrimeArrayLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> GetPrime(newSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>This should only be used on 64-bit.<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">ulong</span> <span class="title">GetFastModMultiplier</span>(<span class="params"><span class="built_in">uint</span> divisor</span>)</span> =&gt;</span><br><span class="line">            <span class="built_in">ulong</span>.MaxValue / divisor + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>Performs a mod operation using the multiplier pre-computed with <span class="doctag">&lt;see cref=&quot;GetFastModMultiplier&quot;/&gt;</span>.<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span>This should only be used on 64-bit.<span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        [<span class="meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">uint</span> <span class="title">FastMod</span>(<span class="params"><span class="built_in">uint</span> <span class="keyword">value</span>, <span class="built_in">uint</span> divisor, <span class="built_in">ulong</span> multiplier</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We use modified Daniel Lemire&#x27;s fastmod algorithm (https://github.com/dotnet/runtime/pull/406),</span></span><br><span class="line">            <span class="comment">// which allows to avoid the long multiplication if the divisor is less than 2**31.</span></span><br><span class="line">            Debug.Assert(divisor &lt;= <span class="built_in">int</span>.MaxValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is equivalent of (uint)Math.BigMul(multiplier * value, divisor, out _). This version</span></span><br><span class="line">            <span class="comment">// is faster than BigMul currently because we only need the high bits.</span></span><br><span class="line">            <span class="built_in">uint</span> highbits = (<span class="built_in">uint</span>)(((((multiplier * <span class="keyword">value</span>) &gt;&gt; <span class="number">32</span>) + <span class="number">1</span>) * divisor) &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">            Debug.Assert(highbits == <span class="keyword">value</span> % divisor);</span><br><span class="line">            <span class="keyword">return</span> highbits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TryInsert源码">TryInsert源码</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">TryInsert</span>(<span class="params">TKey key, TValue <span class="keyword">value</span>, InsertionBehavior behavior</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> this method is mirrored in CollectionsMarshal.GetValueRefOrAddDefault below.</span></span><br><span class="line">    <span class="comment">// If you make any changes here, make sure to keep that version in sync as well.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_buckets == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Initialize(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Assert(_buckets != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    Entry[]? entries = _entries;</span><br><span class="line">    Debug.Assert(entries != <span class="literal">null</span>, <span class="string">&quot;expected entries to be non-null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class="line">    <span class="built_in">uint</span> hashCode = (<span class="built_in">uint</span>)((comparer == <span class="literal">null</span>) ? key.GetHashCode() : comparer.GetHashCode(key));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uint</span> collisionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ref</span> <span class="built_in">int</span> bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">hashCode</span>)</span>;</span><br><span class="line">    <span class="built_in">int</span> i = bucket - <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparer == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span>(TKey).IsValueType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">                <span class="comment">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entries[i].key, key))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class="line">                    &#123;</span><br><span class="line">                        entries[i].<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i = entries[i].next;</span><br><span class="line"></span><br><span class="line">                collisionCount++;</span><br><span class="line">                <span class="keyword">if</span> (collisionCount &gt; (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">                    <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Object type: Shared Generic, EqualityComparer&lt;TValue&gt;.Default won&#x27;t devirtualize</span></span><br><span class="line">            <span class="comment">// https://github.com/dotnet/runtime/issues/10050</span></span><br><span class="line">            <span class="comment">// So cache in a local rather than get EqualityComparer per loop iteration</span></span><br><span class="line">            EqualityComparer&lt;TKey&gt; defaultComparer = EqualityComparer&lt;TKey&gt;.Default;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">                <span class="comment">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; defaultComparer.Equals(entries[i].key, key))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class="line">                    &#123;</span><br><span class="line">                        entries[i].<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i = entries[i].next;</span><br><span class="line"></span><br><span class="line">                collisionCount++;</span><br><span class="line">                <span class="keyword">if</span> (collisionCount &gt; (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">                    <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">            <span class="comment">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class="line">                &#123;</span><br><span class="line">                    entries[i].<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class="line">                &#123;</span><br><span class="line">                    ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i = entries[i].next;</span><br><span class="line"></span><br><span class="line">            collisionCount++;</span><br><span class="line">            <span class="keyword">if</span> (collisionCount &gt; (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">                <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> index;</span><br><span class="line">    <span class="keyword">if</span> (_freeCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        index = _freeList;</span><br><span class="line">        Debug.Assert((StartOfFreeList - entries[_freeList].next) &gt;= <span class="number">-1</span>, <span class="string">&quot;shouldn&#x27;t overflow because `next` cannot underflow&quot;</span>);</span><br><span class="line">        _freeList = StartOfFreeList - entries[_freeList].next;</span><br><span class="line">        _freeCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> count = _count;</span><br><span class="line">        <span class="keyword">if</span> (count == entries.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            Resize();</span><br><span class="line">            bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">hashCode</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = count;</span><br><span class="line">        _count = count + <span class="number">1</span>;</span><br><span class="line">        entries = _entries;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ref</span> Entry entry = <span class="keyword">ref</span> entries![index];</span><br><span class="line">    entry.hashCode = hashCode;</span><br><span class="line">    entry.next = bucket - <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line">    entry.key = key;</span><br><span class="line">    entry.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    bucket = index + <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line">    _version++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value types never rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">typeof</span>(TKey).IsValueType &amp;&amp; collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; comparer <span class="keyword">is</span> NonRandomizedStringEqualityComparer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If we hit the collision threshold we&#x27;ll need to switch to the comparer which is using randomized string hashing</span></span><br><span class="line">        <span class="comment">// i.e. EqualityComparer&lt;string&gt;.Default.</span></span><br><span class="line">        Resize(entries.Length, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Resize源码">Resize源码</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"></span>)</span> =&gt; Resize(HashHelpers.ExpandPrime(_count), <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"><span class="built_in">int</span> newSize, <span class="built_in">bool</span> forceNewHashCodes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Value types never rehash</span></span><br><span class="line">    Debug.Assert(!forceNewHashCodes || !<span class="keyword">typeof</span>(TKey).IsValueType);</span><br><span class="line">    Debug.Assert(_entries != <span class="literal">null</span>, <span class="string">&quot;_entries should be non-null&quot;</span>);</span><br><span class="line">    Debug.Assert(newSize &gt;= _entries.Length);</span><br><span class="line"></span><br><span class="line">    Entry[] entries = <span class="keyword">new</span> Entry[newSize];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> count = _count;</span><br><span class="line">    Array.Copy(_entries, entries, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">typeof</span>(TKey).IsValueType &amp;&amp; forceNewHashCodes)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Assert(_comparer <span class="keyword">is</span> NonRandomizedStringEqualityComparer);</span><br><span class="line">        _comparer = (IEqualityComparer&lt;TKey&gt;)((NonRandomizedStringEqualityComparer)_comparer)</span><br><span class="line">            .GetRandomizedEqualityComparer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (entries[i].next &gt;= <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                entries[i].hashCode = (<span class="built_in">uint</span>)_comparer.GetHashCode(entries[i].key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ReferenceEquals(_comparer, EqualityComparer&lt;TKey&gt;.Default))</span><br><span class="line">        &#123;</span><br><span class="line">            _comparer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class="line">    _buckets = <span class="keyword">new</span> <span class="built_in">int</span>[newSize];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_64BIT</span></span><br><span class="line">            _fastModMultiplier = HashHelpers.GetFastModMultiplier((<span class="built_in">uint</span>)newSize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (entries[i].next &gt;= <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">ref</span> <span class="built_in">int</span> bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">entries[i].hashCode</span>)</span>;</span><br><span class="line">            entries[i].next = bucket - <span class="number">1</span>; <span class="comment">// Value in _buckets is 1-based</span></span><br><span class="line">            bucket = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _entries = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Remove源码">Remove源码</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">TKey key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The overload Remove(TKey key, out TValue value) is a copy of this method with one additional</span></span><br><span class="line">    <span class="comment">// statement to copy the value for entry being removed into the output parameter.</span></span><br><span class="line">    <span class="comment">// Code has been intentionally duplicated for performance reasons.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_buckets != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Assert(_entries != <span class="literal">null</span>, <span class="string">&quot;entries should be non-null&quot;</span>);</span><br><span class="line">        <span class="built_in">uint</span> collisionCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">uint</span> hashCode = (<span class="built_in">uint</span>)(_comparer?.GetHashCode(key) ?? key.GetHashCode());</span><br><span class="line">        <span class="keyword">ref</span> <span class="built_in">int</span> bucket = <span class="function"><span class="keyword">ref</span> <span class="title">GetBucket</span>(<span class="params">hashCode</span>)</span>;</span><br><span class="line">        Entry[]? entries = _entries;</span><br><span class="line">        <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> i = bucket - <span class="number">1</span>; <span class="comment">// Value in buckets is 1-based</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">ref</span> Entry entry = <span class="keyword">ref</span> entries[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp;</span><br><span class="line">                (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (last &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bucket = entry.next + <span class="number">1</span>; <span class="comment">// Value in buckets is 1-based</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    entries[last].next = entry.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Debug.Assert((StartOfFreeList - _freeList) &lt; <span class="number">0</span>,</span><br><span class="line">                    <span class="string">&quot;shouldn&#x27;t underflow because max hashtable length is MaxPrimeArrayLength = 0x7FEFFFFD(2146435069) _freelist underflow threshold 2147483646&quot;</span>);</span><br><span class="line">                entry.next = StartOfFreeList - _freeList;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TKey&gt;())</span><br><span class="line">                &#123;</span><br><span class="line">                    entry.key = <span class="literal">default</span>!;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TValue&gt;())</span><br><span class="line">                &#123;</span><br><span class="line">                    entry.<span class="keyword">value</span> = <span class="literal">default</span>!;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _freeList = i;</span><br><span class="line">                _freeCount++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            last = i;</span><br><span class="line">            i = entry.next;</span><br><span class="line"></span><br><span class="line">            collisionCount++;</span><br><span class="line">            <span class="keyword">if</span> (collisionCount &gt; (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">                <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FindValue源码">FindValue源码</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">ref</span> TValue <span class="title">FindValue</span>(<span class="params">TKey key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ref</span> Entry entry = <span class="keyword">ref</span> Unsafe.NullRef&lt;Entry&gt;();</span><br><span class="line">    <span class="keyword">if</span> (_buckets != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Assert(_entries != <span class="literal">null</span>, <span class="string">&quot;expected entries to be != null&quot;</span>);</span><br><span class="line">        IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class="line">        <span class="keyword">if</span> (comparer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">uint</span> hashCode = (<span class="built_in">uint</span>)key.GetHashCode();</span><br><span class="line">            <span class="built_in">int</span> i = GetBucket(hashCode);</span><br><span class="line">            Entry[]? entries = _entries;</span><br><span class="line">            <span class="built_in">uint</span> collisionCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span>(TKey).IsValueType)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span></span><br><span class="line"></span><br><span class="line">                i--; <span class="comment">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">                    <span class="comment">// Test in if to drop range check for following array access</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">goto</span> ReturnNotFound;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    entry = <span class="keyword">ref</span> entries[i];</span><br><span class="line">                    <span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">goto</span> ReturnFound;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    i = entry.next;</span><br><span class="line"></span><br><span class="line">                    collisionCount++;</span><br><span class="line">                &#125; <span class="keyword">while</span> (collisionCount &lt;= (<span class="built_in">uint</span>)entries.Length);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">                <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">                <span class="keyword">goto</span> ConcurrentOperation;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Object type: Shared Generic, EqualityComparer&lt;TValue&gt;.Default won&#x27;t devirtualize</span></span><br><span class="line">                <span class="comment">// https://github.com/dotnet/runtime/issues/10050</span></span><br><span class="line">                <span class="comment">// So cache in a local rather than get EqualityComparer per loop iteration</span></span><br><span class="line">                EqualityComparer&lt;TKey&gt; defaultComparer = EqualityComparer&lt;TKey&gt;.Default;</span><br><span class="line"></span><br><span class="line">                i--; <span class="comment">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">                    <span class="comment">// Test in if to drop range check for following array access</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">goto</span> ReturnNotFound;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    entry = <span class="keyword">ref</span> entries[i];</span><br><span class="line">                    <span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp; defaultComparer.Equals(entry.key, key))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">goto</span> ReturnFound;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    i = entry.next;</span><br><span class="line"></span><br><span class="line">                    collisionCount++;</span><br><span class="line">                &#125; <span class="keyword">while</span> (collisionCount &lt;= (<span class="built_in">uint</span>)entries.Length);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">                <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">                <span class="keyword">goto</span> ConcurrentOperation;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">uint</span> hashCode = (<span class="built_in">uint</span>)comparer.GetHashCode(key);</span><br><span class="line">            <span class="built_in">int</span> i = GetBucket(hashCode);</span><br><span class="line">            Entry[]? entries = _entries;</span><br><span class="line">            <span class="built_in">uint</span> collisionCount = <span class="number">0</span>;</span><br><span class="line">            i--; <span class="comment">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class="line">                <span class="comment">// Test in if to drop range check for following array access</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">uint</span>)i &gt;= (<span class="built_in">uint</span>)entries.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">goto</span> ReturnNotFound;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                entry = <span class="keyword">ref</span> entries[i];</span><br><span class="line">                <span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp; comparer.Equals(entry.key, key))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">goto</span> ReturnFound;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i = entry.next;</span><br><span class="line"></span><br><span class="line">                collisionCount++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (collisionCount &lt;= (<span class="built_in">uint</span>)entries.Length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class="line">            <span class="comment">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class="line">            <span class="keyword">goto</span> ConcurrentOperation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> ReturnNotFound;</span><br><span class="line"></span><br><span class="line">ConcurrentOperation:</span><br><span class="line">    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class="line">ReturnFound:</span><br><span class="line">    <span class="keyword">ref</span> TValue <span class="keyword">value</span> = <span class="keyword">ref</span> entry.<span class="keyword">value</span>;</span><br><span class="line">Return:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ref</span> <span class="keyword">value</span>;</span><br><span class="line">ReturnNotFound:</span><br><span class="line">    <span class="keyword">value</span> = <span class="keyword">ref</span> Unsafe.NullRef&lt;TValue&gt;();</span><br><span class="line">    <span class="keyword">goto</span> Return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">好饿殿</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hungryhighness.github.io/2022/02/23/Dictionary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://hungryhighness.github.io/2022/02/23/Dictionary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hungryhighness.github.io" target="_blank">好饿殿の小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c#</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/02/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"><img class="prev-cover" src="https://i.loli.net/2021/11/22/eHGML2aYUcPmnvK.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试经历</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/23/List%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="next-cover" src="https://i.loli.net/2021/11/22/eHGML2aYUcPmnvK.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">List源码解析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/05/CS%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="CS面试基础知识"><img class="cover" src="https://i.loli.net/2021/11/22/RgqZl1rK3OIPpLi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-05</div><div class="title">CS面试基础知识</div></div></a></div><div><a href="/2022/02/23/List%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="List源码解析"><img class="cover" src="https://i.loli.net/2021/11/22/eHGML2aYUcPmnvK.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">List源码解析</div></div></a></div><div><a href="/2022/01/19/%E5%85%AC%E5%85%B1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/" title="公共语言基础结构"><img class="cover" src="https://i.loli.net/2021/11/22/RgqZl1rK3OIPpLi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-19</div><div class="title">公共语言基础结构</div></div></a></div><div><a href="/2022/02/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="算法与数据结构"><img class="cover" src="https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-05</div><div class="title">算法与数据结构</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">好饿殿</div><div class="author-info__description">一个喜欢玩乙游的男程序猿(</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HungryHighness" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://message/?uin=923618834" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:HungryHighness@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Dictionary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Dictionary源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">Hash算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E6%A1%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">Hash桶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%A2%B0%E6%92%9E"><span class="toc-number">1.1.3.</span> <span class="toc-text">Hash碰撞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">拉链法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">线性探测法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dictionary%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">Dictionary构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E5%88%86API"><span class="toc-number">1.3.</span> <span class="toc-text">部分API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Add"><span class="toc-number">1.3.1.</span> <span class="toc-text">Add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove"><span class="toc-number">1.3.2.</span> <span class="toc-text">Remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FindValue"><span class="toc-number">1.3.3.</span> <span class="toc-text">FindValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resize"><span class="toc-number">1.3.4.</span> <span class="toc-text">Resize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">索引器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95"><span class="toc-number">1.6.</span> <span class="toc-text">源码目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashHelpers%E7%B1%BB%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81"><span class="toc-number">1.6.1.</span> <span class="toc-text">HashHelpers类部分源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TryInsert%E6%BA%90%E7%A0%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">TryInsert源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resize%E6%BA%90%E7%A0%81"><span class="toc-number">1.6.3.</span> <span class="toc-text">Resize源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove%E6%BA%90%E7%A0%81"><span class="toc-number">1.6.4.</span> <span class="toc-text">Remove源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FindValue%E6%BA%90%E7%A0%81"><span class="toc-number">1.6.5.</span> <span class="toc-text">FindValue源码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/02/Lua%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="Lua设计与实现读书笔记"><img src="https://i.loli.net/2021/11/22/qvfB7Vk1hZiAJ3G.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua设计与实现读书笔记"/></a><div class="content"><a class="title" href="/2022/05/02/Lua%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="Lua设计与实现读书笔记">Lua设计与实现读书笔记</a><time datetime="2022-05-02T12:48:59.000Z" title="发表于 2022-05-02 20:48:59">2022-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/03/xlua%E8%B8%A9%E5%9D%91/" title="xlua踩坑"><img src="https://i.loli.net/2021/11/22/RgqZl1rK3OIPpLi.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xlua踩坑"/></a><div class="content"><a class="title" href="/2022/03/03/xlua%E8%B8%A9%E5%9D%91/" title="xlua踩坑">xlua踩坑</a><time datetime="2022-03-03T15:04:50.000Z" title="发表于 2022-03-03 23:04:50">2022-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/02/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/" title="面试经历"><img src="https://i.loli.net/2021/11/22/eHGML2aYUcPmnvK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经历"/></a><div class="content"><a class="title" href="/2022/03/02/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/" title="面试经历">面试经历</a><time datetime="2022-03-02T09:35:52.000Z" title="发表于 2022-03-02 17:35:52">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/23/Dictionary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Dictionary源码解析"><img src="https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dictionary源码解析"/></a><div class="content"><a class="title" href="/2022/02/23/Dictionary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Dictionary源码解析">Dictionary源码解析</a><time datetime="2022-02-23T08:26:01.000Z" title="发表于 2022-02-23 16:26:01">2022-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/23/List%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="List源码解析"><img src="https://i.loli.net/2021/11/22/eHGML2aYUcPmnvK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="List源码解析"/></a><div class="content"><a class="title" href="/2022/02/23/List%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="List源码解析">List源码解析</a><time datetime="2022-02-23T05:34:21.000Z" title="发表于 2022-02-23 13:34:21">2022-02-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 好饿殿</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
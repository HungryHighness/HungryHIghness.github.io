{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/img/1.png","path":"img/1.png","modified":1,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/background.png","path":"img/background.png","modified":1,"renderable":0},{"_id":"source/img/cover_1.png","path":"img/cover_1.png","modified":1,"renderable":0},{"_id":"source/img/favicon.jpg","path":"img/favicon.jpg","modified":1,"renderable":0},{"_id":"source/img/background_2.jpg","path":"img/background_2.jpg","modified":1,"renderable":0},{"_id":"source/img/psc.jpg","path":"img/psc.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"4ad24a8b725eb0594d5e3ef3dd546272c1e69d69","modified":1640278727458},{"_id":"source/_data/link.yml","hash":"fffbf68c4a864a9d54537e2dc938108a4bacc934","modified":1645813574812},{"_id":"source/_posts/Dictionary源码解析.md","hash":"0e0506677ebe636b6b0d3c07555180597a818b15","modified":1651495815651},{"_id":"source/_posts/CS面试基础知识.md","hash":"014d50cf9071cb4d63a503360c292ac384643778","modified":1651495857966},{"_id":"source/_posts/leetcode.md","hash":"3a29a0b913fe01b96ef78a1fbb6c99b906a74920","modified":1641734750780},{"_id":"source/_posts/Lua设计与实现读书笔记.md","hash":"de8345627ed12909cd7befb050ff3756ec172f76","modified":1653159994251},{"_id":"source/_posts/剑指Offer.md","hash":"08995f35e98f0e709274b42a4f3ba64e36fd4987","modified":1657989212394},{"_id":"source/_posts/公共语言基础结构.md","hash":"2698891b565f3c456a53695e9a9173b0e23ac8c0","modified":1651496072245},{"_id":"source/_posts/List源码解析.md","hash":"7df2f8a875dbfb1b5ab9330e8c7fc6abe0520332","modified":1651495827604},{"_id":"source/_posts/算法与数据结构.md","hash":"3245d35d3e46ebdce576f8a01fb04a62a06cf71f","modified":1651495846902},{"_id":"source/categories/index.md","hash":"ae340f099d6b6e7eff970e6520a9065732e33eed","modified":1635070601834},{"_id":"source/_posts/xlua踩坑.md","hash":"cd1188f1c69c01e1718c3cee914d36f93159021e","modified":1646373113743},{"_id":"source/_posts/面试经历.md","hash":"9e9727c23908a094b634ddafc0efaad7a19b28d1","modified":1646816311837},{"_id":"source/img/cover_1.png","hash":"0f0e26842fddc5cac701837d60f2791bab909873","modified":1640071292211},{"_id":"source/_posts/CS面试基础知识/RX_36I`V7SC3ZSYNM~EMC{T.png","hash":"96ad1c1e5c9662c2290c2e90df8b89e8d9b2fc1c","modified":1644064660205},{"_id":"source/tags/index.md","hash":"1b5b0d109bfac93bd57c487db63b17a31e16fd84","modified":1635070631425},{"_id":"source/link/index.md","hash":"29af8760406bf382fe0ffbe76e9bf4678dce72a8","modified":1638368328816},{"_id":"source/_posts/操作系统/操作系统.md","hash":"2dd35626085105b1b7459e9ccadcc711a6da1c74","modified":1640336752570},{"_id":"source/img/favicon.jpg","hash":"f909901855f432850a03f208b22cc07d4b13625c","modified":1637340698935},{"_id":"source/img/psc.jpg","hash":"e63a56d59624f7d7cc8c307a7453873b7331f43d","modified":1637341839497},{"_id":"source/_posts/Lua设计与实现读书笔记/1.png","hash":"095063e9e63ea0488695a28c384b1e23715193b1","modified":1652205969953},{"_id":"source/_posts/Lua设计与实现读书笔记/}179[UY3OP~C{R3)L0G%KZW.png","hash":"5b14e4fa77562e0faef43e87be49176014dad2a2","modified":1652206865414},{"_id":"themes/butterfly/package.json","hash":"6a5ddc166980502757c1413b5e04a3a8a91c0a48","modified":1635829734398},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1635829734358},{"_id":"themes/butterfly/_config.yml","hash":"d9593b423071020f7b970dd932128be03b9ad3e3","modified":1635829734360},{"_id":"themes/butterfly/README.md","hash":"0f0eaee9c30ef1e9aed588fbb3e8263401348b55","modified":1635829734358},{"_id":"themes/butterfly/layout/category.pug","hash":"5ac3cd8172088843cec03175c612a9c85f49cf2e","modified":1635829734362},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1635829734397},{"_id":"themes/butterfly/README_CN.md","hash":"70ec43a8aa0776b5a0a2a6b6009dd253fa3679eb","modified":1635829734359},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1635829734362},{"_id":"themes/butterfly/layout/page.pug","hash":"cae76ce64c114fd192b5da5a7d14aa0240df2f06","modified":1635829734397},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1635829734357},{"_id":"themes/butterfly/languages/default.yml","hash":"b9dbdb20bd1f1c7ca8a8f38635bdc4ed8bb1d44c","modified":1635829734360},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1635829734357},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1635829734398},{"_id":"themes/butterfly/languages/en.yml","hash":"fd1c1211c8f166d089a7697872185a81182d92e1","modified":1635829734361},{"_id":"themes/butterfly/layout/post.pug","hash":"8f2f13c9ae099dd83827ce3dbac5abc8d7d5bde3","modified":1635829734398},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"46685048a05b419ed9c72cf31bd6e5efef7524f2","modified":1635829734361},{"_id":"themes/butterfly/scripts/events/init.js","hash":"5803aa55d9c21e51ea64c1ae50c9b602979aaee2","modified":1635829734399},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1635829734400},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"736bec8eeb3a29d0d43669d81f1fa686e02be18e","modified":1635829734362},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1635829734399},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"98ef86305b8d2ad9dbab969715e1ac93b407f036","modified":1635829734400},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"bd29f20fad3d3fab600940e7a6dc9a803943cb33","modified":1635829734401},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1635829734401},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1635829734401},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1635829734402},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"8cb7ef368cc2ac7f4a13c2959908b1574e572acf","modified":1635829734403},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"98ab13a60413d68bd9d02d54d121c66a6d4634d2","modified":1635829734402},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"26dd1900e68a3e10a5cf3f3484a93139a0f1340e","modified":1635829734403},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1635829734403},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1635829734404},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1635829734404},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1635829734405},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1635829734404},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1635829734405},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1635829734356},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1635829734405},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"3cdc5e32d0f1e5866bcf86f94a0d76aaf7142937","modified":1635829734363},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1635829734356},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f2e1d8a05d2e409c4804f67a98f5f59f527d6627","modified":1635829734370},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1635829734356},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1635829734364},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"f4dcc0a596eb9801c4d3c033d018d0abb413c8e5","modified":1635829734364},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"a1ca58fdff74b890cade94479f8f0eb9ce7e5e73","modified":1635829734363},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1635829734426},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1635829734374},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1635829734425},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1635829734373},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1635829734427},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1635829734424},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9b5243385f7a90e0103c25c531a1e7f2f1884c15","modified":1635829734375},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1635829734426},{"_id":"themes/butterfly/source/css/var.styl","hash":"31198af95fecc6819d3b2cb7ef03988ef67257da","modified":1635829734425},{"_id":"themes/butterfly/source/js/main.js","hash":"53c6df70de6e7949b102ab06fd0cd53b9b39b01c","modified":1635829734427},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1635829734429},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1635829734365},{"_id":"themes/butterfly/source/js/utils.js","hash":"1b8bf1e6d50fa8ffe2aff7548b141cab72540ba0","modified":1635829734429},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"903d12250ce70713dd5b8ac7e1f7a20fe15eb815","modified":1635829734365},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1635829734366},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1635829734367},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"73c04d62055840545112dd12d73807835ca62347","modified":1635829734366},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"3ca9d9cdfd6e61df1d5b07de40f34349cda7a7c7","modified":1635829734365},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1635829734366},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1635829734367},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"3a2797d2744607ba6cdb5a02853851957c0f7e29","modified":1635829734368},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"4d52000cae1fce333329c382dac6c9a21ad0b195","modified":1635829734368},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1635829734370},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"d6556d5396eb0e10ea0ec10158779c21dc78f738","modified":1635829734367},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1635829734371},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"419807903e5586b8804b1f8f17cea97bd05f0b17","modified":1635829734369},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1635829734369},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7677911bd3f43edaf8230eea02f60a248eee9934","modified":1635829734369},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1635829734372},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1635829734371},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"dcccb1425fabcf12a1bed955518b0e7b1054cab0","modified":1635829734371},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"9aa743b1f6fb7fafabee38f9204ce9c8f1be7f9a","modified":1635829734372},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1635829734372},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1635829734373},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1635829734374},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"c762732e200ff2627bc046af5f170b3269343341","modified":1635829734374},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1635829734376},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1635829734385},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1635829734389},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1635829734389},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1635829734393},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1635829734393},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"ad59dcce32e4e67066303a1ffd1dd95874d9953e","modified":1635829734389},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1635829734394},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1635829734394},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"6c3449a44ae1a80f71dd4d9d6a85cec1781ceff1","modified":1635829734394},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"0f1a5c356c1ffd47ff49e153226e2d670dc61057","modified":1635829734395},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"4a2ea9fe59f1dc8cb4f4f6a28cf24a40fc300254","modified":1635829734393},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1635829734395},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1635829734396},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"0b5c165664f9f8691551fc5ff435b40e7f73c737","modified":1635829734395},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1635829734396},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1635829734396},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1635829734396},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"e4c39101d7087066a86f7743985a53d6a246470b","modified":1635829734397},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2e8e391b211b2416d3c9430ab5361659c073f348","modified":1635829734408},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f9de9db2a49ac4d5447660ab159171ac5c228e3c","modified":1635829734406},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"03164bca4546707543828cb2a41bc672b77bfa5a","modified":1635829734407},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"f25415a436100688248fef0ad90e3d4397627833","modified":1635829734410},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"89a6cb63a97cc08675319c403e4a89391f6ab401","modified":1635829734416},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"e65ed98056e6c91e622f94bad5283d00fdb22142","modified":1635829734420},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"fa2985afd08556b25f5f1a01bc1a7c76b294a962","modified":1635829734420},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"8489722684aa9b4baa38386f4d4b39f4dbd60113","modified":1635829734416},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"23ea60f8becc91f6e9f6cfb1cbfd25689c263b9c","modified":1635829734411},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"25ac939fc57346de07ba9e15a1a760b492baefd7","modified":1635829734419},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1635829734411},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1635829734412},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1635829734411},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"db7fe645662d87be4f8dfc08e55bbe1a3734bf93","modified":1635829734413},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"8c4e08c8a63dacdfb2a733a0d0035fa97c7f5e9e","modified":1635829734414},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a00ad74074513a1c7f6e02977b8fa778beaa2108","modified":1635829734414},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"4ae98e703440b616d2a36da139bda844c94d425e","modified":1635829734414},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"943aa34c83c87d0225db65ae90621870472972fa","modified":1635829734415},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1635829734413},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"814729d1d71f4326623a4f34b621bf0421503103","modified":1635829734413},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"dd71e34edece4e06b59e941fb3cc5ad9a3ad09cf","modified":1635829734412},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"87c576a3361f30eefafec27a872ad76e9fbb2765","modified":1635829734417},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"48ad198d0ea97a25db4d2a3e587a16ef41617c0b","modified":1635829734418},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1635829734417},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"191ce31ce0f2b1d22a64225801a88cee6054f574","modified":1635829734415},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"5e5c1d6d104cc15314ae365d0da7cb07334a6457","modified":1635829734418},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"0da09b1811a776106ca66c56be6e2a396dca5680","modified":1635829734418},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1635829734419},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"c91609b7f431cacecc3718ae2fb7403c55f8267a","modified":1635829734422},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1635829734424},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"c3369a14f4111c098d0177036ca57df6deb59d72","modified":1635829734421},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1635829734417},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1635829734422},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1635829734421},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1635829734421},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1635829734423},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1635829734422},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1635829734377},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1635829734376},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1635829734377},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1635829734423},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"54378d52d275e4ab84173bb02e17ea02ae46e55f","modified":1635829734428},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1635829734428},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1635829734378},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1635829734377},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1635829734378},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1635829734380},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1635829734380},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0bf6a47e804fb793b40f82690a24816b902edd41","modified":1635829734381},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1635829734381},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"d97403cdd58c759cfd1752dd85aa4a0f9b73dc46","modified":1635829734382},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"50126b2e841b01584b8b65b2f834038e3997b694","modified":1635829734381},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0254203aae73e70b90dfce6ec4f9c9d3be9ac9f8","modified":1635829734382},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1635829734383},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"e877c98949873a62659db7501d19eb3d66650b51","modified":1635829734382},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"afffc4ac8ce93d39dcc892bd518805cf33531244","modified":1635829734383},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"8290994cf1ee2faff60214ff245cf513fbbe94aa","modified":1635829734384},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0bf1c53b914443c66be5077ff09cfc218f111e11","modified":1635829734384},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1635829734383},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1635829734386},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1635829734385},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1635829734386},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1635829734386},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"8890becd8220c57db2c7451409710942c103a7f4","modified":1635829734387},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"767c38e3dfa0097b0dc1fdfd0df292c16f757d05","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1635829734390},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"83103bad0db195bce095330c4a84e7529bbd40dd","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0ad766ae491e6fcba2ef3d136a7af6158cd4153e","modified":1635829734387},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"a3d43cc360666b5b9730e8bb9e5c8fd940ae5b3d","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1635829734391},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1635829734390},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1635829734391},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1635829734392},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1635829734392},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1635829734392},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"b74c61f6e15b422e9d2df23133552bbd1b5fe513","modified":1635829734409},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"b0916c8c7d15b67b55cb1618be8370870fedbf42","modified":1635829734408},{"_id":"source/img/1.png","hash":"c814776079d2b4c49df12703048d9791ffa4fbaa","modified":1635073565499},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1635829734410},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"4d71aab9082c67d3ee52ad58dfc3c1c9b41f2ab1","modified":1635829734410},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1635829734409},{"_id":"source/img/avatar.jpg","hash":"ca9c387a644a990f7663a5c21000138d87d14418","modified":1637338473069},{"_id":"source/img/background_2.jpg","hash":"476f439546785a49f1f33cd93b4a9e8e9f61acec","modified":1640071292211},{"_id":"source/img/background.png","hash":"f26a50f7ba402b4125b1ba9259e06762a1791428","modified":1634813687669},{"_id":"public/about/index.html","hash":"fab70d7e6cee7bfdc99f8dc736418fba297985a3","modified":1657989253049},{"_id":"public/categories/index.html","hash":"f81879b3020aae33581cc22218254ea4709da3c7","modified":1657989253049},{"_id":"public/tags/index.html","hash":"ad9dcfa838266cfc667d8dddb3e00161b7ebf3cb","modified":1657989253049},{"_id":"public/link/index.html","hash":"bb7f35ac96323e2d6828ad4ba2b2b8974ad7671c","modified":1657989253049},{"_id":"public/2022/07/11/剑指Offer/index.html","hash":"a6d44fc49a5291ef6744ac72c8ed6534213ad17b","modified":1657989253049},{"_id":"public/2022/05/02/Lua设计与实现读书笔记/index.html","hash":"b6935e4070741f02cbbacc4d284e4231585ee789","modified":1657989253049},{"_id":"public/2022/03/03/xlua踩坑/index.html","hash":"95459ed21bfbc4d8dbc8bd8577697c69a34ed544","modified":1657989253049},{"_id":"public/2022/03/02/面试经历/index.html","hash":"bee299769061d225bc539aca1d886c9f6dd31be6","modified":1657989253049},{"_id":"public/2022/02/23/Dictionary源码解析/index.html","hash":"6c91a6f6257ec5cc417392ce97a2546ccd05422d","modified":1657989253049},{"_id":"public/2022/02/23/List源码解析/index.html","hash":"ce791bef29e9b14ee6404e2c5161b3bf200157c4","modified":1657989253049},{"_id":"public/2022/02/05/算法与数据结构/index.html","hash":"3363e8e7f9038adec9985e786a9c8b4736437778","modified":1657989253049},{"_id":"public/2022/02/05/CS面试基础知识/index.html","hash":"4420e949275531d88c7fd45c848843ddc3d7ded3","modified":1657989253049},{"_id":"public/2022/01/19/公共语言基础结构/index.html","hash":"c03b059fc411cb13e4a039c372525772db00ecdd","modified":1657989253049},{"_id":"public/2021/11/01/leetcode/index.html","hash":"fe55c6c8a806fcdb92745d883ce62ec5bbd049c3","modified":1657989253049},{"_id":"public/2021/10/24/操作系统/操作系统/index.html","hash":"b3b44963472da5bc9eab5500b7de778267071a4c","modified":1657989253049},{"_id":"public/categories/语言基础/index.html","hash":"048f914c4da741ea3cb60289c7117971a0f41c52","modified":1657989253049},{"_id":"public/categories/计算机基础知识/index.html","hash":"4b8f6792dfacbaf28f4ae22546840f184902ee07","modified":1657989253049},{"_id":"public/categories/Unity/index.html","hash":"44761dd179f11576667d06a09906acffa6c7b909","modified":1657989253049},{"_id":"public/categories/面试/index.html","hash":"85f2f973ae667f9fb229aa372219c42a27be6acd","modified":1657989253049},{"_id":"public/archives/index.html","hash":"54e6447f5f726a5f7a848a27aa997db4643e5be8","modified":1657989253049},{"_id":"public/archives/page/2/index.html","hash":"24abe24dc8e3f53e7989d6a5b12dad0f9b17153e","modified":1657989253049},{"_id":"public/archives/2021/index.html","hash":"77d46fce549e3b4d5c8113e116434c0fb5dd876a","modified":1657989253049},{"_id":"public/archives/2021/10/index.html","hash":"ccee31f8c8c033491f8866f691369c5dfb227924","modified":1657989253049},{"_id":"public/archives/2021/11/index.html","hash":"5069f43b39849577adf68fb15648da9fa8055060","modified":1657989253049},{"_id":"public/archives/2022/index.html","hash":"148fc3109daa12e3d217193120770577634bdd51","modified":1657989253049},{"_id":"public/archives/2022/01/index.html","hash":"8b2b3e187ed975dafb284021e596a7d661e9c353","modified":1657989253049},{"_id":"public/archives/2022/02/index.html","hash":"6ca21634c2f76fb192c97db68216ed627b42afb8","modified":1657989253049},{"_id":"public/archives/2022/03/index.html","hash":"92204261db0c0bf1250af8aeed6b4af992fa6388","modified":1657989253049},{"_id":"public/archives/2022/05/index.html","hash":"7e8ccbb17b31471e570146f888da7a73048d8c59","modified":1657989253049},{"_id":"public/archives/2022/07/index.html","hash":"6729d5536b47b9053ed087523c37767807df4abf","modified":1657989253049},{"_id":"public/index.html","hash":"35ab0ac42630a60177b6f145ad23c7b908a96f23","modified":1657989253049},{"_id":"public/page/2/index.html","hash":"903a825786287778f65504dc36ca4bb31516c1bf","modified":1657989253049},{"_id":"public/tags/c/index.html","hash":"c996a12af34805cd2b351335b444753bde9a6395","modified":1657989253049},{"_id":"public/tags/算法/index.html","hash":"b6369b65f90b7791bece8c544ccd5f817fa3b5a6","modified":1657989253049},{"_id":"public/tags/Lua/index.html","hash":"732310d1e8566ea655f301597ac08929d75686c6","modified":1657989253049},{"_id":"public/tags/Unity/index.html","hash":"6afc6967e7f3db81663d29b17075f21f9eca5286","modified":1657989253049},{"_id":"public/tags/操作系统/index.html","hash":"d13a70e32c54abe4ab90398b8e736a92ab45237e","modified":1657989253049},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1657989253049},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1657989253049},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1657989253049},{"_id":"public/img/cover_1.png","hash":"0f0e26842fddc5cac701837d60f2791bab909873","modified":1657989253049},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1657989253049},{"_id":"public/2022/02/05/CS面试基础知识/RX_36I`V7SC3ZSYNM~EMC{T.png","hash":"96ad1c1e5c9662c2290c2e90df8b89e8d9b2fc1c","modified":1657989253049},{"_id":"public/img/favicon.jpg","hash":"f909901855f432850a03f208b22cc07d4b13625c","modified":1657989253049},{"_id":"public/img/psc.jpg","hash":"e63a56d59624f7d7cc8c307a7453873b7331f43d","modified":1657989253049},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1657989253049},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1657989253049},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1657989253049},{"_id":"public/js/search/local-search.js","hash":"b1429e9f80ef6b9a77434819ffb87d90bdad25e8","modified":1657989253049},{"_id":"public/css/index.css","hash":"5026a4a0e1f33ef06243916e03ccb148946fba79","modified":1657989253049},{"_id":"public/js/main.js","hash":"b244f28124a46d7f1e8ef76ba6e925289691f93b","modified":1657989253049},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1657989253049},{"_id":"public/2022/05/02/Lua设计与实现读书笔记/1.png","hash":"095063e9e63ea0488695a28c384b1e23715193b1","modified":1657989253049},{"_id":"public/2022/05/02/Lua设计与实现读书笔记/}179[UY3OP~C{R3)L0G%KZW.png","hash":"5b14e4fa77562e0faef43e87be49176014dad2a2","modified":1657989253049},{"_id":"public/img/1.png","hash":"c814776079d2b4c49df12703048d9791ffa4fbaa","modified":1657989253049},{"_id":"public/img/avatar.jpg","hash":"ca9c387a644a990f7663a5c21000138d87d14418","modified":1657989253049},{"_id":"public/img/background_2.jpg","hash":"476f439546785a49f1f33cd93b4a9e8e9f61acec","modified":1657989253049},{"_id":"public/img/background.png","hash":"f26a50f7ba402b4125b1ba9259e06762a1791428","modified":1657989253049}],"Category":[{"name":"语言基础","_id":"cl5o3ztq300042cupeb2y1y0y"},{"name":"计算机基础知识","_id":"cl5o3ztqb000i2cup2ptpff25"},{"name":"Unity","_id":"cl5o3ztqc000p2cup4m088tsv"},{"name":"面试","_id":"cl5o3ztqi00172cup3t7q6m28"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"_content":"# 自我介绍\n\n一个喜欢玩各种游戏的程序仔，大部分人都习惯叫我好饿，不过现实中好像都在叫我学姐？\n\n但我真的是男生！\n\n","source":"about/index.md","raw":"# 自我介绍\n\n一个喜欢玩各种游戏的程序仔，大部分人都习惯叫我好饿，不过现实中好像都在叫我学姐？\n\n但我真的是男生！\n\n","date":"2021-12-23T16:58:47.458Z","updated":"2021-12-23T16:58:47.458Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cl5o3ztpv00002cup0cttf4yz","content":"<h1 id=\"自我介绍\">自我介绍</h1>\n<p>一个喜欢玩各种游戏的程序仔，大部分人都习惯叫我好饿，不过现实中好像都在叫我学姐？</p>\n<p>但我真的是男生！</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/wm8CdvX1aHoLPJY.jpg","excerpt":"","more":"<h1 id=\"自我介绍\">自我介绍</h1>\n<p>一个喜欢玩各种游戏的程序仔，大部分人都习惯叫我好饿，不过现实中好像都在叫我学姐？</p>\n<p>但我真的是男生！</p>\n"},{"title":"分类","date":"2021-10-24T10:16:21.000Z","type":"categories","_content":"\n","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-10-24 18:16:21\ntype: \"categories\"\n---\n\n","updated":"2021-10-24T10:16:41.834Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl5o3ztq100022cupedj78ihu","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg","excerpt":"","more":""},{"title":"标签","date":"2021-10-24T10:14:45.000Z","type":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-10-24 18:14:45\ntype : \"tags\"\n---\n\n","updated":"2021-10-24T10:17:11.425Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl5o3ztq500062cup0wve5c16","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/wm8CdvX1aHoLPJY.jpg","excerpt":"","more":""},{"title":"友链","date":"2021-10-24T10:17:24.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友链\ndate: 2021-10-24 18:17:24\ntype: \"link\"\n---\n","updated":"2021-12-01T14:18:48.816Z","path":"link/index.html","comments":1,"layout":"page","_id":"cl5o3ztq600082cupd7ky1n3y","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/qvfB7Vk1hZiAJ3G.jpg","excerpt":"","more":""}],"Post":[{"title":"CS面试基础知识","date":"2022-02-05T12:32:59.000Z","_content":"\n# C#\n\n## 静态构造函数与构造函数\n\n```csharp\n  class A\n    {\n        public A(string text)\n        {\n            Console.WriteLine(text);\n        }\n    }\n\n    class B\n    {\n        private static A a1 = new A(\"a1\");\n        private A a2 = new A(\"a2\");\n\n        public B()\n        {\n            a2 = new A(\"a4\");\n        }\n\n        static B()\n        {\n            a1 = new A(\"a3\");\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        B b = new B();\n    }\n\n```\n\n在调用B类型代码之前先执行静态构造函数。静态构造函数先初始化静态变量之后运行函数体内的语句。之后调用B的普通构造函数，普通构造函数先初始化成员变量之后运行函数体内的语句。因此输出为：\n\n[![HnlQYj.png](https://s4.ax1x.com/2022/02/05/HnlQYj.png)](https://imgtu.com/i/HnlQYj)\n\n## 反射与应用程序域\n\n```csharp\nusing System.Diagnostics;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\n\nnamespace ConsoleApp2;\n\n[Serializable]\ninternal class A : MarshalByRefObject\n{\n    public static int Number;\n\n    public void SetNumber(int value)\n    {\n        Number = value;\n    }\n}\n\n[Serializable]\ninternal class B\n{\n    public static int Number;\n\n    public void SetNumber(int value)\n    {\n        Number = value;\n    }\n}\n\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        string assembly = Assembly.GetEntryAssembly().FullName;\n        AppDomain domain = AppDomain.CreateDomain(\"NewDomain\");\n\n        A.Number = 10;\n        string nameOfA = typeof(A).FullName;\n        A a = domain.CreateInstanceAndUnwrap(assembly, nameOfA) as A;\n        a.SetNumber(20);\n        Console.WriteLine($\"Number in class A is {A.Number}\");\n\n        B.Number = 10;\n        string nameOfB = typeof(B).FullName;\n        B b = domain.CreateInstanceAndUnwrap(assembly, nameOfA) as B;\n        b.SetNumber(20);\n        Console.WriteLine($\"Number in class B is {B.Number}\");\n    }\n}\n```\n\n> 此代码在.NET5+以上无法运行，因为现在已经不再支持创建其他应用域，可详见文档[.NET Framework 技术在 .NET Core 和 .NET 5+ 上不可用 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/core/porting/net-framework-tech-unavailable)。\n\n上述代码先创建一个叫做**NewDomain**的应用程序域，并在该域中利用反射创建类型A和类型B的实例。但是**类型A继承于MarshalByRefObject**，而B没有，所以两者在跨越应用域的边界时表现出的行为不同。\n\n首先考虑A的情况，因A继承自MarshalByRefObject，那么a实际上只是在默认的域中的一个代理实例(Proxy)，它指向位于NewDomain域中的一个实例。当调用a的方法SetNumber时，是在NewDomain域中调用该方法，它将修改NewDomain域中静态变量A.Number的值并设置为20。由于静态变量在每个应用程序域中都有一份独立的拷贝，因此修改NewDomain域中的A.Number对于默认域中没有任何影响。由于Console.WriteLine()是在默认应用域中输出，因此输出仍然是10。\n\nB的情况比较简单，因为B只是从Object继承来的类型，它在穿越应用程序域的边界时，将会完整地复制实例。因此在代码中，我们在NewDomain中生成B的实例，但是会把实例b复制到默认的应用程序域。此时调用b.SetNumber也是在默认的应用程序域中修改，所以输出是20.\n\n## 不同的相等\n\n```csharp\npublic static bool ReferenceEquals(object left, object right);\npublic static bool Equals(object left, object right);\npublic virtual bool Equals(object right);\npublic static bool operator ==(MyClass left, MyClass right);\n```\n\n因为C#即允许创建值类型，又允许创建引用类型，所以要从不同角度考虑两个对象是否相等。\n\n- 两个引用对象是否相等，要看引用的是否是同一个实例。\n- 两个值类型是否相同，要看是否属于同一类型并且具有相同的内容。\n\n其中静态版本的`ReferenceEquals()`和`Equals()`不需要重写，因为无论待比较的两个对象在运行期是什么类型，这两个方法都能正确的比较。\n\n需要考虑的是针对自己所创建的值类型来重写实例版本`Equals()`方法，并且重载`==`运算符，以求提升比较的效率。\n\n如果你创建的某个引用类型需要按照内容而非身份来判断两个对象是否相等，那么应该针对该类型重写实例版本的`Equals()`方法。\n\n## 逆变与协变\n\n[泛型中的协变和逆变 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance)\n\n# 计算机网络\n\n# 操作系统\n\n# Unity\n\n## 动态加载资源与方式\n\n`AssetsBundle.Load`：即将资源打成 asset bundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object，unity官方推荐也是绝大多数商业化项目使用的一种方式。\n\n`AssetDatabase.LoadAssetAtPath` ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。\n\n`Resource.Load`:可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中。\n\n[在运行时加载资源 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/LoadingResourcesatRuntime.html)\n\n## 引擎中有哪些坐标系\n\n- 屏幕坐标系：即游戏画面，为二维坐标系\n\n- 世界坐标系：游戏物体绝对位置坐标所在坐标系，为三维坐标系\n\n- 模型坐标系：游戏物体自身坐标系，为三维坐标系\n\n- 观察坐标系（视口坐标系）：也就是摄像机的视锥体空间，为三维坐标系，转换到屏幕空间需要进行投影操作\n\n> Unity使用的是**左手**坐标系\n\n[Unity3D坐标系 - 简书 (jianshu.com)](https://www.jianshu.com/p/0c5c8fb78074)\n\n## 相机中的Clipping Plane、Near、Far数值有什么意义\n\n[实时渲染中的坐标系变换（3）：投影变换-1 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/113662566)\n\n论games101的重要性。。要不还是寄了把\n\n## 四元数的作用\n\n万向节死锁经典问题了\n\n[四元数和三维转动，可互动的探索式视频（请看链接）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Lt411U7og?spm_id_from=333.999.0.0)\n\n## OnEnbale、Awake、Start运行时的先后顺序\n\n- **Awake** ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）\n- **OnEnable：**（仅在对象处于激活状态时调用）在启用对象后立即调用此函数。在创建 MonoBehaviour 实例时（例如加载关卡或实例化具有脚本组件的游戏对象时）会执行此调用。\n- **Start** ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。\n\n[事件函数的执行顺序 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html)\n\n## 相机的移动在Update函数中好吗？物理更新一般是在Update中吗？\n\n相机移动在`LateUpdate`，物理更新在`FixedUpdate`\n\n这里设计到帧更新问题，可以看一下[游戏循环 · Sequencing Patterns · 游戏设计模式 (tkchu.me)](https://gpp.tkchu.me/game-loop.html)\n\n[重要课程 - 时间 - 统一手册 (unity.cn)](https://docs.unity.cn/cn/2020.3/Manual/TimeFrameManagement.html)\n\n[Unity中的FixedUpdate、Update、LateUpdate的区别及游戏帧更新_enternalstar的博客-CSDN博客_fixedupdate](https://blog.csdn.net/enternalstar/article/details/108507205)\n","source":"_posts/CS面试基础知识.md","raw":"---\ntitle: CS面试基础知识\ndate: 2022-02-05 20:32:59\ntags: c#\ncategories: 语言基础\n---\n\n# C#\n\n## 静态构造函数与构造函数\n\n```csharp\n  class A\n    {\n        public A(string text)\n        {\n            Console.WriteLine(text);\n        }\n    }\n\n    class B\n    {\n        private static A a1 = new A(\"a1\");\n        private A a2 = new A(\"a2\");\n\n        public B()\n        {\n            a2 = new A(\"a4\");\n        }\n\n        static B()\n        {\n            a1 = new A(\"a3\");\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        B b = new B();\n    }\n\n```\n\n在调用B类型代码之前先执行静态构造函数。静态构造函数先初始化静态变量之后运行函数体内的语句。之后调用B的普通构造函数，普通构造函数先初始化成员变量之后运行函数体内的语句。因此输出为：\n\n[![HnlQYj.png](https://s4.ax1x.com/2022/02/05/HnlQYj.png)](https://imgtu.com/i/HnlQYj)\n\n## 反射与应用程序域\n\n```csharp\nusing System.Diagnostics;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\n\nnamespace ConsoleApp2;\n\n[Serializable]\ninternal class A : MarshalByRefObject\n{\n    public static int Number;\n\n    public void SetNumber(int value)\n    {\n        Number = value;\n    }\n}\n\n[Serializable]\ninternal class B\n{\n    public static int Number;\n\n    public void SetNumber(int value)\n    {\n        Number = value;\n    }\n}\n\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        string assembly = Assembly.GetEntryAssembly().FullName;\n        AppDomain domain = AppDomain.CreateDomain(\"NewDomain\");\n\n        A.Number = 10;\n        string nameOfA = typeof(A).FullName;\n        A a = domain.CreateInstanceAndUnwrap(assembly, nameOfA) as A;\n        a.SetNumber(20);\n        Console.WriteLine($\"Number in class A is {A.Number}\");\n\n        B.Number = 10;\n        string nameOfB = typeof(B).FullName;\n        B b = domain.CreateInstanceAndUnwrap(assembly, nameOfA) as B;\n        b.SetNumber(20);\n        Console.WriteLine($\"Number in class B is {B.Number}\");\n    }\n}\n```\n\n> 此代码在.NET5+以上无法运行，因为现在已经不再支持创建其他应用域，可详见文档[.NET Framework 技术在 .NET Core 和 .NET 5+ 上不可用 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/core/porting/net-framework-tech-unavailable)。\n\n上述代码先创建一个叫做**NewDomain**的应用程序域，并在该域中利用反射创建类型A和类型B的实例。但是**类型A继承于MarshalByRefObject**，而B没有，所以两者在跨越应用域的边界时表现出的行为不同。\n\n首先考虑A的情况，因A继承自MarshalByRefObject，那么a实际上只是在默认的域中的一个代理实例(Proxy)，它指向位于NewDomain域中的一个实例。当调用a的方法SetNumber时，是在NewDomain域中调用该方法，它将修改NewDomain域中静态变量A.Number的值并设置为20。由于静态变量在每个应用程序域中都有一份独立的拷贝，因此修改NewDomain域中的A.Number对于默认域中没有任何影响。由于Console.WriteLine()是在默认应用域中输出，因此输出仍然是10。\n\nB的情况比较简单，因为B只是从Object继承来的类型，它在穿越应用程序域的边界时，将会完整地复制实例。因此在代码中，我们在NewDomain中生成B的实例，但是会把实例b复制到默认的应用程序域。此时调用b.SetNumber也是在默认的应用程序域中修改，所以输出是20.\n\n## 不同的相等\n\n```csharp\npublic static bool ReferenceEquals(object left, object right);\npublic static bool Equals(object left, object right);\npublic virtual bool Equals(object right);\npublic static bool operator ==(MyClass left, MyClass right);\n```\n\n因为C#即允许创建值类型，又允许创建引用类型，所以要从不同角度考虑两个对象是否相等。\n\n- 两个引用对象是否相等，要看引用的是否是同一个实例。\n- 两个值类型是否相同，要看是否属于同一类型并且具有相同的内容。\n\n其中静态版本的`ReferenceEquals()`和`Equals()`不需要重写，因为无论待比较的两个对象在运行期是什么类型，这两个方法都能正确的比较。\n\n需要考虑的是针对自己所创建的值类型来重写实例版本`Equals()`方法，并且重载`==`运算符，以求提升比较的效率。\n\n如果你创建的某个引用类型需要按照内容而非身份来判断两个对象是否相等，那么应该针对该类型重写实例版本的`Equals()`方法。\n\n## 逆变与协变\n\n[泛型中的协变和逆变 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance)\n\n# 计算机网络\n\n# 操作系统\n\n# Unity\n\n## 动态加载资源与方式\n\n`AssetsBundle.Load`：即将资源打成 asset bundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object，unity官方推荐也是绝大多数商业化项目使用的一种方式。\n\n`AssetDatabase.LoadAssetAtPath` ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。\n\n`Resource.Load`:可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中。\n\n[在运行时加载资源 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/LoadingResourcesatRuntime.html)\n\n## 引擎中有哪些坐标系\n\n- 屏幕坐标系：即游戏画面，为二维坐标系\n\n- 世界坐标系：游戏物体绝对位置坐标所在坐标系，为三维坐标系\n\n- 模型坐标系：游戏物体自身坐标系，为三维坐标系\n\n- 观察坐标系（视口坐标系）：也就是摄像机的视锥体空间，为三维坐标系，转换到屏幕空间需要进行投影操作\n\n> Unity使用的是**左手**坐标系\n\n[Unity3D坐标系 - 简书 (jianshu.com)](https://www.jianshu.com/p/0c5c8fb78074)\n\n## 相机中的Clipping Plane、Near、Far数值有什么意义\n\n[实时渲染中的坐标系变换（3）：投影变换-1 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/113662566)\n\n论games101的重要性。。要不还是寄了把\n\n## 四元数的作用\n\n万向节死锁经典问题了\n\n[四元数和三维转动，可互动的探索式视频（请看链接）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Lt411U7og?spm_id_from=333.999.0.0)\n\n## OnEnbale、Awake、Start运行时的先后顺序\n\n- **Awake** ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）\n- **OnEnable：**（仅在对象处于激活状态时调用）在启用对象后立即调用此函数。在创建 MonoBehaviour 实例时（例如加载关卡或实例化具有脚本组件的游戏对象时）会执行此调用。\n- **Start** ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。\n\n[事件函数的执行顺序 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html)\n\n## 相机的移动在Update函数中好吗？物理更新一般是在Update中吗？\n\n相机移动在`LateUpdate`，物理更新在`FixedUpdate`\n\n这里设计到帧更新问题，可以看一下[游戏循环 · Sequencing Patterns · 游戏设计模式 (tkchu.me)](https://gpp.tkchu.me/game-loop.html)\n\n[重要课程 - 时间 - 统一手册 (unity.cn)](https://docs.unity.cn/cn/2020.3/Manual/TimeFrameManagement.html)\n\n[Unity中的FixedUpdate、Update、LateUpdate的区别及游戏帧更新_enternalstar的博客-CSDN博客_fixedupdate](https://blog.csdn.net/enternalstar/article/details/108507205)\n","slug":"CS面试基础知识","published":1,"updated":"2022-05-02T12:50:57.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztpz00012cup7mco7jzn","content":"<h1 id=\"C\">C#</h1>\n<h2 id=\"静态构造函数与构造函数\">静态构造函数与构造函数</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span>(<span class=\"params\"><span class=\"built_in\">string</span> text</span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          Console.WriteLine(text);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title\">B</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> A a1 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">private</span> A a2 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          a2 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a4&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          a1 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a3&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在调用B类型代码之前先执行静态构造函数。静态构造函数先初始化静态变量之后运行函数体内的语句。之后调用B的普通构造函数，普通构造函数先初始化成员变量之后运行函数体内的语句。因此输出为：</p>\n<p><a href=\"https://imgtu.com/i/HnlQYj\"><img src=\"https://s4.ax1x.com/2022/02/05/HnlQYj.png\" alt=\"HnlQYj.png\"></a></p>\n<h2 id=\"反射与应用程序域\">反射与应用程序域</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Diagnostics;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Reflection;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Runtime.CompilerServices;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">ConsoleApp2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title\">A</span> : <span class=\"title\">MarshalByRefObject</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> Number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span> <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Number = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title\">B</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> Number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span> <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Number = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> assembly = Assembly.GetEntryAssembly().FullName;</span><br><span class=\"line\">        AppDomain domain = AppDomain.CreateDomain(<span class=\"string\">&quot;NewDomain&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        A.Number = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> nameOfA = <span class=\"keyword\">typeof</span>(A).FullName;</span><br><span class=\"line\">        A a = domain.CreateInstanceAndUnwrap(assembly, nameOfA) <span class=\"keyword\">as</span> A;</span><br><span class=\"line\">        a.SetNumber(<span class=\"number\">20</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Number in class A is <span class=\"subst\">&#123;A.Number&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        B.Number = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> nameOfB = <span class=\"keyword\">typeof</span>(B).FullName;</span><br><span class=\"line\">        B b = domain.CreateInstanceAndUnwrap(assembly, nameOfA) <span class=\"keyword\">as</span> B;</span><br><span class=\"line\">        b.SetNumber(<span class=\"number\">20</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Number in class B is <span class=\"subst\">&#123;B.Number&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此代码在.NET5+以上无法运行，因为现在已经不再支持创建其他应用域，可详见文档<a href=\"https://docs.microsoft.com/zh-cn/dotnet/core/porting/net-framework-tech-unavailable\">.NET Framework 技术在 .NET Core 和 .NET 5+ 上不可用 | Microsoft Docs</a>。</p>\n</blockquote>\n<p>上述代码先创建一个叫做<strong>NewDomain</strong>的应用程序域，并在该域中利用反射创建类型A和类型B的实例。但是<strong>类型A继承于MarshalByRefObject</strong>，而B没有，所以两者在跨越应用域的边界时表现出的行为不同。</p>\n<p>首先考虑A的情况，因A继承自MarshalByRefObject，那么a实际上只是在默认的域中的一个代理实例(Proxy)，它指向位于NewDomain域中的一个实例。当调用a的方法SetNumber时，是在NewDomain域中调用该方法，它将修改NewDomain域中静态变量A.Number的值并设置为20。由于静态变量在每个应用程序域中都有一份独立的拷贝，因此修改NewDomain域中的A.Number对于默认域中没有任何影响。由于Console.WriteLine()是在默认应用域中输出，因此输出仍然是10。</p>\n<p>B的情况比较简单，因为B只是从Object继承来的类型，它在穿越应用程序域的边界时，将会完整地复制实例。因此在代码中，我们在NewDomain中生成B的实例，但是会把实例b复制到默认的应用程序域。此时调用b.SetNumber也是在默认的应用程序域中修改，所以输出是20.</p>\n<h2 id=\"不同的相等\">不同的相等</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">ReferenceEquals</span>(<span class=\"params\"><span class=\"built_in\">object</span> left, <span class=\"built_in\">object</span> right</span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">Equals</span>(<span class=\"params\"><span class=\"built_in\">object</span> left, <span class=\"built_in\">object</span> right</span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">Equals</span>(<span class=\"params\"><span class=\"built_in\">object</span> right</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"keyword\">operator</span> ==(MyClass left, MyClass right);</span><br></pre></td></tr></table></figure>\n<p>因为C#即允许创建值类型，又允许创建引用类型，所以要从不同角度考虑两个对象是否相等。</p>\n<ul>\n<li>两个引用对象是否相等，要看引用的是否是同一个实例。</li>\n<li>两个值类型是否相同，要看是否属于同一类型并且具有相同的内容。</li>\n</ul>\n<p>其中静态版本的<code>ReferenceEquals()</code>和<code>Equals()</code>不需要重写，因为无论待比较的两个对象在运行期是什么类型，这两个方法都能正确的比较。</p>\n<p>需要考虑的是针对自己所创建的值类型来重写实例版本<code>Equals()</code>方法，并且重载<code>==</code>运算符，以求提升比较的效率。</p>\n<p>如果你创建的某个引用类型需要按照内容而非身份来判断两个对象是否相等，那么应该针对该类型重写实例版本的<code>Equals()</code>方法。</p>\n<h2 id=\"逆变与协变\">逆变与协变</h2>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance\">泛型中的协变和逆变 | Microsoft Docs</a></p>\n<h1 id=\"计算机网络\">计算机网络</h1>\n<h1 id=\"操作系统\">操作系统</h1>\n<h1 id=\"Unity\">Unity</h1>\n<h2 id=\"动态加载资源与方式\">动态加载资源与方式</h2>\n<p><code>AssetsBundle.Load</code>：即将资源打成 asset bundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object，unity官方推荐也是绝大多数商业化项目使用的一种方式。</p>\n<p><code>AssetDatabase.LoadAssetAtPath</code> ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。</p>\n<p><code>Resource.Load</code>:可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中。</p>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/LoadingResourcesatRuntime.html\">在运行时加载资源 - Unity 手册 (unity3d.com)</a></p>\n<h2 id=\"引擎中有哪些坐标系\">引擎中有哪些坐标系</h2>\n<ul>\n<li>\n<p>屏幕坐标系：即游戏画面，为二维坐标系</p>\n</li>\n<li>\n<p>世界坐标系：游戏物体绝对位置坐标所在坐标系，为三维坐标系</p>\n</li>\n<li>\n<p>模型坐标系：游戏物体自身坐标系，为三维坐标系</p>\n</li>\n<li>\n<p>观察坐标系（视口坐标系）：也就是摄像机的视锥体空间，为三维坐标系，转换到屏幕空间需要进行投影操作</p>\n</li>\n</ul>\n<blockquote>\n<p>Unity使用的是<strong>左手</strong>坐标系</p>\n</blockquote>\n<p><a href=\"https://www.jianshu.com/p/0c5c8fb78074\">Unity3D坐标系 - 简书 (jianshu.com)</a></p>\n<h2 id=\"相机中的Clipping-Plane、Near、Far数值有什么意义\">相机中的Clipping Plane、Near、Far数值有什么意义</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/113662566\">实时渲染中的坐标系变换（3）：投影变换-1 - 知乎 (zhihu.com)</a></p>\n<p>论games101的重要性。。要不还是寄了把</p>\n<h2 id=\"四元数的作用\">四元数的作用</h2>\n<p>万向节死锁经典问题了</p>\n<p><a href=\"https://www.bilibili.com/video/BV1Lt411U7og?spm_id_from=333.999.0.0\">四元数和三维转动，可互动的探索式视频（请看链接）_哔哩哔哩_bilibili</a></p>\n<h2 id=\"OnEnbale、Awake、Start运行时的先后顺序\">OnEnbale、Awake、Start运行时的先后顺序</h2>\n<ul>\n<li><strong>Awake</strong> ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）</li>\n<li><strong>OnEnable：</strong>（仅在对象处于激活状态时调用）在启用对象后立即调用此函数。在创建 MonoBehaviour 实例时（例如加载关卡或实例化具有脚本组件的游戏对象时）会执行此调用。</li>\n<li><strong>Start</strong> ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。</li>\n</ul>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html\">事件函数的执行顺序 - Unity 手册 (unity3d.com)</a></p>\n<h2 id=\"相机的移动在Update函数中好吗？物理更新一般是在Update中吗？\">相机的移动在Update函数中好吗？物理更新一般是在Update中吗？</h2>\n<p>相机移动在<code>LateUpdate</code>，物理更新在<code>FixedUpdate</code></p>\n<p>这里设计到帧更新问题，可以看一下<a href=\"https://gpp.tkchu.me/game-loop.html\">游戏循环 · Sequencing Patterns · 游戏设计模式 (tkchu.me)</a></p>\n<p><a href=\"https://docs.unity.cn/cn/2020.3/Manual/TimeFrameManagement.html\">重要课程 - 时间 - 统一手册 (unity.cn)</a></p>\n<p><a href=\"https://blog.csdn.net/enternalstar/article/details/108507205\">Unity中的FixedUpdate、Update、LateUpdate的区别及游戏帧更新_enternalstar的博客-CSDN博客_fixedupdate</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/qvfB7Vk1hZiAJ3G.jpg","excerpt":"","more":"<h1 id=\"C\">C#</h1>\n<h2 id=\"静态构造函数与构造函数\">静态构造函数与构造函数</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span>(<span class=\"params\"><span class=\"built_in\">string</span> text</span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          Console.WriteLine(text);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title\">B</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> A a1 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">private</span> A a2 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          a2 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a4&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">B</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          a1 = <span class=\"keyword\">new</span> A(<span class=\"string\">&quot;a3&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在调用B类型代码之前先执行静态构造函数。静态构造函数先初始化静态变量之后运行函数体内的语句。之后调用B的普通构造函数，普通构造函数先初始化成员变量之后运行函数体内的语句。因此输出为：</p>\n<p><a href=\"https://imgtu.com/i/HnlQYj\"><img src=\"https://s4.ax1x.com/2022/02/05/HnlQYj.png\" alt=\"HnlQYj.png\"></a></p>\n<h2 id=\"反射与应用程序域\">反射与应用程序域</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Diagnostics;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Reflection;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Runtime.CompilerServices;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">ConsoleApp2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title\">A</span> : <span class=\"title\">MarshalByRefObject</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> Number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span> <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Number = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Serializable</span>]</span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title\">B</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> Number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span> <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Number = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> assembly = Assembly.GetEntryAssembly().FullName;</span><br><span class=\"line\">        AppDomain domain = AppDomain.CreateDomain(<span class=\"string\">&quot;NewDomain&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        A.Number = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> nameOfA = <span class=\"keyword\">typeof</span>(A).FullName;</span><br><span class=\"line\">        A a = domain.CreateInstanceAndUnwrap(assembly, nameOfA) <span class=\"keyword\">as</span> A;</span><br><span class=\"line\">        a.SetNumber(<span class=\"number\">20</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Number in class A is <span class=\"subst\">&#123;A.Number&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        B.Number = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> nameOfB = <span class=\"keyword\">typeof</span>(B).FullName;</span><br><span class=\"line\">        B b = domain.CreateInstanceAndUnwrap(assembly, nameOfA) <span class=\"keyword\">as</span> B;</span><br><span class=\"line\">        b.SetNumber(<span class=\"number\">20</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Number in class B is <span class=\"subst\">&#123;B.Number&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此代码在.NET5+以上无法运行，因为现在已经不再支持创建其他应用域，可详见文档<a href=\"https://docs.microsoft.com/zh-cn/dotnet/core/porting/net-framework-tech-unavailable\">.NET Framework 技术在 .NET Core 和 .NET 5+ 上不可用 | Microsoft Docs</a>。</p>\n</blockquote>\n<p>上述代码先创建一个叫做<strong>NewDomain</strong>的应用程序域，并在该域中利用反射创建类型A和类型B的实例。但是<strong>类型A继承于MarshalByRefObject</strong>，而B没有，所以两者在跨越应用域的边界时表现出的行为不同。</p>\n<p>首先考虑A的情况，因A继承自MarshalByRefObject，那么a实际上只是在默认的域中的一个代理实例(Proxy)，它指向位于NewDomain域中的一个实例。当调用a的方法SetNumber时，是在NewDomain域中调用该方法，它将修改NewDomain域中静态变量A.Number的值并设置为20。由于静态变量在每个应用程序域中都有一份独立的拷贝，因此修改NewDomain域中的A.Number对于默认域中没有任何影响。由于Console.WriteLine()是在默认应用域中输出，因此输出仍然是10。</p>\n<p>B的情况比较简单，因为B只是从Object继承来的类型，它在穿越应用程序域的边界时，将会完整地复制实例。因此在代码中，我们在NewDomain中生成B的实例，但是会把实例b复制到默认的应用程序域。此时调用b.SetNumber也是在默认的应用程序域中修改，所以输出是20.</p>\n<h2 id=\"不同的相等\">不同的相等</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">ReferenceEquals</span>(<span class=\"params\"><span class=\"built_in\">object</span> left, <span class=\"built_in\">object</span> right</span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">Equals</span>(<span class=\"params\"><span class=\"built_in\">object</span> left, <span class=\"built_in\">object</span> right</span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">Equals</span>(<span class=\"params\"><span class=\"built_in\">object</span> right</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"keyword\">operator</span> ==(MyClass left, MyClass right);</span><br></pre></td></tr></table></figure>\n<p>因为C#即允许创建值类型，又允许创建引用类型，所以要从不同角度考虑两个对象是否相等。</p>\n<ul>\n<li>两个引用对象是否相等，要看引用的是否是同一个实例。</li>\n<li>两个值类型是否相同，要看是否属于同一类型并且具有相同的内容。</li>\n</ul>\n<p>其中静态版本的<code>ReferenceEquals()</code>和<code>Equals()</code>不需要重写，因为无论待比较的两个对象在运行期是什么类型，这两个方法都能正确的比较。</p>\n<p>需要考虑的是针对自己所创建的值类型来重写实例版本<code>Equals()</code>方法，并且重载<code>==</code>运算符，以求提升比较的效率。</p>\n<p>如果你创建的某个引用类型需要按照内容而非身份来判断两个对象是否相等，那么应该针对该类型重写实例版本的<code>Equals()</code>方法。</p>\n<h2 id=\"逆变与协变\">逆变与协变</h2>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance\">泛型中的协变和逆变 | Microsoft Docs</a></p>\n<h1 id=\"计算机网络\">计算机网络</h1>\n<h1 id=\"操作系统\">操作系统</h1>\n<h1 id=\"Unity\">Unity</h1>\n<h2 id=\"动态加载资源与方式\">动态加载资源与方式</h2>\n<p><code>AssetsBundle.Load</code>：即将资源打成 asset bundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object，unity官方推荐也是绝大多数商业化项目使用的一种方式。</p>\n<p><code>AssetDatabase.LoadAssetAtPath</code> ：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。</p>\n<p><code>Resource.Load</code>:可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中。</p>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/LoadingResourcesatRuntime.html\">在运行时加载资源 - Unity 手册 (unity3d.com)</a></p>\n<h2 id=\"引擎中有哪些坐标系\">引擎中有哪些坐标系</h2>\n<ul>\n<li>\n<p>屏幕坐标系：即游戏画面，为二维坐标系</p>\n</li>\n<li>\n<p>世界坐标系：游戏物体绝对位置坐标所在坐标系，为三维坐标系</p>\n</li>\n<li>\n<p>模型坐标系：游戏物体自身坐标系，为三维坐标系</p>\n</li>\n<li>\n<p>观察坐标系（视口坐标系）：也就是摄像机的视锥体空间，为三维坐标系，转换到屏幕空间需要进行投影操作</p>\n</li>\n</ul>\n<blockquote>\n<p>Unity使用的是<strong>左手</strong>坐标系</p>\n</blockquote>\n<p><a href=\"https://www.jianshu.com/p/0c5c8fb78074\">Unity3D坐标系 - 简书 (jianshu.com)</a></p>\n<h2 id=\"相机中的Clipping-Plane、Near、Far数值有什么意义\">相机中的Clipping Plane、Near、Far数值有什么意义</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/113662566\">实时渲染中的坐标系变换（3）：投影变换-1 - 知乎 (zhihu.com)</a></p>\n<p>论games101的重要性。。要不还是寄了把</p>\n<h2 id=\"四元数的作用\">四元数的作用</h2>\n<p>万向节死锁经典问题了</p>\n<p><a href=\"https://www.bilibili.com/video/BV1Lt411U7og?spm_id_from=333.999.0.0\">四元数和三维转动，可互动的探索式视频（请看链接）_哔哩哔哩_bilibili</a></p>\n<h2 id=\"OnEnbale、Awake、Start运行时的先后顺序\">OnEnbale、Awake、Start运行时的先后顺序</h2>\n<ul>\n<li><strong>Awake</strong> ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）</li>\n<li><strong>OnEnable：</strong>（仅在对象处于激活状态时调用）在启用对象后立即调用此函数。在创建 MonoBehaviour 实例时（例如加载关卡或实例化具有脚本组件的游戏对象时）会执行此调用。</li>\n<li><strong>Start</strong> ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。</li>\n</ul>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html\">事件函数的执行顺序 - Unity 手册 (unity3d.com)</a></p>\n<h2 id=\"相机的移动在Update函数中好吗？物理更新一般是在Update中吗？\">相机的移动在Update函数中好吗？物理更新一般是在Update中吗？</h2>\n<p>相机移动在<code>LateUpdate</code>，物理更新在<code>FixedUpdate</code></p>\n<p>这里设计到帧更新问题，可以看一下<a href=\"https://gpp.tkchu.me/game-loop.html\">游戏循环 · Sequencing Patterns · 游戏设计模式 (tkchu.me)</a></p>\n<p><a href=\"https://docs.unity.cn/cn/2020.3/Manual/TimeFrameManagement.html\">重要课程 - 时间 - 统一手册 (unity.cn)</a></p>\n<p><a href=\"https://blog.csdn.net/enternalstar/article/details/108507205\">Unity中的FixedUpdate、Update、LateUpdate的区别及游戏帧更新_enternalstar的博客-CSDN博客_fixedupdate</a></p>\n"},{"title":"Dictionary源码解析","date":"2022-02-23T08:26:01.000Z","_content":"\n# Dictionary源码解析\n\n## 前置知识\n\n### Hash算法\n\n**散列函数**（英语：Hash function）又称**散列算法**、**哈希函数**，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做**散列值**（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。\n\n所有的Hash函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“Hash碰撞”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。\n\n常见构造Hash函数的算法：\n\n1. 直接寻址法：取key的某个线性函数值为哈希地址。即$H(key) = a*key+b，(a,b为常量)$\n2. 数字分析法：比方有一组数据，其中每个数据都由十位数字组成。通过观察可得，每一组数据中前五位有大量重复数据，这样后五位就可以看作是随机的，即可选后五位作为哈希地址。\n3. 平方取中法：取key平方后的中间几位作为哈希地址。\n4. 折叠法：将key分成位数相同的几部分(最后一部分位数可以不同)，然后叠加和作为哈希地址。比如$12345$即可拆成$12+34+5$。\n5. 除留余数法：选定一个统一的基数p，对所有键取余，从而得到对应的哈希地址。即$H(key) = key\\mod {p}$。p的选择一般为素数或为表长。\n\n> 对于为什么取素数可以看下面链接，我们的目标是让key和p的最大公约数都为1。\n>\n> [Hash时取模一定要模质数吗？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/20806796)\n\n### Hash桶\n\n将生成的HashCode分段拆开，每一段称为一个桶，常见的桶便是对结果取余。比如源码中这一段`return ref buckets[hashCode % (uint)buckets.Length]`。\n\n### Hash碰撞\n\n一个哈希函数能够将键转化为数组索引。算法的第二步是**碰撞处理**。也就是处理两个或者多个键的散列值相同的情况。\n\n#### 拉链法\n\n将大小为$M$的数组中的每一个元素指向一条链表，链表中每个节点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法，因为发生冲突的元素都被存储在链表中。\n\n这个方法的基本思想就是选择足够大的$M$，使所有链表都尽可能保证高效的查找。\n\n> 当然，这里`M`并不是越大越好，选择一个足够大的即可。\n\n查找分为两步：\n\n1. 根据散列值找到对应的链表\n2. 沿着链表顺序查找相应的键\n\n#### 线性探测法\n\n用大小为$M$的数组保存$N$个键值对，其中$M > N$。我们需要依靠数组中的**空位**解决碰撞冲突。基于这种策略的方法被统称为开放地址散列表。\n\n其中最简单的方法叫做线性探测法：\n\n当发生碰撞时，我们直接检查散列表的下一个位置。这样的线性探测可能会产生三种结果：\n\n- 命中，该位置的键和被查找的键相同\n- 未命中，键为空（该位置没有键）\n- 继续查找，该位置的键和被查找的键不同\n\n## Dictionary构造器\n\n```csharp\nprivate struct Entry\n{\n    public uint hashCode; \n    /// <summary>\n    /// 0-based index of next entry in chain: -1 means end of chain\n    /// also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,\n    /// so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.\n    /// </summary>\n    public int next; //下一个元素的下标索引\n    public TKey key;     // Key of entry\n    public TValue value; // Value of entry\n}\n```\n\n首先引入了`Entry`结构体，这是`Dictionary`中存放数据的最小单位。\n\n```csharp\npublic class Dictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary, IReadOnlyDictionary<TKey, TValue>,\n    ISerializable, IDeserializationCallback where TKey : notnull\n{\n    private int[]? _buckets; //Hash桶\n    private Entry[]? _entries; //Entry数组，用于存放元素\n    private int _count; //当前Entries的index位置\n    private int _freeList; // 被删除Entry在Entries中的下标index\n    private int _freeCount; // 有多少被删除的Entry\n    private int _version; // 当前版本，防止迭代过程中集合被更改\n    private IEqualityComparer<TKey>? _comparer; // 比较器\n    private KeyCollection? _keys; // 存放key的集合\n    private ValueCollection? _values; // 存放Value的集合\n    private const int StartOfFreeList = -3;\n}\n```\n\n```csharp\npublic Dictionary(int capacity, IEqualityComparer<TKey>? comparer)\n{\n    if (capacity < 0)\n    {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity);\n    }\n\n    if (capacity > 0)\n    {\n        Initialize(capacity);\n    }\n\n    if (comparer is not null && comparer != EqualityComparer<TKey>.Default) // first check for null to avoid forcing default comparer instantiation unnecessarily\n    {\n        _comparer = comparer;\n    }\n\n    // Special-case EqualityComparer<string>.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.\n    // We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the\n    // hash buckets become unbalanced.\n    if (typeof(TKey) == typeof(string))\n    {\n        IEqualityComparer<string>? stringComparer = NonRandomizedStringEqualityComparer.GetStringComparer(_comparer);\n        if (stringComparer is not null)\n        {\n            _comparer = (IEqualityComparer<TKey>?)stringComparer;\n        }\n    }\n}\n```\n\n```csharp\nprivate int Initialize(int capacity)\n{\n    int size = HashHelpers.GetPrime(capacity);\n    int[] buckets = new int[size];\n    Entry[] entries = new Entry[size];\n\n    // Assign member variables after both arrays allocated to guard against corruption from OOM if second fails\n    _freeList = -1;\n    _buckets = buckets;\n    _entries = entries;\n\n    return size;\n}\n```\n\n可以看到，`Dictionary`在构造的时候做了以下几件事\n\n1. 设置`size`为大于容量的一个最小质数（见目录中HashHelpers源码）。\n2. 初始化`int[] buckets`，大小为`size`,用来进行Hash碰撞。\n3. 初始化`Entry[] entries`，大小为`size`，用来存储字典的内容，并且标识下一个元素的位置。\n\n## 部分API\n\n### Add\n\n```csharp\npublic void Add(TKey key, TValue value)\n{\n    bool modified = TryInsert(key, value, InsertionBehavior.ThrowOnExisting);\n    Debug.Assert(modified); // If there was an existing key and the Add failed, an exception will already have been thrown.\n}\n```\n\nAdd这里的英文注释写的很清晰，如果有一个现有的key，并且添加失败了，那么将会抛出一个异常，接下来去看`TryInsert()`方法。\n\n因`TryInsert()`过长，这里选择拆开讲解，完整版见目录。\n\n首先，先看输入参数`TryInsert(key, value, InsertionBehavior.ThrowOnExisting)`。\n\n这里面`key`和`value`都没什么可说的，但是第三个参数可以拉出来看看。\n\n```csharp\ninternal enum InsertionBehavior : byte\n{\n    None,\n    OverwriteExisting, // 如果存在重复Key重新赋值\n    ThrowOnExisting, // 如果存在重复Key抛出异常\n}\n```\n\n这个参数将会在一会源码中看到用途，现在有个印象即可。\n\n```csharp\nIEqualityComparer<TKey>? comparer = _comparer;\n    uint hashCode = (uint)((comparer == null) ? key.GetHashCode() : comparer.GetHashCode(key));\n```\n\n根据`key`的值或者`comparer`来计算`hashCode`。\n\n```csharp\nuint collisionCount = 0;\nref int bucket = ref GetBucket(hashCode);\nint i = bucket - 1; // Value in _buckets is 1-based\n\nprivate ref int GetBucket(uint hashCode)\n{\n    int[] buckets = _buckets!;\n#if TARGET_64BIT\n            return ref buckets[HashHelpers.FastMod(hashCode, (uint)buckets.Length, _fastModMultiplier)];\n#else\n    return ref buckets[hashCode % (uint)buckets.Length];\n#endif\n}\n```\n\n根据`hashCode`计算出应该选择哪个桶。\n\n接卸来大致逻辑可以简单拆成\n\n```csharp\nif(comparer == null) //是否自己实现了比较器\n{\n\tif (typeof(TKey).IsValueType){} //Key是否是值类型\n\telse{}\n}\nelse{} //下面看这个else的内容\n```\n\n在具体代码内部中其实都差不多，所以这里选择看实现比较器的部分(也就是注释中说的哪个`else`)。\n\n```csharp\nelse\n{\n    while (true)\n    {\n        // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n        // Test uint in if rather than loop condition to drop range check for following array access\n        if ((uint)i >= (uint)entries.Length)\n        {\n            break;\n        }\n\n        if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key))\n        {\n            if (behavior == InsertionBehavior.OverwriteExisting)\n            {\n                entries[i].value = value;\n                return true;\n            }\n\n            if (behavior == InsertionBehavior.ThrowOnExisting)\n            {\n                ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n            }\n\n            return false;\n        }\n\n        i = entries[i].next;\n\n        collisionCount++;\n        if (collisionCount > (uint)entries.Length)\n        {\n            // The chain of entries forms a loop; which means a concurrent update has happened.\n            // Break out of the loop and throw, rather than looping forever.\n            ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n        }\n    }\n}\n```\n\n内部一个死循环，这部分循环有个点是比较隐藏的，那就是如何跳出这个碰撞检测。\n\n如果不发生碰撞冲突，`int i = bucket - 1`根据这个结果即可算出$i=-1$。发生碰撞的话就要分类讨论了，具体可以看源码。当然最终跳出的方案不是返回一个值就是将$i$赋值为$-1$。\n\n```csharp\nif ((uint)i >= (uint)entries.Length)\n{\n\tbreak;\n}\n```\n\n之后看这里的逻辑，在`uint`也就是无符号整数型下，`i`的大小将会是最大的，因为$-1$的底层表示为$11111111$。\n\n> 当然实际肯定不是八位，这里只是为了简单描述。\n>\n> 具体是为什么可以看一下csapp或者原码、反码、补码的知识。\n\n在这里就出现了上面提到过的参数`InsertionBehavior`枚举。很明显，如果允许覆盖就覆盖，不允许就抛出异常。\n\n```csharp\nint index;\nif (_freeCount > 0)\n{\n    index = _freeList;\n    Debug.Assert((StartOfFreeList - entries[_freeList].next) >= -1, \"shouldn't overflow because `next` cannot underflow\");\n    _freeList = StartOfFreeList - entries[_freeList].next;\n    _freeCount--;\n}\nelse\n{\n    int count = _count;\n    if (count == entries.Length)\n    {\n        Resize();\n        bucket = ref GetBucket(hashCode);\n    }\n    index = count;\n    _count = count + 1;\n    entries = _entries;\n}\n```\n\n选择合适的位置放入数据。\n\n`freeCount和freeList`在后面`Remove`中再说，不过同样都是为了选择位置。\n\n```csharp\nref Entry entry = ref entries![index];\nentry.hashCode = hashCode;\nentry.next = bucket - 1; // Value in _buckets is 1-based\nentry.key = key;\nentry.value = value;\nbucket = index + 1; // Value in _buckets is 1-based\n_version++;\n```\n\n最终`Add()`调用结束后的数值记录。\n\n### Remove\n\n```csharp\npublic bool Remove(TKey key){}\n```\n\n```csharp\nif (_buckets != null)\n{\n    uint collisionCount = 0;\n    uint hashCode = (uint)(_comparer?.GetHashCode(key) ?? key.GetHashCode());\n    ref int bucket = ref GetBucket(hashCode);\n    Entry[]? entries = _entries;\n    int last = -1;\n    int i = bucket - 1; // Value in buckets is 1-based\n    while (i >= 0)\n    {\n        ///下一段\n    }\n}\nreturn false;\n```\n\n同样还是同过key获取HashCode之后找到桶的位置。`last`用于确定最后一个元素的位置。\n\n```csharp\nwhile (i >= 0)\n{\n    ref Entry entry = ref entries[i];\n\n    if (entry.hashCode == hashCode &&\n        (_comparer?.Equals(entry.key, key) ?? EqualityComparer<TKey>.Default.Equals(entry.key, key)))\n    {\n        //下一段\n    }\n\n    last = i;\n    i = entry.next;\n\n    collisionCount++;\n    if (collisionCount > (uint)entries.Length)\n    {\n        // The chain of entries forms a loop; which means a concurrent update has happened.\n        // Break out of the loop and throw, rather than looping forever.\n        ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n    }\n}\n```\n\n遍历在同一个桶的`entry`直到找到目标元素，或者是碰撞次数过多抛出异常。\n\n```csharp\nif (entry.hashCode == hashCode && (_comparer?.Equals(entry.key, key) ?? EqualityComparer<TKey>.Default.Equals(entry.key, key)))\n{\n    if (last < 0)\n    {   // 代表当前是桶的最后一个元素，那么直接赋值即可\n        bucket = entry.next + 1; // Value in buckets is 1-based\n    }\n    else\n    {\t// 代表当前元素处于链表中间，如果直接删掉会导致链表断开，所以让其头尾相连\n        entries[last].next = entry.next;\n    }\n\t// 这里去看entry源码部分\n    entry.next = StartOfFreeList - _freeList;\n\t\n    // entry内部数据初始化\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<TKey>())\n    {\n        entry.key = default!;\n    }\n\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<TValue>())\n    {\n        entry.value = default!;\n    }\n\t// 让freeList等于当前位置\n    _freeList = i;\n    _freeCount++;\n    return true;\n}\n```\n\n这里就提到了`freeList`的作用，可以使下一次`Add`选择该位置\n\n### FindValue\n\n因为还是要区分是否存在比较器来分类讨论，依旧选择存在。\n\n```csharp\nuint hashCode = (uint)comparer.GetHashCode(key);\nint i = GetBucket(hashCode);\nEntry[]? entries = _entries;\nuint collisionCount = 0;\ni--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\ndo\n{\n    // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n    // Test in if to drop range check for following array access\n    if ((uint)i >= (uint)entries.Length)\n    {\n        goto ReturnNotFound;\n    }\n\n    entry = ref entries[i];\n    if (entry.hashCode == hashCode && comparer.Equals(entry.key, key))\n    {\n        goto ReturnFound;\n    }\n\n    i = entry.next;\n\n    collisionCount++;\n} while (collisionCount <= (uint)entries.Length);\n\n// The chain of entries forms a loop; which means a concurrent update has happened.\n// Break out of the loop and throw, rather than looping forever.\ngoto ConcurrentOperation;\n```\n\n经历了前面增删，这个查找其实变得就很清晰。说白了就是在桶里面跑一边找到就返回，找不到就寄。\n\n不过需要注意的是这里面用了很多`goto`建议在目录大致过一遍即可。\n\n```csharp\n//外部\nConcurrentOperation:\n\tThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\nReturnFound:\n\tref TValue value = ref entry.value;\nReturn:\n\treturn ref value;\nReturnNotFound:\n\tvalue = ref Unsafe.NullRef<TValue>();\ngoto Return;\n```\n\n说实话，这是我第一次见到`goto`。。。\n\n### Resize\n\n```csharp\nprivate void Resize() => Resize(HashHelpers.ExpandPrime(_count), false);\n```\n\n`HashHelpers.ExpandPrime(_count)`方法可以在目录中源码寻找，不过这里大致就理解成**大于两倍大小的最小素数**就行了\n\n```csharp\n//精简版，完整版看目录\nprivate void Resize(int newSize, bool forceNewHashCodes)\n{\n    Entry[] entries = new Entry[newSize];\n    int count = _count;\n    Array.Copy(_entries, entries, count);\n    // Assign member variables after both arrays allocated to guard against corruption from OOM if second fails\n    _buckets = new int[newSize];\n    for (int i = 0; i < count; i++)\n    {\n        if (entries[i].next >= -1)\n        {\n            ref int bucket = ref GetBucket(entries[i].hashCode);\n            entries[i].next = bucket - 1; // Value in _buckets is 1-based\n            bucket = i + 1;\n        }\n    }\n    _entries = entries;\n}\n```\n\n可以看出扩容操作其实就是，申请新的`Entry`和`buckets`，之后将现有的元素拷贝进去。\n\n## 索引器\n\n```csharp\npublic TValue this[TKey key]\n{\n    get\n    {\n        ref TValue value = ref FindValue(key);\n        if (!Unsafe.IsNullRef(ref value))\n        {\n            return value;\n        }\n\n        ThrowHelper.ThrowKeyNotFoundException(key);\n        return default;\n    }\n\n    set\n    {\n        bool modified = TryInsert(key, value, InsertionBehavior.OverwriteExisting);\n        Debug.Assert(modified);\n    }\n}\n```\n\n`get`既查找是否有`key`。\n\n`set`即插入。注意参数为`InsertionBehavior.OverwriteExisting`，所以可以覆盖元素。\n\n## 迭代器\n\n这里虽然我还没有写！！但是在`foreach`中是可以删除元素的，不能增加元素，看了源码，会发现删除不会修改版本号。！！\n\n## 源码目录\n\n### HashHelpers类部分源码\n\n```csharp\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nnamespace System.Collections\n{\n    internal static partial class HashHelpers\n    {\n        public const uint HashCollisionThreshold = 100;\n\n        // This is the maximum prime smaller than Array.MaxLength.\n        public const int MaxPrimeArrayLength = 0x7FFFFFC3;\n\n        public const int HashPrime = 101;\n\n        // Table of prime numbers to use as hash table sizes.\n        // A typical resize algorithm would pick the smallest prime number in this array\n        // that is larger than twice the previous capacity.\n        // Suppose our Hashtable currently has capacity x and enough elements are added\n        // such that a resize needs to occur. Resizing first computes 2x then finds the\n        // first prime in the table greater than 2x, i.e. if primes are ordered\n        // p_1, p_2, ..., p_i, ..., it finds p_n such that p_n-1 < 2x < p_n.\n        // Doubling is important for preserving the asymptotic complexity of the\n        // hashtable operations such as add.  Having a prime guarantees that double\n        // hashing does not lead to infinite loops.  IE, your hash function will be\n        // h1(key) + i*h2(key), 0 <= i < size.  h2 and the size must be relatively prime.\n        // We prefer the low computation costs of higher prime numbers over the increased\n        // memory allocation of a fixed prime number i.e. when right sizing a HashSet.\n        private static readonly int[] s_primes =\n        {\n            3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,\n            1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,\n            17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,\n            187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,\n            1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369\n        };\n\n        public static bool IsPrime(int candidate)\n        {\n            if ((candidate & 1) != 0)\n            {\n                int limit = (int)Math.Sqrt(candidate);\n                for (int divisor = 3; divisor <= limit; divisor += 2)\n                {\n                    if ((candidate % divisor) == 0)\n                        return false;\n                }\n                return true;\n            }\n            return candidate == 2;\n        }\n\n        public static int GetPrime(int min)\n        {\n            if (min < 0)\n                throw new ArgumentException(SR.Arg_HTCapacityOverflow);\n\n            foreach (int prime in s_primes)\n            {\n                if (prime >= min)\n                    return prime;\n            }\n\n            // Outside of our predefined table. Compute the hard way.\n            for (int i = (min | 1); i < int.MaxValue; i += 2)\n            {\n                if (IsPrime(i) && ((i - 1) % HashPrime != 0))\n                    return i;\n            }\n            return min;\n        }\n\n        // Returns size of hashtable to grow to.\n        public static int ExpandPrime(int oldSize)\n        {\n            int newSize = 2 * oldSize;\n\n            // Allow the hashtables to grow to maximum possible size (~2G elements) before encountering capacity overflow.\n            // Note that this check works even when _items.Length overflowed thanks to the (uint) cast\n            if ((uint)newSize > MaxPrimeArrayLength && MaxPrimeArrayLength > oldSize)\n            {\n                Debug.Assert(MaxPrimeArrayLength == GetPrime(MaxPrimeArrayLength), \"Invalid MaxPrimeArrayLength\");\n                return MaxPrimeArrayLength;\n            }\n\n            return GetPrime(newSize);\n        }\n\n        /// <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>\n        /// <remarks>This should only be used on 64-bit.</remarks>\n        public static ulong GetFastModMultiplier(uint divisor) =>\n            ulong.MaxValue / divisor + 1;\n\n        /// <summary>Performs a mod operation using the multiplier pre-computed with <see cref=\"GetFastModMultiplier\"/>.</summary>\n        /// <remarks>This should only be used on 64-bit.</remarks>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static uint FastMod(uint value, uint divisor, ulong multiplier)\n        {\n            // We use modified Daniel Lemire's fastmod algorithm (https://github.com/dotnet/runtime/pull/406),\n            // which allows to avoid the long multiplication if the divisor is less than 2**31.\n            Debug.Assert(divisor <= int.MaxValue);\n\n            // This is equivalent of (uint)Math.BigMul(multiplier * value, divisor, out _). This version\n            // is faster than BigMul currently because we only need the high bits.\n            uint highbits = (uint)(((((multiplier * value) >> 32) + 1) * divisor) >> 32);\n\n            Debug.Assert(highbits == value % divisor);\n            return highbits;\n        }\n    }\n}\n```\n\n### TryInsert源码\n\n```csharp\nprivate bool TryInsert(TKey key, TValue value, InsertionBehavior behavior)\n{\n    // NOTE: this method is mirrored in CollectionsMarshal.GetValueRefOrAddDefault below.\n    // If you make any changes here, make sure to keep that version in sync as well.\n\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (_buckets == null)\n    {\n        Initialize(0);\n    }\n    Debug.Assert(_buckets != null);\n\n    Entry[]? entries = _entries;\n    Debug.Assert(entries != null, \"expected entries to be non-null\");\n\n    IEqualityComparer<TKey>? comparer = _comparer;\n    uint hashCode = (uint)((comparer == null) ? key.GetHashCode() : comparer.GetHashCode(key));\n\n    uint collisionCount = 0;\n    ref int bucket = ref GetBucket(hashCode);\n    int i = bucket - 1; // Value in _buckets is 1-based\n\n    if (comparer == null)\n    {\n        if (typeof(TKey).IsValueType)\n        {\n            // ValueType: Devirtualize with EqualityComparer<TValue>.Default intrinsic\n            while (true)\n            {\n                // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                // Test uint in if rather than loop condition to drop range check for following array access\n                if ((uint)i >= (uint)entries.Length)\n                {\n                    break;\n                }\n\n                if (entries[i].hashCode == hashCode && EqualityComparer<TKey>.Default.Equals(entries[i].key, key))\n                {\n                    if (behavior == InsertionBehavior.OverwriteExisting)\n                    {\n                        entries[i].value = value;\n                        return true;\n                    }\n\n                    if (behavior == InsertionBehavior.ThrowOnExisting)\n                    {\n                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n                    }\n\n                    return false;\n                }\n\n                i = entries[i].next;\n\n                collisionCount++;\n                if (collisionCount > (uint)entries.Length)\n                {\n                    // The chain of entries forms a loop; which means a concurrent update has happened.\n                    // Break out of the loop and throw, rather than looping forever.\n                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n                }\n            }\n        }\n        else\n        {\n            // Object type: Shared Generic, EqualityComparer<TValue>.Default won't devirtualize\n            // https://github.com/dotnet/runtime/issues/10050\n            // So cache in a local rather than get EqualityComparer per loop iteration\n            EqualityComparer<TKey> defaultComparer = EqualityComparer<TKey>.Default;\n            while (true)\n            {\n                // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                // Test uint in if rather than loop condition to drop range check for following array access\n                if ((uint)i >= (uint)entries.Length)\n                {\n                    break;\n                }\n\n                if (entries[i].hashCode == hashCode && defaultComparer.Equals(entries[i].key, key))\n                {\n                    if (behavior == InsertionBehavior.OverwriteExisting)\n                    {\n                        entries[i].value = value;\n                        return true;\n                    }\n\n                    if (behavior == InsertionBehavior.ThrowOnExisting)\n                    {\n                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n                    }\n\n                    return false;\n                }\n\n                i = entries[i].next;\n\n                collisionCount++;\n                if (collisionCount > (uint)entries.Length)\n                {\n                    // The chain of entries forms a loop; which means a concurrent update has happened.\n                    // Break out of the loop and throw, rather than looping forever.\n                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n                }\n            }\n        }\n    }\n    else\n    {\n        while (true)\n        {\n            // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n            // Test uint in if rather than loop condition to drop range check for following array access\n            if ((uint)i >= (uint)entries.Length)\n            {\n                break;\n            }\n\n            if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key))\n            {\n                if (behavior == InsertionBehavior.OverwriteExisting)\n                {\n                    entries[i].value = value;\n                    return true;\n                }\n\n                if (behavior == InsertionBehavior.ThrowOnExisting)\n                {\n                    ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n                }\n\n                return false;\n            }\n\n            i = entries[i].next;\n\n            collisionCount++;\n            if (collisionCount > (uint)entries.Length)\n            {\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n            }\n        }\n    }\n\n    int index;\n    if (_freeCount > 0)\n    {\n        index = _freeList;\n        Debug.Assert((StartOfFreeList - entries[_freeList].next) >= -1, \"shouldn't overflow because `next` cannot underflow\");\n        _freeList = StartOfFreeList - entries[_freeList].next;\n        _freeCount--;\n    }\n    else\n    {\n        int count = _count;\n        if (count == entries.Length)\n        {\n            Resize();\n            bucket = ref GetBucket(hashCode);\n        }\n        index = count;\n        _count = count + 1;\n        entries = _entries;\n    }\n\n    ref Entry entry = ref entries![index];\n    entry.hashCode = hashCode;\n    entry.next = bucket - 1; // Value in _buckets is 1-based\n    entry.key = key;\n    entry.value = value;\n    bucket = index + 1; // Value in _buckets is 1-based\n    _version++;\n\n    // Value types never rehash\n    if (!typeof(TKey).IsValueType && collisionCount > HashHelpers.HashCollisionThreshold && comparer is NonRandomizedStringEqualityComparer)\n    {\n        // If we hit the collision threshold we'll need to switch to the comparer which is using randomized string hashing\n        // i.e. EqualityComparer<string>.Default.\n        Resize(entries.Length, true);\n    }\n\n    return true;\n}\n```\n\n### Resize源码\n\n```csharp\nprivate void Resize() => Resize(HashHelpers.ExpandPrime(_count), false);\nprivate void Resize(int newSize, bool forceNewHashCodes)\n{\n    // Value types never rehash\n    Debug.Assert(!forceNewHashCodes || !typeof(TKey).IsValueType);\n    Debug.Assert(_entries != null, \"_entries should be non-null\");\n    Debug.Assert(newSize >= _entries.Length);\n\n    Entry[] entries = new Entry[newSize];\n\n    int count = _count;\n    Array.Copy(_entries, entries, count);\n\n    if (!typeof(TKey).IsValueType && forceNewHashCodes)\n    {\n        Debug.Assert(_comparer is NonRandomizedStringEqualityComparer);\n        _comparer = (IEqualityComparer<TKey>)((NonRandomizedStringEqualityComparer)_comparer)\n            .GetRandomizedEqualityComparer();\n\n        for (int i = 0; i < count; i++)\n        {\n            if (entries[i].next >= -1)\n            {\n                entries[i].hashCode = (uint)_comparer.GetHashCode(entries[i].key);\n            }\n        }\n\n        if (ReferenceEquals(_comparer, EqualityComparer<TKey>.Default))\n        {\n            _comparer = null;\n        }\n    }\n\n    // Assign member variables after both arrays allocated to guard against corruption from OOM if second fails\n    _buckets = new int[newSize];\n#if TARGET_64BIT\n            _fastModMultiplier = HashHelpers.GetFastModMultiplier((uint)newSize);\n#endif\n    for (int i = 0; i < count; i++)\n    {\n        if (entries[i].next >= -1)\n        {\n            ref int bucket = ref GetBucket(entries[i].hashCode);\n            entries[i].next = bucket - 1; // Value in _buckets is 1-based\n            bucket = i + 1;\n        }\n    }\n\n    _entries = 0;\n}\n```\n\n### Remove源码\n\n```csharp\npublic bool Remove(TKey key)\n{\n    // The overload Remove(TKey key, out TValue value) is a copy of this method with one additional\n    // statement to copy the value for entry being removed into the output parameter.\n    // Code has been intentionally duplicated for performance reasons.\n\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (_buckets != null)\n    {\n        Debug.Assert(_entries != null, \"entries should be non-null\");\n        uint collisionCount = 0;\n        uint hashCode = (uint)(_comparer?.GetHashCode(key) ?? key.GetHashCode());\n        ref int bucket = ref GetBucket(hashCode);\n        Entry[]? entries = _entries;\n        int last = -1;\n        int i = bucket - 1; // Value in buckets is 1-based\n        while (i >= 0)\n        {\n            ref Entry entry = ref entries[i];\n\n            if (entry.hashCode == hashCode &&\n                (_comparer?.Equals(entry.key, key) ?? EqualityComparer<TKey>.Default.Equals(entry.key, key)))\n            {\n                if (last < 0)\n                {\n                    bucket = entry.next + 1; // Value in buckets is 1-based\n                }\n                else\n                {\n                    entries[last].next = entry.next;\n                }\n\n                Debug.Assert((StartOfFreeList - _freeList) < 0,\n                    \"shouldn't underflow because max hashtable length is MaxPrimeArrayLength = 0x7FEFFFFD(2146435069) _freelist underflow threshold 2147483646\");\n                entry.next = StartOfFreeList - _freeList;\n\n                if (RuntimeHelpers.IsReferenceOrContainsReferences<TKey>())\n                {\n                    entry.key = default!;\n                }\n\n                if (RuntimeHelpers.IsReferenceOrContainsReferences<TValue>())\n                {\n                    entry.value = default!;\n                }\n\n                _freeList = i;\n                _freeCount++;\n                return true;\n            }\n\n            last = i;\n            i = entry.next;\n\n            collisionCount++;\n            if (collisionCount > (uint)entries.Length)\n            {\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n            }\n        }\n    }\n\n    return false;\n}\n```\n\n### FindValue源码\n\n```csharp\ninternal ref TValue FindValue(TKey key)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    ref Entry entry = ref Unsafe.NullRef<Entry>();\n    if (_buckets != null)\n    {\n        Debug.Assert(_entries != null, \"expected entries to be != null\");\n        IEqualityComparer<TKey>? comparer = _comparer;\n        if (comparer == null)\n        {\n            uint hashCode = (uint)key.GetHashCode();\n            int i = GetBucket(hashCode);\n            Entry[]? entries = _entries;\n            uint collisionCount = 0;\n            if (typeof(TKey).IsValueType)\n            {\n                // ValueType: Devirtualize with EqualityComparer<TValue>.Default intrinsic\n\n                i--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\n                do\n                {\n                    // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                    // Test in if to drop range check for following array access\n                    if ((uint)i >= (uint)entries.Length)\n                    {\n                        goto ReturnNotFound;\n                    }\n\n                    entry = ref entries[i];\n                    if (entry.hashCode == hashCode && EqualityComparer<TKey>.Default.Equals(entry.key, key))\n                    {\n                        goto ReturnFound;\n                    }\n\n                    i = entry.next;\n\n                    collisionCount++;\n                } while (collisionCount <= (uint)entries.Length);\n\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                goto ConcurrentOperation;\n            }\n            else\n            {\n                // Object type: Shared Generic, EqualityComparer<TValue>.Default won't devirtualize\n                // https://github.com/dotnet/runtime/issues/10050\n                // So cache in a local rather than get EqualityComparer per loop iteration\n                EqualityComparer<TKey> defaultComparer = EqualityComparer<TKey>.Default;\n\n                i--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\n                do\n                {\n                    // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                    // Test in if to drop range check for following array access\n                    if ((uint)i >= (uint)entries.Length)\n                    {\n                        goto ReturnNotFound;\n                    }\n\n                    entry = ref entries[i];\n                    if (entry.hashCode == hashCode && defaultComparer.Equals(entry.key, key))\n                    {\n                        goto ReturnFound;\n                    }\n\n                    i = entry.next;\n\n                    collisionCount++;\n                } while (collisionCount <= (uint)entries.Length);\n\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                goto ConcurrentOperation;\n            }\n        }\n        else\n        {\n            uint hashCode = (uint)comparer.GetHashCode(key);\n            int i = GetBucket(hashCode);\n            Entry[]? entries = _entries;\n            uint collisionCount = 0;\n            i--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\n            do\n            {\n                // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                // Test in if to drop range check for following array access\n                if ((uint)i >= (uint)entries.Length)\n                {\n                    goto ReturnNotFound;\n                }\n\n                entry = ref entries[i];\n                if (entry.hashCode == hashCode && comparer.Equals(entry.key, key))\n                {\n                    goto ReturnFound;\n                }\n\n                i = entry.next;\n\n                collisionCount++;\n            } while (collisionCount <= (uint)entries.Length);\n\n            // The chain of entries forms a loop; which means a concurrent update has happened.\n            // Break out of the loop and throw, rather than looping forever.\n            goto ConcurrentOperation;\n        }\n    }\n\n    goto ReturnNotFound;\n\nConcurrentOperation:\n    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\nReturnFound:\n    ref TValue value = ref entry.value;\nReturn:\n    return ref value;\nReturnNotFound:\n    value = ref Unsafe.NullRef<TValue>();\n    goto Return;\n}\n```","source":"_posts/Dictionary源码解析.md","raw":"---\ntitle: Dictionary源码解析\ndate: 2022-02-23 16:26:01\ntags: c#\ncategories: 语言基础\n---\n\n# Dictionary源码解析\n\n## 前置知识\n\n### Hash算法\n\n**散列函数**（英语：Hash function）又称**散列算法**、**哈希函数**，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做**散列值**（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。\n\n所有的Hash函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“Hash碰撞”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。\n\n常见构造Hash函数的算法：\n\n1. 直接寻址法：取key的某个线性函数值为哈希地址。即$H(key) = a*key+b，(a,b为常量)$\n2. 数字分析法：比方有一组数据，其中每个数据都由十位数字组成。通过观察可得，每一组数据中前五位有大量重复数据，这样后五位就可以看作是随机的，即可选后五位作为哈希地址。\n3. 平方取中法：取key平方后的中间几位作为哈希地址。\n4. 折叠法：将key分成位数相同的几部分(最后一部分位数可以不同)，然后叠加和作为哈希地址。比如$12345$即可拆成$12+34+5$。\n5. 除留余数法：选定一个统一的基数p，对所有键取余，从而得到对应的哈希地址。即$H(key) = key\\mod {p}$。p的选择一般为素数或为表长。\n\n> 对于为什么取素数可以看下面链接，我们的目标是让key和p的最大公约数都为1。\n>\n> [Hash时取模一定要模质数吗？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/20806796)\n\n### Hash桶\n\n将生成的HashCode分段拆开，每一段称为一个桶，常见的桶便是对结果取余。比如源码中这一段`return ref buckets[hashCode % (uint)buckets.Length]`。\n\n### Hash碰撞\n\n一个哈希函数能够将键转化为数组索引。算法的第二步是**碰撞处理**。也就是处理两个或者多个键的散列值相同的情况。\n\n#### 拉链法\n\n将大小为$M$的数组中的每一个元素指向一条链表，链表中每个节点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法，因为发生冲突的元素都被存储在链表中。\n\n这个方法的基本思想就是选择足够大的$M$，使所有链表都尽可能保证高效的查找。\n\n> 当然，这里`M`并不是越大越好，选择一个足够大的即可。\n\n查找分为两步：\n\n1. 根据散列值找到对应的链表\n2. 沿着链表顺序查找相应的键\n\n#### 线性探测法\n\n用大小为$M$的数组保存$N$个键值对，其中$M > N$。我们需要依靠数组中的**空位**解决碰撞冲突。基于这种策略的方法被统称为开放地址散列表。\n\n其中最简单的方法叫做线性探测法：\n\n当发生碰撞时，我们直接检查散列表的下一个位置。这样的线性探测可能会产生三种结果：\n\n- 命中，该位置的键和被查找的键相同\n- 未命中，键为空（该位置没有键）\n- 继续查找，该位置的键和被查找的键不同\n\n## Dictionary构造器\n\n```csharp\nprivate struct Entry\n{\n    public uint hashCode; \n    /// <summary>\n    /// 0-based index of next entry in chain: -1 means end of chain\n    /// also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,\n    /// so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.\n    /// </summary>\n    public int next; //下一个元素的下标索引\n    public TKey key;     // Key of entry\n    public TValue value; // Value of entry\n}\n```\n\n首先引入了`Entry`结构体，这是`Dictionary`中存放数据的最小单位。\n\n```csharp\npublic class Dictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary, IReadOnlyDictionary<TKey, TValue>,\n    ISerializable, IDeserializationCallback where TKey : notnull\n{\n    private int[]? _buckets; //Hash桶\n    private Entry[]? _entries; //Entry数组，用于存放元素\n    private int _count; //当前Entries的index位置\n    private int _freeList; // 被删除Entry在Entries中的下标index\n    private int _freeCount; // 有多少被删除的Entry\n    private int _version; // 当前版本，防止迭代过程中集合被更改\n    private IEqualityComparer<TKey>? _comparer; // 比较器\n    private KeyCollection? _keys; // 存放key的集合\n    private ValueCollection? _values; // 存放Value的集合\n    private const int StartOfFreeList = -3;\n}\n```\n\n```csharp\npublic Dictionary(int capacity, IEqualityComparer<TKey>? comparer)\n{\n    if (capacity < 0)\n    {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity);\n    }\n\n    if (capacity > 0)\n    {\n        Initialize(capacity);\n    }\n\n    if (comparer is not null && comparer != EqualityComparer<TKey>.Default) // first check for null to avoid forcing default comparer instantiation unnecessarily\n    {\n        _comparer = comparer;\n    }\n\n    // Special-case EqualityComparer<string>.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.\n    // We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the\n    // hash buckets become unbalanced.\n    if (typeof(TKey) == typeof(string))\n    {\n        IEqualityComparer<string>? stringComparer = NonRandomizedStringEqualityComparer.GetStringComparer(_comparer);\n        if (stringComparer is not null)\n        {\n            _comparer = (IEqualityComparer<TKey>?)stringComparer;\n        }\n    }\n}\n```\n\n```csharp\nprivate int Initialize(int capacity)\n{\n    int size = HashHelpers.GetPrime(capacity);\n    int[] buckets = new int[size];\n    Entry[] entries = new Entry[size];\n\n    // Assign member variables after both arrays allocated to guard against corruption from OOM if second fails\n    _freeList = -1;\n    _buckets = buckets;\n    _entries = entries;\n\n    return size;\n}\n```\n\n可以看到，`Dictionary`在构造的时候做了以下几件事\n\n1. 设置`size`为大于容量的一个最小质数（见目录中HashHelpers源码）。\n2. 初始化`int[] buckets`，大小为`size`,用来进行Hash碰撞。\n3. 初始化`Entry[] entries`，大小为`size`，用来存储字典的内容，并且标识下一个元素的位置。\n\n## 部分API\n\n### Add\n\n```csharp\npublic void Add(TKey key, TValue value)\n{\n    bool modified = TryInsert(key, value, InsertionBehavior.ThrowOnExisting);\n    Debug.Assert(modified); // If there was an existing key and the Add failed, an exception will already have been thrown.\n}\n```\n\nAdd这里的英文注释写的很清晰，如果有一个现有的key，并且添加失败了，那么将会抛出一个异常，接下来去看`TryInsert()`方法。\n\n因`TryInsert()`过长，这里选择拆开讲解，完整版见目录。\n\n首先，先看输入参数`TryInsert(key, value, InsertionBehavior.ThrowOnExisting)`。\n\n这里面`key`和`value`都没什么可说的，但是第三个参数可以拉出来看看。\n\n```csharp\ninternal enum InsertionBehavior : byte\n{\n    None,\n    OverwriteExisting, // 如果存在重复Key重新赋值\n    ThrowOnExisting, // 如果存在重复Key抛出异常\n}\n```\n\n这个参数将会在一会源码中看到用途，现在有个印象即可。\n\n```csharp\nIEqualityComparer<TKey>? comparer = _comparer;\n    uint hashCode = (uint)((comparer == null) ? key.GetHashCode() : comparer.GetHashCode(key));\n```\n\n根据`key`的值或者`comparer`来计算`hashCode`。\n\n```csharp\nuint collisionCount = 0;\nref int bucket = ref GetBucket(hashCode);\nint i = bucket - 1; // Value in _buckets is 1-based\n\nprivate ref int GetBucket(uint hashCode)\n{\n    int[] buckets = _buckets!;\n#if TARGET_64BIT\n            return ref buckets[HashHelpers.FastMod(hashCode, (uint)buckets.Length, _fastModMultiplier)];\n#else\n    return ref buckets[hashCode % (uint)buckets.Length];\n#endif\n}\n```\n\n根据`hashCode`计算出应该选择哪个桶。\n\n接卸来大致逻辑可以简单拆成\n\n```csharp\nif(comparer == null) //是否自己实现了比较器\n{\n\tif (typeof(TKey).IsValueType){} //Key是否是值类型\n\telse{}\n}\nelse{} //下面看这个else的内容\n```\n\n在具体代码内部中其实都差不多，所以这里选择看实现比较器的部分(也就是注释中说的哪个`else`)。\n\n```csharp\nelse\n{\n    while (true)\n    {\n        // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n        // Test uint in if rather than loop condition to drop range check for following array access\n        if ((uint)i >= (uint)entries.Length)\n        {\n            break;\n        }\n\n        if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key))\n        {\n            if (behavior == InsertionBehavior.OverwriteExisting)\n            {\n                entries[i].value = value;\n                return true;\n            }\n\n            if (behavior == InsertionBehavior.ThrowOnExisting)\n            {\n                ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n            }\n\n            return false;\n        }\n\n        i = entries[i].next;\n\n        collisionCount++;\n        if (collisionCount > (uint)entries.Length)\n        {\n            // The chain of entries forms a loop; which means a concurrent update has happened.\n            // Break out of the loop and throw, rather than looping forever.\n            ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n        }\n    }\n}\n```\n\n内部一个死循环，这部分循环有个点是比较隐藏的，那就是如何跳出这个碰撞检测。\n\n如果不发生碰撞冲突，`int i = bucket - 1`根据这个结果即可算出$i=-1$。发生碰撞的话就要分类讨论了，具体可以看源码。当然最终跳出的方案不是返回一个值就是将$i$赋值为$-1$。\n\n```csharp\nif ((uint)i >= (uint)entries.Length)\n{\n\tbreak;\n}\n```\n\n之后看这里的逻辑，在`uint`也就是无符号整数型下，`i`的大小将会是最大的，因为$-1$的底层表示为$11111111$。\n\n> 当然实际肯定不是八位，这里只是为了简单描述。\n>\n> 具体是为什么可以看一下csapp或者原码、反码、补码的知识。\n\n在这里就出现了上面提到过的参数`InsertionBehavior`枚举。很明显，如果允许覆盖就覆盖，不允许就抛出异常。\n\n```csharp\nint index;\nif (_freeCount > 0)\n{\n    index = _freeList;\n    Debug.Assert((StartOfFreeList - entries[_freeList].next) >= -1, \"shouldn't overflow because `next` cannot underflow\");\n    _freeList = StartOfFreeList - entries[_freeList].next;\n    _freeCount--;\n}\nelse\n{\n    int count = _count;\n    if (count == entries.Length)\n    {\n        Resize();\n        bucket = ref GetBucket(hashCode);\n    }\n    index = count;\n    _count = count + 1;\n    entries = _entries;\n}\n```\n\n选择合适的位置放入数据。\n\n`freeCount和freeList`在后面`Remove`中再说，不过同样都是为了选择位置。\n\n```csharp\nref Entry entry = ref entries![index];\nentry.hashCode = hashCode;\nentry.next = bucket - 1; // Value in _buckets is 1-based\nentry.key = key;\nentry.value = value;\nbucket = index + 1; // Value in _buckets is 1-based\n_version++;\n```\n\n最终`Add()`调用结束后的数值记录。\n\n### Remove\n\n```csharp\npublic bool Remove(TKey key){}\n```\n\n```csharp\nif (_buckets != null)\n{\n    uint collisionCount = 0;\n    uint hashCode = (uint)(_comparer?.GetHashCode(key) ?? key.GetHashCode());\n    ref int bucket = ref GetBucket(hashCode);\n    Entry[]? entries = _entries;\n    int last = -1;\n    int i = bucket - 1; // Value in buckets is 1-based\n    while (i >= 0)\n    {\n        ///下一段\n    }\n}\nreturn false;\n```\n\n同样还是同过key获取HashCode之后找到桶的位置。`last`用于确定最后一个元素的位置。\n\n```csharp\nwhile (i >= 0)\n{\n    ref Entry entry = ref entries[i];\n\n    if (entry.hashCode == hashCode &&\n        (_comparer?.Equals(entry.key, key) ?? EqualityComparer<TKey>.Default.Equals(entry.key, key)))\n    {\n        //下一段\n    }\n\n    last = i;\n    i = entry.next;\n\n    collisionCount++;\n    if (collisionCount > (uint)entries.Length)\n    {\n        // The chain of entries forms a loop; which means a concurrent update has happened.\n        // Break out of the loop and throw, rather than looping forever.\n        ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n    }\n}\n```\n\n遍历在同一个桶的`entry`直到找到目标元素，或者是碰撞次数过多抛出异常。\n\n```csharp\nif (entry.hashCode == hashCode && (_comparer?.Equals(entry.key, key) ?? EqualityComparer<TKey>.Default.Equals(entry.key, key)))\n{\n    if (last < 0)\n    {   // 代表当前是桶的最后一个元素，那么直接赋值即可\n        bucket = entry.next + 1; // Value in buckets is 1-based\n    }\n    else\n    {\t// 代表当前元素处于链表中间，如果直接删掉会导致链表断开，所以让其头尾相连\n        entries[last].next = entry.next;\n    }\n\t// 这里去看entry源码部分\n    entry.next = StartOfFreeList - _freeList;\n\t\n    // entry内部数据初始化\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<TKey>())\n    {\n        entry.key = default!;\n    }\n\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<TValue>())\n    {\n        entry.value = default!;\n    }\n\t// 让freeList等于当前位置\n    _freeList = i;\n    _freeCount++;\n    return true;\n}\n```\n\n这里就提到了`freeList`的作用，可以使下一次`Add`选择该位置\n\n### FindValue\n\n因为还是要区分是否存在比较器来分类讨论，依旧选择存在。\n\n```csharp\nuint hashCode = (uint)comparer.GetHashCode(key);\nint i = GetBucket(hashCode);\nEntry[]? entries = _entries;\nuint collisionCount = 0;\ni--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\ndo\n{\n    // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n    // Test in if to drop range check for following array access\n    if ((uint)i >= (uint)entries.Length)\n    {\n        goto ReturnNotFound;\n    }\n\n    entry = ref entries[i];\n    if (entry.hashCode == hashCode && comparer.Equals(entry.key, key))\n    {\n        goto ReturnFound;\n    }\n\n    i = entry.next;\n\n    collisionCount++;\n} while (collisionCount <= (uint)entries.Length);\n\n// The chain of entries forms a loop; which means a concurrent update has happened.\n// Break out of the loop and throw, rather than looping forever.\ngoto ConcurrentOperation;\n```\n\n经历了前面增删，这个查找其实变得就很清晰。说白了就是在桶里面跑一边找到就返回，找不到就寄。\n\n不过需要注意的是这里面用了很多`goto`建议在目录大致过一遍即可。\n\n```csharp\n//外部\nConcurrentOperation:\n\tThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\nReturnFound:\n\tref TValue value = ref entry.value;\nReturn:\n\treturn ref value;\nReturnNotFound:\n\tvalue = ref Unsafe.NullRef<TValue>();\ngoto Return;\n```\n\n说实话，这是我第一次见到`goto`。。。\n\n### Resize\n\n```csharp\nprivate void Resize() => Resize(HashHelpers.ExpandPrime(_count), false);\n```\n\n`HashHelpers.ExpandPrime(_count)`方法可以在目录中源码寻找，不过这里大致就理解成**大于两倍大小的最小素数**就行了\n\n```csharp\n//精简版，完整版看目录\nprivate void Resize(int newSize, bool forceNewHashCodes)\n{\n    Entry[] entries = new Entry[newSize];\n    int count = _count;\n    Array.Copy(_entries, entries, count);\n    // Assign member variables after both arrays allocated to guard against corruption from OOM if second fails\n    _buckets = new int[newSize];\n    for (int i = 0; i < count; i++)\n    {\n        if (entries[i].next >= -1)\n        {\n            ref int bucket = ref GetBucket(entries[i].hashCode);\n            entries[i].next = bucket - 1; // Value in _buckets is 1-based\n            bucket = i + 1;\n        }\n    }\n    _entries = entries;\n}\n```\n\n可以看出扩容操作其实就是，申请新的`Entry`和`buckets`，之后将现有的元素拷贝进去。\n\n## 索引器\n\n```csharp\npublic TValue this[TKey key]\n{\n    get\n    {\n        ref TValue value = ref FindValue(key);\n        if (!Unsafe.IsNullRef(ref value))\n        {\n            return value;\n        }\n\n        ThrowHelper.ThrowKeyNotFoundException(key);\n        return default;\n    }\n\n    set\n    {\n        bool modified = TryInsert(key, value, InsertionBehavior.OverwriteExisting);\n        Debug.Assert(modified);\n    }\n}\n```\n\n`get`既查找是否有`key`。\n\n`set`即插入。注意参数为`InsertionBehavior.OverwriteExisting`，所以可以覆盖元素。\n\n## 迭代器\n\n这里虽然我还没有写！！但是在`foreach`中是可以删除元素的，不能增加元素，看了源码，会发现删除不会修改版本号。！！\n\n## 源码目录\n\n### HashHelpers类部分源码\n\n```csharp\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nnamespace System.Collections\n{\n    internal static partial class HashHelpers\n    {\n        public const uint HashCollisionThreshold = 100;\n\n        // This is the maximum prime smaller than Array.MaxLength.\n        public const int MaxPrimeArrayLength = 0x7FFFFFC3;\n\n        public const int HashPrime = 101;\n\n        // Table of prime numbers to use as hash table sizes.\n        // A typical resize algorithm would pick the smallest prime number in this array\n        // that is larger than twice the previous capacity.\n        // Suppose our Hashtable currently has capacity x and enough elements are added\n        // such that a resize needs to occur. Resizing first computes 2x then finds the\n        // first prime in the table greater than 2x, i.e. if primes are ordered\n        // p_1, p_2, ..., p_i, ..., it finds p_n such that p_n-1 < 2x < p_n.\n        // Doubling is important for preserving the asymptotic complexity of the\n        // hashtable operations such as add.  Having a prime guarantees that double\n        // hashing does not lead to infinite loops.  IE, your hash function will be\n        // h1(key) + i*h2(key), 0 <= i < size.  h2 and the size must be relatively prime.\n        // We prefer the low computation costs of higher prime numbers over the increased\n        // memory allocation of a fixed prime number i.e. when right sizing a HashSet.\n        private static readonly int[] s_primes =\n        {\n            3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,\n            1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,\n            17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,\n            187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,\n            1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369\n        };\n\n        public static bool IsPrime(int candidate)\n        {\n            if ((candidate & 1) != 0)\n            {\n                int limit = (int)Math.Sqrt(candidate);\n                for (int divisor = 3; divisor <= limit; divisor += 2)\n                {\n                    if ((candidate % divisor) == 0)\n                        return false;\n                }\n                return true;\n            }\n            return candidate == 2;\n        }\n\n        public static int GetPrime(int min)\n        {\n            if (min < 0)\n                throw new ArgumentException(SR.Arg_HTCapacityOverflow);\n\n            foreach (int prime in s_primes)\n            {\n                if (prime >= min)\n                    return prime;\n            }\n\n            // Outside of our predefined table. Compute the hard way.\n            for (int i = (min | 1); i < int.MaxValue; i += 2)\n            {\n                if (IsPrime(i) && ((i - 1) % HashPrime != 0))\n                    return i;\n            }\n            return min;\n        }\n\n        // Returns size of hashtable to grow to.\n        public static int ExpandPrime(int oldSize)\n        {\n            int newSize = 2 * oldSize;\n\n            // Allow the hashtables to grow to maximum possible size (~2G elements) before encountering capacity overflow.\n            // Note that this check works even when _items.Length overflowed thanks to the (uint) cast\n            if ((uint)newSize > MaxPrimeArrayLength && MaxPrimeArrayLength > oldSize)\n            {\n                Debug.Assert(MaxPrimeArrayLength == GetPrime(MaxPrimeArrayLength), \"Invalid MaxPrimeArrayLength\");\n                return MaxPrimeArrayLength;\n            }\n\n            return GetPrime(newSize);\n        }\n\n        /// <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>\n        /// <remarks>This should only be used on 64-bit.</remarks>\n        public static ulong GetFastModMultiplier(uint divisor) =>\n            ulong.MaxValue / divisor + 1;\n\n        /// <summary>Performs a mod operation using the multiplier pre-computed with <see cref=\"GetFastModMultiplier\"/>.</summary>\n        /// <remarks>This should only be used on 64-bit.</remarks>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static uint FastMod(uint value, uint divisor, ulong multiplier)\n        {\n            // We use modified Daniel Lemire's fastmod algorithm (https://github.com/dotnet/runtime/pull/406),\n            // which allows to avoid the long multiplication if the divisor is less than 2**31.\n            Debug.Assert(divisor <= int.MaxValue);\n\n            // This is equivalent of (uint)Math.BigMul(multiplier * value, divisor, out _). This version\n            // is faster than BigMul currently because we only need the high bits.\n            uint highbits = (uint)(((((multiplier * value) >> 32) + 1) * divisor) >> 32);\n\n            Debug.Assert(highbits == value % divisor);\n            return highbits;\n        }\n    }\n}\n```\n\n### TryInsert源码\n\n```csharp\nprivate bool TryInsert(TKey key, TValue value, InsertionBehavior behavior)\n{\n    // NOTE: this method is mirrored in CollectionsMarshal.GetValueRefOrAddDefault below.\n    // If you make any changes here, make sure to keep that version in sync as well.\n\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (_buckets == null)\n    {\n        Initialize(0);\n    }\n    Debug.Assert(_buckets != null);\n\n    Entry[]? entries = _entries;\n    Debug.Assert(entries != null, \"expected entries to be non-null\");\n\n    IEqualityComparer<TKey>? comparer = _comparer;\n    uint hashCode = (uint)((comparer == null) ? key.GetHashCode() : comparer.GetHashCode(key));\n\n    uint collisionCount = 0;\n    ref int bucket = ref GetBucket(hashCode);\n    int i = bucket - 1; // Value in _buckets is 1-based\n\n    if (comparer == null)\n    {\n        if (typeof(TKey).IsValueType)\n        {\n            // ValueType: Devirtualize with EqualityComparer<TValue>.Default intrinsic\n            while (true)\n            {\n                // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                // Test uint in if rather than loop condition to drop range check for following array access\n                if ((uint)i >= (uint)entries.Length)\n                {\n                    break;\n                }\n\n                if (entries[i].hashCode == hashCode && EqualityComparer<TKey>.Default.Equals(entries[i].key, key))\n                {\n                    if (behavior == InsertionBehavior.OverwriteExisting)\n                    {\n                        entries[i].value = value;\n                        return true;\n                    }\n\n                    if (behavior == InsertionBehavior.ThrowOnExisting)\n                    {\n                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n                    }\n\n                    return false;\n                }\n\n                i = entries[i].next;\n\n                collisionCount++;\n                if (collisionCount > (uint)entries.Length)\n                {\n                    // The chain of entries forms a loop; which means a concurrent update has happened.\n                    // Break out of the loop and throw, rather than looping forever.\n                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n                }\n            }\n        }\n        else\n        {\n            // Object type: Shared Generic, EqualityComparer<TValue>.Default won't devirtualize\n            // https://github.com/dotnet/runtime/issues/10050\n            // So cache in a local rather than get EqualityComparer per loop iteration\n            EqualityComparer<TKey> defaultComparer = EqualityComparer<TKey>.Default;\n            while (true)\n            {\n                // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                // Test uint in if rather than loop condition to drop range check for following array access\n                if ((uint)i >= (uint)entries.Length)\n                {\n                    break;\n                }\n\n                if (entries[i].hashCode == hashCode && defaultComparer.Equals(entries[i].key, key))\n                {\n                    if (behavior == InsertionBehavior.OverwriteExisting)\n                    {\n                        entries[i].value = value;\n                        return true;\n                    }\n\n                    if (behavior == InsertionBehavior.ThrowOnExisting)\n                    {\n                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n                    }\n\n                    return false;\n                }\n\n                i = entries[i].next;\n\n                collisionCount++;\n                if (collisionCount > (uint)entries.Length)\n                {\n                    // The chain of entries forms a loop; which means a concurrent update has happened.\n                    // Break out of the loop and throw, rather than looping forever.\n                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n                }\n            }\n        }\n    }\n    else\n    {\n        while (true)\n        {\n            // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n            // Test uint in if rather than loop condition to drop range check for following array access\n            if ((uint)i >= (uint)entries.Length)\n            {\n                break;\n            }\n\n            if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key))\n            {\n                if (behavior == InsertionBehavior.OverwriteExisting)\n                {\n                    entries[i].value = value;\n                    return true;\n                }\n\n                if (behavior == InsertionBehavior.ThrowOnExisting)\n                {\n                    ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);\n                }\n\n                return false;\n            }\n\n            i = entries[i].next;\n\n            collisionCount++;\n            if (collisionCount > (uint)entries.Length)\n            {\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n            }\n        }\n    }\n\n    int index;\n    if (_freeCount > 0)\n    {\n        index = _freeList;\n        Debug.Assert((StartOfFreeList - entries[_freeList].next) >= -1, \"shouldn't overflow because `next` cannot underflow\");\n        _freeList = StartOfFreeList - entries[_freeList].next;\n        _freeCount--;\n    }\n    else\n    {\n        int count = _count;\n        if (count == entries.Length)\n        {\n            Resize();\n            bucket = ref GetBucket(hashCode);\n        }\n        index = count;\n        _count = count + 1;\n        entries = _entries;\n    }\n\n    ref Entry entry = ref entries![index];\n    entry.hashCode = hashCode;\n    entry.next = bucket - 1; // Value in _buckets is 1-based\n    entry.key = key;\n    entry.value = value;\n    bucket = index + 1; // Value in _buckets is 1-based\n    _version++;\n\n    // Value types never rehash\n    if (!typeof(TKey).IsValueType && collisionCount > HashHelpers.HashCollisionThreshold && comparer is NonRandomizedStringEqualityComparer)\n    {\n        // If we hit the collision threshold we'll need to switch to the comparer which is using randomized string hashing\n        // i.e. EqualityComparer<string>.Default.\n        Resize(entries.Length, true);\n    }\n\n    return true;\n}\n```\n\n### Resize源码\n\n```csharp\nprivate void Resize() => Resize(HashHelpers.ExpandPrime(_count), false);\nprivate void Resize(int newSize, bool forceNewHashCodes)\n{\n    // Value types never rehash\n    Debug.Assert(!forceNewHashCodes || !typeof(TKey).IsValueType);\n    Debug.Assert(_entries != null, \"_entries should be non-null\");\n    Debug.Assert(newSize >= _entries.Length);\n\n    Entry[] entries = new Entry[newSize];\n\n    int count = _count;\n    Array.Copy(_entries, entries, count);\n\n    if (!typeof(TKey).IsValueType && forceNewHashCodes)\n    {\n        Debug.Assert(_comparer is NonRandomizedStringEqualityComparer);\n        _comparer = (IEqualityComparer<TKey>)((NonRandomizedStringEqualityComparer)_comparer)\n            .GetRandomizedEqualityComparer();\n\n        for (int i = 0; i < count; i++)\n        {\n            if (entries[i].next >= -1)\n            {\n                entries[i].hashCode = (uint)_comparer.GetHashCode(entries[i].key);\n            }\n        }\n\n        if (ReferenceEquals(_comparer, EqualityComparer<TKey>.Default))\n        {\n            _comparer = null;\n        }\n    }\n\n    // Assign member variables after both arrays allocated to guard against corruption from OOM if second fails\n    _buckets = new int[newSize];\n#if TARGET_64BIT\n            _fastModMultiplier = HashHelpers.GetFastModMultiplier((uint)newSize);\n#endif\n    for (int i = 0; i < count; i++)\n    {\n        if (entries[i].next >= -1)\n        {\n            ref int bucket = ref GetBucket(entries[i].hashCode);\n            entries[i].next = bucket - 1; // Value in _buckets is 1-based\n            bucket = i + 1;\n        }\n    }\n\n    _entries = 0;\n}\n```\n\n### Remove源码\n\n```csharp\npublic bool Remove(TKey key)\n{\n    // The overload Remove(TKey key, out TValue value) is a copy of this method with one additional\n    // statement to copy the value for entry being removed into the output parameter.\n    // Code has been intentionally duplicated for performance reasons.\n\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (_buckets != null)\n    {\n        Debug.Assert(_entries != null, \"entries should be non-null\");\n        uint collisionCount = 0;\n        uint hashCode = (uint)(_comparer?.GetHashCode(key) ?? key.GetHashCode());\n        ref int bucket = ref GetBucket(hashCode);\n        Entry[]? entries = _entries;\n        int last = -1;\n        int i = bucket - 1; // Value in buckets is 1-based\n        while (i >= 0)\n        {\n            ref Entry entry = ref entries[i];\n\n            if (entry.hashCode == hashCode &&\n                (_comparer?.Equals(entry.key, key) ?? EqualityComparer<TKey>.Default.Equals(entry.key, key)))\n            {\n                if (last < 0)\n                {\n                    bucket = entry.next + 1; // Value in buckets is 1-based\n                }\n                else\n                {\n                    entries[last].next = entry.next;\n                }\n\n                Debug.Assert((StartOfFreeList - _freeList) < 0,\n                    \"shouldn't underflow because max hashtable length is MaxPrimeArrayLength = 0x7FEFFFFD(2146435069) _freelist underflow threshold 2147483646\");\n                entry.next = StartOfFreeList - _freeList;\n\n                if (RuntimeHelpers.IsReferenceOrContainsReferences<TKey>())\n                {\n                    entry.key = default!;\n                }\n\n                if (RuntimeHelpers.IsReferenceOrContainsReferences<TValue>())\n                {\n                    entry.value = default!;\n                }\n\n                _freeList = i;\n                _freeCount++;\n                return true;\n            }\n\n            last = i;\n            i = entry.next;\n\n            collisionCount++;\n            if (collisionCount > (uint)entries.Length)\n            {\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\n            }\n        }\n    }\n\n    return false;\n}\n```\n\n### FindValue源码\n\n```csharp\ninternal ref TValue FindValue(TKey key)\n{\n    if (key == null)\n    {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    ref Entry entry = ref Unsafe.NullRef<Entry>();\n    if (_buckets != null)\n    {\n        Debug.Assert(_entries != null, \"expected entries to be != null\");\n        IEqualityComparer<TKey>? comparer = _comparer;\n        if (comparer == null)\n        {\n            uint hashCode = (uint)key.GetHashCode();\n            int i = GetBucket(hashCode);\n            Entry[]? entries = _entries;\n            uint collisionCount = 0;\n            if (typeof(TKey).IsValueType)\n            {\n                // ValueType: Devirtualize with EqualityComparer<TValue>.Default intrinsic\n\n                i--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\n                do\n                {\n                    // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                    // Test in if to drop range check for following array access\n                    if ((uint)i >= (uint)entries.Length)\n                    {\n                        goto ReturnNotFound;\n                    }\n\n                    entry = ref entries[i];\n                    if (entry.hashCode == hashCode && EqualityComparer<TKey>.Default.Equals(entry.key, key))\n                    {\n                        goto ReturnFound;\n                    }\n\n                    i = entry.next;\n\n                    collisionCount++;\n                } while (collisionCount <= (uint)entries.Length);\n\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                goto ConcurrentOperation;\n            }\n            else\n            {\n                // Object type: Shared Generic, EqualityComparer<TValue>.Default won't devirtualize\n                // https://github.com/dotnet/runtime/issues/10050\n                // So cache in a local rather than get EqualityComparer per loop iteration\n                EqualityComparer<TKey> defaultComparer = EqualityComparer<TKey>.Default;\n\n                i--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\n                do\n                {\n                    // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                    // Test in if to drop range check for following array access\n                    if ((uint)i >= (uint)entries.Length)\n                    {\n                        goto ReturnNotFound;\n                    }\n\n                    entry = ref entries[i];\n                    if (entry.hashCode == hashCode && defaultComparer.Equals(entry.key, key))\n                    {\n                        goto ReturnFound;\n                    }\n\n                    i = entry.next;\n\n                    collisionCount++;\n                } while (collisionCount <= (uint)entries.Length);\n\n                // The chain of entries forms a loop; which means a concurrent update has happened.\n                // Break out of the loop and throw, rather than looping forever.\n                goto ConcurrentOperation;\n            }\n        }\n        else\n        {\n            uint hashCode = (uint)comparer.GetHashCode(key);\n            int i = GetBucket(hashCode);\n            Entry[]? entries = _entries;\n            uint collisionCount = 0;\n            i--; // Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.\n            do\n            {\n                // Should be a while loop https://github.com/dotnet/runtime/issues/9422\n                // Test in if to drop range check for following array access\n                if ((uint)i >= (uint)entries.Length)\n                {\n                    goto ReturnNotFound;\n                }\n\n                entry = ref entries[i];\n                if (entry.hashCode == hashCode && comparer.Equals(entry.key, key))\n                {\n                    goto ReturnFound;\n                }\n\n                i = entry.next;\n\n                collisionCount++;\n            } while (collisionCount <= (uint)entries.Length);\n\n            // The chain of entries forms a loop; which means a concurrent update has happened.\n            // Break out of the loop and throw, rather than looping forever.\n            goto ConcurrentOperation;\n        }\n    }\n\n    goto ReturnNotFound;\n\nConcurrentOperation:\n    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();\nReturnFound:\n    ref TValue value = ref entry.value;\nReturn:\n    return ref value;\nReturnNotFound:\n    value = ref Unsafe.NullRef<TValue>();\n    goto Return;\n}\n```","slug":"Dictionary源码解析","published":1,"updated":"2022-05-02T12:50:15.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztq200032cup00hn4zoo","content":"<h1 id=\"Dictionary源码解析\">Dictionary源码解析</h1>\n<h2 id=\"前置知识\">前置知识</h2>\n<h3 id=\"Hash算法\">Hash算法</h3>\n<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>\n<p>所有的Hash函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“Hash碰撞”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。</p>\n<p>常见构造Hash函数的算法：</p>\n<ol>\n<li>直接寻址法：取key的某个线性函数值为哈希地址。即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mo>∗</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>+</mo><mi>b</mi><mtext>，</mtext><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mtext>为常量</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H(key) = a*key+b，(a,b为常量)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord cjk_fallback\">，</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord cjk_fallback\">为常量</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>数字分析法：比方有一组数据，其中每个数据都由十位数字组成。通过观察可得，每一组数据中前五位有大量重复数据，这样后五位就可以看作是随机的，即可选后五位作为哈希地址。</li>\n<li>平方取中法：取key平方后的中间几位作为哈希地址。</li>\n<li>折叠法：将key分成位数相同的几部分(最后一部分位数可以不同)，然后叠加和作为哈希地址。比如<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12345</mn></mrow><annotation encoding=\"application/x-tex\">12345</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">12345</span></span></span></span>即可拆成<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12</mn><mo>+</mo><mn>34</mn><mo>+</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">12+34+5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">12</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">34</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span>。</li>\n<li>除留余数法：选定一个统一的基数p，对所有键取余，从而得到对应的哈希地址。即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mspace></mspace><mspace width=\"0.6667em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">H(key) = key\\mod {p}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6667em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>。p的选择一般为素数或为表长。</li>\n</ol>\n<blockquote>\n<p>对于为什么取素数可以看下面链接，我们的目标是让key和p的最大公约数都为1。</p>\n<p><a href=\"https://www.zhihu.com/question/20806796\">Hash时取模一定要模质数吗？ - 知乎 (zhihu.com)</a></p>\n</blockquote>\n<h3 id=\"Hash桶\">Hash桶</h3>\n<p>将生成的HashCode分段拆开，每一段称为一个桶，常见的桶便是对结果取余。比如源码中这一段<code>return ref buckets[hashCode % (uint)buckets.Length]</code>。</p>\n<h3 id=\"Hash碰撞\">Hash碰撞</h3>\n<p>一个哈希函数能够将键转化为数组索引。算法的第二步是<strong>碰撞处理</strong>。也就是处理两个或者多个键的散列值相同的情况。</p>\n<h4 id=\"拉链法\">拉链法</h4>\n<p>将大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>的数组中的每一个元素指向一条链表，链表中每个节点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法，因为发生冲突的元素都被存储在链表中。</p>\n<p>这个方法的基本思想就是选择足够大的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>，使所有链表都尽可能保证高效的查找。</p>\n<blockquote>\n<p>当然，这里<code>M</code>并不是越大越好，选择一个足够大的即可。</p>\n</blockquote>\n<p>查找分为两步：</p>\n<ol>\n<li>根据散列值找到对应的链表</li>\n<li>沿着链表顺序查找相应的键</li>\n</ol>\n<h4 id=\"线性探测法\">线性探测法</h4>\n<p>用大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>的数组保存<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>个键值对，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M &gt; N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>。我们需要依靠数组中的<strong>空位</strong>解决碰撞冲突。基于这种策略的方法被统称为开放地址散列表。</p>\n<p>其中最简单的方法叫做线性探测法：</p>\n<p>当发生碰撞时，我们直接检查散列表的下一个位置。这样的线性探测可能会产生三种结果：</p>\n<ul>\n<li>命中，该位置的键和被查找的键相同</li>\n<li>未命中，键为空（该位置没有键）</li>\n<li>继续查找，该位置的键和被查找的键不同</li>\n</ul>\n<h2 id=\"Dictionary构造器\">Dictionary构造器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> Entry</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">uint</span> hashCode; </span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 0-based index of next entry in chain: -1 means end of chain</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> next; <span class=\"comment\">//下一个元素的下标索引</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TKey key;     <span class=\"comment\">// Key of entry</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TValue <span class=\"keyword\">value</span>; <span class=\"comment\">// Value of entry</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先引入了<code>Entry</code>结构体，这是<code>Dictionary</code>中存放数据的最小单位。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt; : <span class=\"title\">IDictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt;, <span class=\"title\">IDictionary</span>, <span class=\"title\">IReadOnlyDictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt;,</span><br><span class=\"line\">    <span class=\"title\">ISerializable</span>, <span class=\"title\">IDeserializationCallback</span> <span class=\"keyword\">where</span> <span class=\"title\">TKey</span> : <span class=\"title\">notnull</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[]? _buckets; <span class=\"comment\">//Hash桶</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[]? _entries; <span class=\"comment\">//Entry数组，用于存放元素</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _count; <span class=\"comment\">//当前Entries的index位置</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _freeList; <span class=\"comment\">// 被删除Entry在Entries中的下标index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _freeCount; <span class=\"comment\">// 有多少被删除的Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _version; <span class=\"comment\">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IEqualityComparer&lt;TKey&gt;? _comparer; <span class=\"comment\">// 比较器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KeyCollection? _keys; <span class=\"comment\">// 存放key的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueCollection? _values; <span class=\"comment\">// 存放Value的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> StartOfFreeList = <span class=\"number\">-3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dictionary</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity, IEqualityComparer&lt;TKey&gt;? comparer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (capacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (capacity &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Initialize(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparer <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span> &amp;&amp; comparer != EqualityComparer&lt;TKey&gt;.Default) <span class=\"comment\">// first check for null to avoid forcing default comparer instantiation unnecessarily</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _comparer = comparer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Special-case EqualityComparer&lt;string&gt;.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.</span></span><br><span class=\"line\">    <span class=\"comment\">// We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the</span></span><br><span class=\"line\">    <span class=\"comment\">// hash buckets become unbalanced.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey) == <span class=\"keyword\">typeof</span>(<span class=\"built_in\">string</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        IEqualityComparer&lt;<span class=\"built_in\">string</span>&gt;? stringComparer = NonRandomizedStringEqualityComparer.GetStringComparer(_comparer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stringComparer <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _comparer = (IEqualityComparer&lt;TKey&gt;?)stringComparer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> <span class=\"title\">Initialize</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> size = HashHelpers.GetPrime(capacity);</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] buckets = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[size];</span><br><span class=\"line\">    Entry[] entries = <span class=\"keyword\">new</span> Entry[size];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class=\"line\">    _freeList = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    _buckets = buckets;</span><br><span class=\"line\">    _entries = entries;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>Dictionary</code>在构造的时候做了以下几件事</p>\n<ol>\n<li>设置<code>size</code>为大于容量的一个最小质数（见目录中HashHelpers源码）。</li>\n<li>初始化<code>int[] buckets</code>，大小为<code>size</code>,用来进行Hash碰撞。</li>\n<li>初始化<code>Entry[] entries</code>，大小为<code>size</code>，用来存储字典的内容，并且标识下一个元素的位置。</li>\n</ol>\n<h2 id=\"部分API\">部分API</h2>\n<h3 id=\"Add\">Add</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Add</span>(<span class=\"params\">TKey key, TValue <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> modified = TryInsert(key, <span class=\"keyword\">value</span>, InsertionBehavior.ThrowOnExisting);</span><br><span class=\"line\">    Debug.Assert(modified); <span class=\"comment\">// If there was an existing key and the Add failed, an exception will already have been thrown.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Add这里的英文注释写的很清晰，如果有一个现有的key，并且添加失败了，那么将会抛出一个异常，接下来去看<code>TryInsert()</code>方法。</p>\n<p>因<code>TryInsert()</code>过长，这里选择拆开讲解，完整版见目录。</p>\n<p>首先，先看输入参数<code>TryInsert(key, value, InsertionBehavior.ThrowOnExisting)</code>。</p>\n<p>这里面<code>key</code>和<code>value</code>都没什么可说的，但是第三个参数可以拉出来看看。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"built_in\">enum</span> InsertionBehavior : <span class=\"built_in\">byte</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    None,</span><br><span class=\"line\">    OverwriteExisting, <span class=\"comment\">// 如果存在重复Key重新赋值</span></span><br><span class=\"line\">    ThrowOnExisting, <span class=\"comment\">// 如果存在重复Key抛出异常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个参数将会在一会源码中看到用途，现在有个印象即可。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)((comparer == <span class=\"literal\">null</span>) ? key.GetHashCode() : comparer.GetHashCode(key));</span><br></pre></td></tr></table></figure>\n<p>根据<code>key</code>的值或者<code>comparer</code>来计算<code>hashCode</code>。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> <span class=\"title\">GetBucket</span>(<span class=\"params\"><span class=\"built_in\">uint</span> hashCode</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] buckets = _buckets!;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_64BIT</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> buckets[HashHelpers.FastMod(hashCode, (<span class=\"built_in\">uint</span>)buckets.Length, _fastModMultiplier)];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> buckets[hashCode % (<span class=\"built_in\">uint</span>)buckets.Length];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据<code>hashCode</code>计算出应该选择哪个桶。</p>\n<p>接卸来大致逻辑可以简单拆成</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(comparer == <span class=\"literal\">null</span>) <span class=\"comment\">//是否自己实现了比较器</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey).IsValueType)&#123;&#125; <span class=\"comment\">//Key是否是值类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;&#125; <span class=\"comment\">//下面看这个else的内容</span></span><br></pre></td></tr></table></figure>\n<p>在具体代码内部中其实都差不多，所以这里选择看实现比较器的部分(也就是注释中说的哪个<code>else</code>)。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">        <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">        collisionCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">            <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">            ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内部一个死循环，这部分循环有个点是比较隐藏的，那就是如何跳出这个碰撞检测。</p>\n<p>如果不发生碰撞冲突，<code>int i = bucket - 1</code>根据这个结果即可算出<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i=-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。发生碰撞的话就要分类讨论了，具体可以看源码。当然最终跳出的方案不是返回一个值就是将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>赋值为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后看这里的逻辑，在<code>uint</code>也就是无符号整数型下，<code>i</code>的大小将会是最大的，因为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>的底层表示为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>11111111</mn></mrow><annotation encoding=\"application/x-tex\">11111111</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">11111111</span></span></span></span>。</p>\n<blockquote>\n<p>当然实际肯定不是八位，这里只是为了简单描述。</p>\n<p>具体是为什么可以看一下csapp或者原码、反码、补码的知识。</p>\n</blockquote>\n<p>在这里就出现了上面提到过的参数<code>InsertionBehavior</code>枚举。很明显，如果允许覆盖就覆盖，不允许就抛出异常。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> index;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (_freeCount &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    index = _freeList;</span><br><span class=\"line\">    Debug.Assert((StartOfFreeList - entries[_freeList].next) &gt;= <span class=\"number\">-1</span>, <span class=\"string\">&quot;shouldn&#x27;t overflow because `next` cannot underflow&quot;</span>);</span><br><span class=\"line\">    _freeList = StartOfFreeList - entries[_freeList].next;</span><br><span class=\"line\">    _freeCount--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == entries.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Resize();</span><br><span class=\"line\">        bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index = count;</span><br><span class=\"line\">    _count = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">    entries = _entries;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>选择合适的位置放入数据。</p>\n<p><code>freeCount和freeList</code>在后面<code>Remove</code>中再说，不过同样都是为了选择位置。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries![index];</span><br><span class=\"line\">entry.hashCode = hashCode;</span><br><span class=\"line\">entry.next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">entry.key = key;</span><br><span class=\"line\">entry.<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">bucket = index + <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">_version++;</span><br></pre></td></tr></table></figure>\n<p>最终<code>Add()</code>调用结束后的数值记录。</p>\n<h3 id=\"Remove\">Remove</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Remove</span>(<span class=\"params\">TKey key</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (_buckets != <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)(_comparer?.GetHashCode(key) ?? key.GetHashCode());</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">    Entry[]? entries = _entries;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span>下一段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>同样还是同过key获取HashCode之后找到桶的位置。<code>last</code>用于确定最后一个元素的位置。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp;</span><br><span class=\"line\">        (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//下一段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    last = i;</span><br><span class=\"line\">    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">    collisionCount++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">        <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">        ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历在同一个桶的<code>entry</code>直到找到目标元素，或者是碰撞次数过多抛出异常。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;   <span class=\"comment\">// 代表当前是桶的最后一个元素，那么直接赋值即可</span></span><br><span class=\"line\">        bucket = entry.next + <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;\t<span class=\"comment\">// 代表当前元素处于链表中间，如果直接删掉会导致链表断开，所以让其头尾相连</span></span><br><span class=\"line\">        entries[last].next = entry.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里去看entry源码部分</span></span><br><span class=\"line\">    entry.next = StartOfFreeList - _freeList;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// entry内部数据初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TKey&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        entry.key = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TValue&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        entry.<span class=\"keyword\">value</span> = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 让freeList等于当前位置</span></span><br><span class=\"line\">    _freeList = i;</span><br><span class=\"line\">    _freeCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就提到了<code>freeList</code>的作用，可以使下一次<code>Add</code>选择该位置</p>\n<h3 id=\"FindValue\">FindValue</h3>\n<p>因为还是要区分是否存在比较器来分类讨论，依旧选择存在。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)comparer.GetHashCode(key);</span><br><span class=\"line\"><span class=\"built_in\">int</span> i = GetBucket(hashCode);</span><br><span class=\"line\">Entry[]? entries = _entries;</span><br><span class=\"line\"><span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">    <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; comparer.Equals(entry.key, key))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">    collisionCount++;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\"><span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\"><span class=\"keyword\">goto</span> ConcurrentOperation;</span><br></pre></td></tr></table></figure>\n<p>经历了前面增删，这个查找其实变得就很清晰。说白了就是在桶里面跑一边找到就返回，找不到就寄。</p>\n<p>不过需要注意的是这里面用了很多<code>goto</code>建议在目录大致过一遍即可。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//外部</span></span><br><span class=\"line\">ConcurrentOperation:</span><br><span class=\"line\">\tThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">ReturnFound:</span><br><span class=\"line\">\t<span class=\"keyword\">ref</span> TValue <span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> entry.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">Return:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">ReturnNotFound:</span><br><span class=\"line\">\t<span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> Unsafe.NullRef&lt;TValue&gt;();</span><br><span class=\"line\"><span class=\"keyword\">goto</span> Return;</span><br></pre></td></tr></table></figure>\n<p>说实话，这是我第一次见到<code>goto</code>。。。</p>\n<h3 id=\"Resize\">Resize</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"></span>)</span> =&gt; Resize(HashHelpers.ExpandPrime(_count), <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p><code>HashHelpers.ExpandPrime(_count)</code>方法可以在目录中源码寻找，不过这里大致就理解成<strong>大于两倍大小的最小素数</strong>就行了</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//精简版，完整版看目录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"><span class=\"built_in\">int</span> newSize, <span class=\"built_in\">bool</span> forceNewHashCodes</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Entry[] entries = <span class=\"keyword\">new</span> Entry[newSize];</span><br><span class=\"line\">    <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">    Array.Copy(_entries, entries, count);</span><br><span class=\"line\">    <span class=\"comment\">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class=\"line\">    _buckets = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[newSize];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entries[i].next &gt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">entries[i].hashCode</span>)</span>;</span><br><span class=\"line\">            entries[i].next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">            bucket = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _entries = entries;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出扩容操作其实就是，申请新的<code>Entry</code>和<code>buckets</code>，之后将现有的元素拷贝进去。</p>\n<h2 id=\"索引器\">索引器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> TValue <span class=\"keyword\">this</span>[TKey key]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">ref</span> TValue <span class=\"keyword\">value</span> = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">FindValue</span>(<span class=\"params\">key</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Unsafe.IsNullRef(<span class=\"keyword\">ref</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ThrowHelper.ThrowKeyNotFoundException(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">default</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> modified = TryInsert(key, <span class=\"keyword\">value</span>, InsertionBehavior.OverwriteExisting);</span><br><span class=\"line\">        Debug.Assert(modified);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>get</code>既查找是否有<code>key</code>。</p>\n<p><code>set</code>即插入。注意参数为<code>InsertionBehavior.OverwriteExisting</code>，所以可以覆盖元素。</p>\n<h2 id=\"迭代器\">迭代器</h2>\n<p>这里虽然我还没有写！！但是在<code>foreach</code>中是可以删除元素的，不能增加元素，看了源码，会发现删除不会修改版本号。！！</p>\n<h2 id=\"源码目录\">源码目录</h2>\n<h3 id=\"HashHelpers类部分源码\">HashHelpers类部分源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Licensed to the .NET Foundation under one or more agreements.</span></span><br><span class=\"line\"><span class=\"comment\">// The .NET Foundation licenses this file to you under the MIT license.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Diagnostics;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Runtime.CompilerServices;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">System.Collections</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">internal</span> <span class=\"keyword\">static</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">HashHelpers</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">const</span> <span class=\"built_in\">uint</span> HashCollisionThreshold = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This is the maximum prime smaller than Array.MaxLength.</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> MaxPrimeArrayLength = <span class=\"number\">0x7FFFFFC3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> HashPrime = <span class=\"number\">101</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Table of prime numbers to use as hash table sizes.</span></span><br><span class=\"line\">        <span class=\"comment\">// A typical resize algorithm would pick the smallest prime number in this array</span></span><br><span class=\"line\">        <span class=\"comment\">// that is larger than twice the previous capacity.</span></span><br><span class=\"line\">        <span class=\"comment\">// Suppose our Hashtable currently has capacity x and enough elements are added</span></span><br><span class=\"line\">        <span class=\"comment\">// such that a resize needs to occur. Resizing first computes 2x then finds the</span></span><br><span class=\"line\">        <span class=\"comment\">// first prime in the table greater than 2x, i.e. if primes are ordered</span></span><br><span class=\"line\">        <span class=\"comment\">// p_1, p_2, ..., p_i, ..., it finds p_n such that p_n-1 &lt; 2x &lt; p_n.</span></span><br><span class=\"line\">        <span class=\"comment\">// Doubling is important for preserving the asymptotic complexity of the</span></span><br><span class=\"line\">        <span class=\"comment\">// hashtable operations such as add.  Having a prime guarantees that double</span></span><br><span class=\"line\">        <span class=\"comment\">// hashing does not lead to infinite loops.  IE, your hash function will be</span></span><br><span class=\"line\">        <span class=\"comment\">// h1(key) + i*h2(key), 0 &lt;= i &lt; size.  h2 and the size must be relatively prime.</span></span><br><span class=\"line\">        <span class=\"comment\">// We prefer the low computation costs of higher prime numbers over the increased</span></span><br><span class=\"line\">        <span class=\"comment\">// memory allocation of a fixed prime number i.e. when right sizing a HashSet.</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span>[] s_primes =</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">17</span>, <span class=\"number\">23</span>, <span class=\"number\">29</span>, <span class=\"number\">37</span>, <span class=\"number\">47</span>, <span class=\"number\">59</span>, <span class=\"number\">71</span>, <span class=\"number\">89</span>, <span class=\"number\">107</span>, <span class=\"number\">131</span>, <span class=\"number\">163</span>, <span class=\"number\">197</span>, <span class=\"number\">239</span>, <span class=\"number\">293</span>, <span class=\"number\">353</span>, <span class=\"number\">431</span>, <span class=\"number\">521</span>, <span class=\"number\">631</span>, <span class=\"number\">761</span>, <span class=\"number\">919</span>,</span><br><span class=\"line\">            <span class=\"number\">1103</span>, <span class=\"number\">1327</span>, <span class=\"number\">1597</span>, <span class=\"number\">1931</span>, <span class=\"number\">2333</span>, <span class=\"number\">2801</span>, <span class=\"number\">3371</span>, <span class=\"number\">4049</span>, <span class=\"number\">4861</span>, <span class=\"number\">5839</span>, <span class=\"number\">7013</span>, <span class=\"number\">8419</span>, <span class=\"number\">10103</span>, <span class=\"number\">12143</span>, <span class=\"number\">14591</span>,</span><br><span class=\"line\">            <span class=\"number\">17519</span>, <span class=\"number\">21023</span>, <span class=\"number\">25229</span>, <span class=\"number\">30293</span>, <span class=\"number\">36353</span>, <span class=\"number\">43627</span>, <span class=\"number\">52361</span>, <span class=\"number\">62851</span>, <span class=\"number\">75431</span>, <span class=\"number\">90523</span>, <span class=\"number\">108631</span>, <span class=\"number\">130363</span>, <span class=\"number\">156437</span>,</span><br><span class=\"line\">            <span class=\"number\">187751</span>, <span class=\"number\">225307</span>, <span class=\"number\">270371</span>, <span class=\"number\">324449</span>, <span class=\"number\">389357</span>, <span class=\"number\">467237</span>, <span class=\"number\">560689</span>, <span class=\"number\">672827</span>, <span class=\"number\">807403</span>, <span class=\"number\">968897</span>, <span class=\"number\">1162687</span>, <span class=\"number\">1395263</span>,</span><br><span class=\"line\">            <span class=\"number\">1674319</span>, <span class=\"number\">2009191</span>, <span class=\"number\">2411033</span>, <span class=\"number\">2893249</span>, <span class=\"number\">3471899</span>, <span class=\"number\">4166287</span>, <span class=\"number\">4999559</span>, <span class=\"number\">5999471</span>, <span class=\"number\">7199369</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsPrime</span>(<span class=\"params\"><span class=\"built_in\">int</span> candidate</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((candidate &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span> limit = (<span class=\"built_in\">int</span>)Math.Sqrt(candidate);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> divisor = <span class=\"number\">3</span>; divisor &lt;= limit; divisor += <span class=\"number\">2</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((candidate % divisor) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> candidate == <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"title\">GetPrime</span>(<span class=\"params\"><span class=\"built_in\">int</span> min</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArgumentException(SR.Arg_HTCapacityOverflow);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">foreach</span> (<span class=\"built_in\">int</span> prime <span class=\"keyword\">in</span> s_primes)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (prime &gt;= min)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> prime;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Outside of our predefined table. Compute the hard way.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = (min | <span class=\"number\">1</span>); i &lt; <span class=\"built_in\">int</span>.MaxValue; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (IsPrime(i) &amp;&amp; ((i - <span class=\"number\">1</span>) % HashPrime != <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Returns size of hashtable to grow to.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"title\">ExpandPrime</span>(<span class=\"params\"><span class=\"built_in\">int</span> oldSize</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> newSize = <span class=\"number\">2</span> * oldSize;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Allow the hashtables to grow to maximum possible size (~2G elements) before encountering capacity overflow.</span></span><br><span class=\"line\">            <span class=\"comment\">// Note that this check works even when _items.Length overflowed thanks to the (uint) cast</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)newSize &gt; MaxPrimeArrayLength &amp;&amp; MaxPrimeArrayLength &gt; oldSize)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Debug.Assert(MaxPrimeArrayLength == GetPrime(MaxPrimeArrayLength), <span class=\"string\">&quot;Invalid MaxPrimeArrayLength&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> MaxPrimeArrayLength;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> GetPrime(newSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).<span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;remarks&gt;</span>This should only be used on 64-bit.<span class=\"doctag\">&lt;/remarks&gt;</span></span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">ulong</span> <span class=\"title\">GetFastModMultiplier</span>(<span class=\"params\"><span class=\"built_in\">uint</span> divisor</span>)</span> =&gt;</span><br><span class=\"line\">            <span class=\"built_in\">ulong</span>.MaxValue / divisor + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span>Performs a mod operation using the multiplier pre-computed with <span class=\"doctag\">&lt;see cref=&quot;GetFastModMultiplier&quot;/&gt;</span>.<span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;remarks&gt;</span>This should only be used on 64-bit.<span class=\"doctag\">&lt;/remarks&gt;</span></span></span><br><span class=\"line\">        [<span class=\"meta\">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">uint</span> <span class=\"title\">FastMod</span>(<span class=\"params\"><span class=\"built_in\">uint</span> <span class=\"keyword\">value</span>, <span class=\"built_in\">uint</span> divisor, <span class=\"built_in\">ulong</span> multiplier</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We use modified Daniel Lemire&#x27;s fastmod algorithm (https://github.com/dotnet/runtime/pull/406),</span></span><br><span class=\"line\">            <span class=\"comment\">// which allows to avoid the long multiplication if the divisor is less than 2**31.</span></span><br><span class=\"line\">            Debug.Assert(divisor &lt;= <span class=\"built_in\">int</span>.MaxValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// This is equivalent of (uint)Math.BigMul(multiplier * value, divisor, out _). This version</span></span><br><span class=\"line\">            <span class=\"comment\">// is faster than BigMul currently because we only need the high bits.</span></span><br><span class=\"line\">            <span class=\"built_in\">uint</span> highbits = (<span class=\"built_in\">uint</span>)(((((multiplier * <span class=\"keyword\">value</span>) &gt;&gt; <span class=\"number\">32</span>) + <span class=\"number\">1</span>) * divisor) &gt;&gt; <span class=\"number\">32</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            Debug.Assert(highbits == <span class=\"keyword\">value</span> % divisor);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> highbits;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"TryInsert源码\">TryInsert源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> <span class=\"title\">TryInsert</span>(<span class=\"params\">TKey key, TValue <span class=\"keyword\">value</span>, InsertionBehavior behavior</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> this method is mirrored in CollectionsMarshal.GetValueRefOrAddDefault below.</span></span><br><span class=\"line\">    <span class=\"comment\">// If you make any changes here, make sure to keep that version in sync as well.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_buckets == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Initialize(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Debug.Assert(_buckets != <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[]? entries = _entries;</span><br><span class=\"line\">    Debug.Assert(entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;expected entries to be non-null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)((comparer == <span class=\"literal\">null</span>) ? key.GetHashCode() : comparer.GetHashCode(key));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparer == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey).IsValueType)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entries[i].key, key))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">                collisionCount++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                    <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Object type: Shared Generic, EqualityComparer&lt;TValue&gt;.Default won&#x27;t devirtualize</span></span><br><span class=\"line\">            <span class=\"comment\">// https://github.com/dotnet/runtime/issues/10050</span></span><br><span class=\"line\">            <span class=\"comment\">// So cache in a local rather than get EqualityComparer per loop iteration</span></span><br><span class=\"line\">            EqualityComparer&lt;TKey&gt; defaultComparer = EqualityComparer&lt;TKey&gt;.Default;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; defaultComparer.Equals(entries[i].key, key))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">                collisionCount++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                    <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">            <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">            collisionCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_freeCount &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        index = _freeList;</span><br><span class=\"line\">        Debug.Assert((StartOfFreeList - entries[_freeList].next) &gt;= <span class=\"number\">-1</span>, <span class=\"string\">&quot;shouldn&#x27;t overflow because `next` cannot underflow&quot;</span>);</span><br><span class=\"line\">        _freeList = StartOfFreeList - entries[_freeList].next;</span><br><span class=\"line\">        _freeCount--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == entries.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Resize();</span><br><span class=\"line\">            bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = count;</span><br><span class=\"line\">        _count = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">        entries = _entries;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries![index];</span><br><span class=\"line\">    entry.hashCode = hashCode;</span><br><span class=\"line\">    entry.next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">    entry.key = key;</span><br><span class=\"line\">    entry.<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    bucket = index + <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">    _version++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Value types never rehash</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">typeof</span>(TKey).IsValueType &amp;&amp; collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; comparer <span class=\"keyword\">is</span> NonRandomizedStringEqualityComparer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If we hit the collision threshold we&#x27;ll need to switch to the comparer which is using randomized string hashing</span></span><br><span class=\"line\">        <span class=\"comment\">// i.e. EqualityComparer&lt;string&gt;.Default.</span></span><br><span class=\"line\">        Resize(entries.Length, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Resize源码\">Resize源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"></span>)</span> =&gt; Resize(HashHelpers.ExpandPrime(_count), <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"><span class=\"built_in\">int</span> newSize, <span class=\"built_in\">bool</span> forceNewHashCodes</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Value types never rehash</span></span><br><span class=\"line\">    Debug.Assert(!forceNewHashCodes || !<span class=\"keyword\">typeof</span>(TKey).IsValueType);</span><br><span class=\"line\">    Debug.Assert(_entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;_entries should be non-null&quot;</span>);</span><br><span class=\"line\">    Debug.Assert(newSize &gt;= _entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[] entries = <span class=\"keyword\">new</span> Entry[newSize];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">    Array.Copy(_entries, entries, count);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">typeof</span>(TKey).IsValueType &amp;&amp; forceNewHashCodes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Assert(_comparer <span class=\"keyword\">is</span> NonRandomizedStringEqualityComparer);</span><br><span class=\"line\">        _comparer = (IEqualityComparer&lt;TKey&gt;)((NonRandomizedStringEqualityComparer)_comparer)</span><br><span class=\"line\">            .GetRandomizedEqualityComparer();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entries[i].next &gt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                entries[i].hashCode = (<span class=\"built_in\">uint</span>)_comparer.GetHashCode(entries[i].key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ReferenceEquals(_comparer, EqualityComparer&lt;TKey&gt;.Default))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _comparer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class=\"line\">    _buckets = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[newSize];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_64BIT</span></span><br><span class=\"line\">            _fastModMultiplier = HashHelpers.GetFastModMultiplier((<span class=\"built_in\">uint</span>)newSize);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entries[i].next &gt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">entries[i].hashCode</span>)</span>;</span><br><span class=\"line\">            entries[i].next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">            bucket = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _entries = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove源码\">Remove源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Remove</span>(<span class=\"params\">TKey key</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// The overload Remove(TKey key, out TValue value) is a copy of this method with one additional</span></span><br><span class=\"line\">    <span class=\"comment\">// statement to copy the value for entry being removed into the output parameter.</span></span><br><span class=\"line\">    <span class=\"comment\">// Code has been intentionally duplicated for performance reasons.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_buckets != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Assert(_entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;entries should be non-null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)(_comparer?.GetHashCode(key) ?? key.GetHashCode());</span><br><span class=\"line\">        <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">        Entry[]? entries = _entries;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp;</span><br><span class=\"line\">                (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    bucket = entry.next + <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entries[last].next = entry.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Debug.Assert((StartOfFreeList - _freeList) &lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;shouldn&#x27;t underflow because max hashtable length is MaxPrimeArrayLength = 0x7FEFFFFD(2146435069) _freelist underflow threshold 2147483646&quot;</span>);</span><br><span class=\"line\">                entry.next = StartOfFreeList - _freeList;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TKey&gt;())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entry.key = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TValue&gt;())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entry.<span class=\"keyword\">value</span> = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                _freeList = i;</span><br><span class=\"line\">                _freeCount++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            last = i;</span><br><span class=\"line\">            i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">            collisionCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FindValue源码\">FindValue源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"keyword\">ref</span> TValue <span class=\"title\">FindValue</span>(<span class=\"params\">TKey key</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> Unsafe.NullRef&lt;Entry&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_buckets != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Assert(_entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;expected entries to be != null&quot;</span>);</span><br><span class=\"line\">        IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparer == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)key.GetHashCode();</span><br><span class=\"line\">            <span class=\"built_in\">int</span> i = GetBucket(hashCode);</span><br><span class=\"line\">            Entry[]? entries = _entries;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey).IsValueType)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span></span><br><span class=\"line\"></span><br><span class=\"line\">                i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                    <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key))</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">                    collisionCount++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                <span class=\"keyword\">goto</span> ConcurrentOperation;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Object type: Shared Generic, EqualityComparer&lt;TValue&gt;.Default won&#x27;t devirtualize</span></span><br><span class=\"line\">                <span class=\"comment\">// https://github.com/dotnet/runtime/issues/10050</span></span><br><span class=\"line\">                <span class=\"comment\">// So cache in a local rather than get EqualityComparer per loop iteration</span></span><br><span class=\"line\">                EqualityComparer&lt;TKey&gt; defaultComparer = EqualityComparer&lt;TKey&gt;.Default;</span><br><span class=\"line\"></span><br><span class=\"line\">                i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                    <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; defaultComparer.Equals(entry.key, key))</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">                    collisionCount++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                <span class=\"keyword\">goto</span> ConcurrentOperation;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)comparer.GetHashCode(key);</span><br><span class=\"line\">            <span class=\"built_in\">int</span> i = GetBucket(hashCode);</span><br><span class=\"line\">            Entry[]? entries = _entries;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; comparer.Equals(entry.key, key))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">                collisionCount++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">            <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> ConcurrentOperation;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\"></span><br><span class=\"line\">ConcurrentOperation:</span><br><span class=\"line\">    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">ReturnFound:</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> TValue <span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> entry.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">Return:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">ReturnNotFound:</span><br><span class=\"line\">    <span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> Unsafe.NullRef&lt;TValue&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> Return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/wm8CdvX1aHoLPJY.jpg","excerpt":"","more":"<h1 id=\"Dictionary源码解析\">Dictionary源码解析</h1>\n<h2 id=\"前置知识\">前置知识</h2>\n<h3 id=\"Hash算法\">Hash算法</h3>\n<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>\n<p>所有的Hash函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“Hash碰撞”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。</p>\n<p>常见构造Hash函数的算法：</p>\n<ol>\n<li>直接寻址法：取key的某个线性函数值为哈希地址。即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mo>∗</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>+</mo><mi>b</mi><mtext>，</mtext><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mtext>为常量</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H(key) = a*key+b，(a,b为常量)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord cjk_fallback\">，</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord cjk_fallback\">为常量</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>数字分析法：比方有一组数据，其中每个数据都由十位数字组成。通过观察可得，每一组数据中前五位有大量重复数据，这样后五位就可以看作是随机的，即可选后五位作为哈希地址。</li>\n<li>平方取中法：取key平方后的中间几位作为哈希地址。</li>\n<li>折叠法：将key分成位数相同的几部分(最后一部分位数可以不同)，然后叠加和作为哈希地址。比如<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12345</mn></mrow><annotation encoding=\"application/x-tex\">12345</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">12345</span></span></span></span>即可拆成<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12</mn><mo>+</mo><mn>34</mn><mo>+</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">12+34+5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">12</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">34</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span>。</li>\n<li>除留余数法：选定一个统一的基数p，对所有键取余，从而得到对应的哈希地址。即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mspace></mspace><mspace width=\"0.6667em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">H(key) = key\\mod {p}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ey</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6667em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>。p的选择一般为素数或为表长。</li>\n</ol>\n<blockquote>\n<p>对于为什么取素数可以看下面链接，我们的目标是让key和p的最大公约数都为1。</p>\n<p><a href=\"https://www.zhihu.com/question/20806796\">Hash时取模一定要模质数吗？ - 知乎 (zhihu.com)</a></p>\n</blockquote>\n<h3 id=\"Hash桶\">Hash桶</h3>\n<p>将生成的HashCode分段拆开，每一段称为一个桶，常见的桶便是对结果取余。比如源码中这一段<code>return ref buckets[hashCode % (uint)buckets.Length]</code>。</p>\n<h3 id=\"Hash碰撞\">Hash碰撞</h3>\n<p>一个哈希函数能够将键转化为数组索引。算法的第二步是<strong>碰撞处理</strong>。也就是处理两个或者多个键的散列值相同的情况。</p>\n<h4 id=\"拉链法\">拉链法</h4>\n<p>将大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>的数组中的每一个元素指向一条链表，链表中每个节点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链法，因为发生冲突的元素都被存储在链表中。</p>\n<p>这个方法的基本思想就是选择足够大的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>，使所有链表都尽可能保证高效的查找。</p>\n<blockquote>\n<p>当然，这里<code>M</code>并不是越大越好，选择一个足够大的即可。</p>\n</blockquote>\n<p>查找分为两步：</p>\n<ol>\n<li>根据散列值找到对应的链表</li>\n<li>沿着链表顺序查找相应的键</li>\n</ol>\n<h4 id=\"线性探测法\">线性探测法</h4>\n<p>用大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>的数组保存<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>个键值对，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M &gt; N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>。我们需要依靠数组中的<strong>空位</strong>解决碰撞冲突。基于这种策略的方法被统称为开放地址散列表。</p>\n<p>其中最简单的方法叫做线性探测法：</p>\n<p>当发生碰撞时，我们直接检查散列表的下一个位置。这样的线性探测可能会产生三种结果：</p>\n<ul>\n<li>命中，该位置的键和被查找的键相同</li>\n<li>未命中，键为空（该位置没有键）</li>\n<li>继续查找，该位置的键和被查找的键不同</li>\n</ul>\n<h2 id=\"Dictionary构造器\">Dictionary构造器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> Entry</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">uint</span> hashCode; </span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 0-based index of next entry in chain: -1 means end of chain</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> next; <span class=\"comment\">//下一个元素的下标索引</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TKey key;     <span class=\"comment\">// Key of entry</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TValue <span class=\"keyword\">value</span>; <span class=\"comment\">// Value of entry</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先引入了<code>Entry</code>结构体，这是<code>Dictionary</code>中存放数据的最小单位。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt; : <span class=\"title\">IDictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt;, <span class=\"title\">IDictionary</span>, <span class=\"title\">IReadOnlyDictionary</span>&lt;<span class=\"title\">TKey</span>, <span class=\"title\">TValue</span>&gt;,</span><br><span class=\"line\">    <span class=\"title\">ISerializable</span>, <span class=\"title\">IDeserializationCallback</span> <span class=\"keyword\">where</span> <span class=\"title\">TKey</span> : <span class=\"title\">notnull</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[]? _buckets; <span class=\"comment\">//Hash桶</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[]? _entries; <span class=\"comment\">//Entry数组，用于存放元素</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _count; <span class=\"comment\">//当前Entries的index位置</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _freeList; <span class=\"comment\">// 被删除Entry在Entries中的下标index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _freeCount; <span class=\"comment\">// 有多少被删除的Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _version; <span class=\"comment\">// 当前版本，防止迭代过程中集合被更改</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IEqualityComparer&lt;TKey&gt;? _comparer; <span class=\"comment\">// 比较器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KeyCollection? _keys; <span class=\"comment\">// 存放key的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueCollection? _values; <span class=\"comment\">// 存放Value的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> StartOfFreeList = <span class=\"number\">-3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dictionary</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity, IEqualityComparer&lt;TKey&gt;? comparer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (capacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (capacity &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Initialize(capacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparer <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span> &amp;&amp; comparer != EqualityComparer&lt;TKey&gt;.Default) <span class=\"comment\">// first check for null to avoid forcing default comparer instantiation unnecessarily</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _comparer = comparer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Special-case EqualityComparer&lt;string&gt;.Default, StringComparer.Ordinal, and StringComparer.OrdinalIgnoreCase.</span></span><br><span class=\"line\">    <span class=\"comment\">// We use a non-randomized comparer for improved perf, falling back to a randomized comparer if the</span></span><br><span class=\"line\">    <span class=\"comment\">// hash buckets become unbalanced.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey) == <span class=\"keyword\">typeof</span>(<span class=\"built_in\">string</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        IEqualityComparer&lt;<span class=\"built_in\">string</span>&gt;? stringComparer = NonRandomizedStringEqualityComparer.GetStringComparer(_comparer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stringComparer <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _comparer = (IEqualityComparer&lt;TKey&gt;?)stringComparer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> <span class=\"title\">Initialize</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> size = HashHelpers.GetPrime(capacity);</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] buckets = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[size];</span><br><span class=\"line\">    Entry[] entries = <span class=\"keyword\">new</span> Entry[size];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class=\"line\">    _freeList = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    _buckets = buckets;</span><br><span class=\"line\">    _entries = entries;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>Dictionary</code>在构造的时候做了以下几件事</p>\n<ol>\n<li>设置<code>size</code>为大于容量的一个最小质数（见目录中HashHelpers源码）。</li>\n<li>初始化<code>int[] buckets</code>，大小为<code>size</code>,用来进行Hash碰撞。</li>\n<li>初始化<code>Entry[] entries</code>，大小为<code>size</code>，用来存储字典的内容，并且标识下一个元素的位置。</li>\n</ol>\n<h2 id=\"部分API\">部分API</h2>\n<h3 id=\"Add\">Add</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Add</span>(<span class=\"params\">TKey key, TValue <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> modified = TryInsert(key, <span class=\"keyword\">value</span>, InsertionBehavior.ThrowOnExisting);</span><br><span class=\"line\">    Debug.Assert(modified); <span class=\"comment\">// If there was an existing key and the Add failed, an exception will already have been thrown.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Add这里的英文注释写的很清晰，如果有一个现有的key，并且添加失败了，那么将会抛出一个异常，接下来去看<code>TryInsert()</code>方法。</p>\n<p>因<code>TryInsert()</code>过长，这里选择拆开讲解，完整版见目录。</p>\n<p>首先，先看输入参数<code>TryInsert(key, value, InsertionBehavior.ThrowOnExisting)</code>。</p>\n<p>这里面<code>key</code>和<code>value</code>都没什么可说的，但是第三个参数可以拉出来看看。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"built_in\">enum</span> InsertionBehavior : <span class=\"built_in\">byte</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    None,</span><br><span class=\"line\">    OverwriteExisting, <span class=\"comment\">// 如果存在重复Key重新赋值</span></span><br><span class=\"line\">    ThrowOnExisting, <span class=\"comment\">// 如果存在重复Key抛出异常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个参数将会在一会源码中看到用途，现在有个印象即可。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)((comparer == <span class=\"literal\">null</span>) ? key.GetHashCode() : comparer.GetHashCode(key));</span><br></pre></td></tr></table></figure>\n<p>根据<code>key</code>的值或者<code>comparer</code>来计算<code>hashCode</code>。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> <span class=\"title\">GetBucket</span>(<span class=\"params\"><span class=\"built_in\">uint</span> hashCode</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[] buckets = _buckets!;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_64BIT</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> buckets[HashHelpers.FastMod(hashCode, (<span class=\"built_in\">uint</span>)buckets.Length, _fastModMultiplier)];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> buckets[hashCode % (<span class=\"built_in\">uint</span>)buckets.Length];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据<code>hashCode</code>计算出应该选择哪个桶。</p>\n<p>接卸来大致逻辑可以简单拆成</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(comparer == <span class=\"literal\">null</span>) <span class=\"comment\">//是否自己实现了比较器</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey).IsValueType)&#123;&#125; <span class=\"comment\">//Key是否是值类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;&#125; <span class=\"comment\">//下面看这个else的内容</span></span><br></pre></td></tr></table></figure>\n<p>在具体代码内部中其实都差不多，所以这里选择看实现比较器的部分(也就是注释中说的哪个<code>else</code>)。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">        <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">        collisionCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">            <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">            ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内部一个死循环，这部分循环有个点是比较隐藏的，那就是如何跳出这个碰撞检测。</p>\n<p>如果不发生碰撞冲突，<code>int i = bucket - 1</code>根据这个结果即可算出<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i=-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。发生碰撞的话就要分类讨论了，具体可以看源码。当然最终跳出的方案不是返回一个值就是将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>赋值为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后看这里的逻辑，在<code>uint</code>也就是无符号整数型下，<code>i</code>的大小将会是最大的，因为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>的底层表示为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>11111111</mn></mrow><annotation encoding=\"application/x-tex\">11111111</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">11111111</span></span></span></span>。</p>\n<blockquote>\n<p>当然实际肯定不是八位，这里只是为了简单描述。</p>\n<p>具体是为什么可以看一下csapp或者原码、反码、补码的知识。</p>\n</blockquote>\n<p>在这里就出现了上面提到过的参数<code>InsertionBehavior</code>枚举。很明显，如果允许覆盖就覆盖，不允许就抛出异常。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> index;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (_freeCount &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    index = _freeList;</span><br><span class=\"line\">    Debug.Assert((StartOfFreeList - entries[_freeList].next) &gt;= <span class=\"number\">-1</span>, <span class=\"string\">&quot;shouldn&#x27;t overflow because `next` cannot underflow&quot;</span>);</span><br><span class=\"line\">    _freeList = StartOfFreeList - entries[_freeList].next;</span><br><span class=\"line\">    _freeCount--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == entries.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Resize();</span><br><span class=\"line\">        bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index = count;</span><br><span class=\"line\">    _count = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">    entries = _entries;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>选择合适的位置放入数据。</p>\n<p><code>freeCount和freeList</code>在后面<code>Remove</code>中再说，不过同样都是为了选择位置。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries![index];</span><br><span class=\"line\">entry.hashCode = hashCode;</span><br><span class=\"line\">entry.next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">entry.key = key;</span><br><span class=\"line\">entry.<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">bucket = index + <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">_version++;</span><br></pre></td></tr></table></figure>\n<p>最终<code>Add()</code>调用结束后的数值记录。</p>\n<h3 id=\"Remove\">Remove</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Remove</span>(<span class=\"params\">TKey key</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (_buckets != <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)(_comparer?.GetHashCode(key) ?? key.GetHashCode());</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">    Entry[]? entries = _entries;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span>下一段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>同样还是同过key获取HashCode之后找到桶的位置。<code>last</code>用于确定最后一个元素的位置。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp;</span><br><span class=\"line\">        (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//下一段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    last = i;</span><br><span class=\"line\">    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">    collisionCount++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">        <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">        ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历在同一个桶的<code>entry</code>直到找到目标元素，或者是碰撞次数过多抛出异常。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;   <span class=\"comment\">// 代表当前是桶的最后一个元素，那么直接赋值即可</span></span><br><span class=\"line\">        bucket = entry.next + <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;\t<span class=\"comment\">// 代表当前元素处于链表中间，如果直接删掉会导致链表断开，所以让其头尾相连</span></span><br><span class=\"line\">        entries[last].next = entry.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里去看entry源码部分</span></span><br><span class=\"line\">    entry.next = StartOfFreeList - _freeList;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// entry内部数据初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TKey&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        entry.key = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TValue&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        entry.<span class=\"keyword\">value</span> = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 让freeList等于当前位置</span></span><br><span class=\"line\">    _freeList = i;</span><br><span class=\"line\">    _freeCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就提到了<code>freeList</code>的作用，可以使下一次<code>Add</code>选择该位置</p>\n<h3 id=\"FindValue\">FindValue</h3>\n<p>因为还是要区分是否存在比较器来分类讨论，依旧选择存在。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)comparer.GetHashCode(key);</span><br><span class=\"line\"><span class=\"built_in\">int</span> i = GetBucket(hashCode);</span><br><span class=\"line\">Entry[]? entries = _entries;</span><br><span class=\"line\"><span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">    <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; comparer.Equals(entry.key, key))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">    collisionCount++;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\"><span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\"><span class=\"keyword\">goto</span> ConcurrentOperation;</span><br></pre></td></tr></table></figure>\n<p>经历了前面增删，这个查找其实变得就很清晰。说白了就是在桶里面跑一边找到就返回，找不到就寄。</p>\n<p>不过需要注意的是这里面用了很多<code>goto</code>建议在目录大致过一遍即可。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//外部</span></span><br><span class=\"line\">ConcurrentOperation:</span><br><span class=\"line\">\tThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">ReturnFound:</span><br><span class=\"line\">\t<span class=\"keyword\">ref</span> TValue <span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> entry.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">Return:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">ReturnNotFound:</span><br><span class=\"line\">\t<span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> Unsafe.NullRef&lt;TValue&gt;();</span><br><span class=\"line\"><span class=\"keyword\">goto</span> Return;</span><br></pre></td></tr></table></figure>\n<p>说实话，这是我第一次见到<code>goto</code>。。。</p>\n<h3 id=\"Resize\">Resize</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"></span>)</span> =&gt; Resize(HashHelpers.ExpandPrime(_count), <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p><code>HashHelpers.ExpandPrime(_count)</code>方法可以在目录中源码寻找，不过这里大致就理解成<strong>大于两倍大小的最小素数</strong>就行了</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//精简版，完整版看目录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"><span class=\"built_in\">int</span> newSize, <span class=\"built_in\">bool</span> forceNewHashCodes</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Entry[] entries = <span class=\"keyword\">new</span> Entry[newSize];</span><br><span class=\"line\">    <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">    Array.Copy(_entries, entries, count);</span><br><span class=\"line\">    <span class=\"comment\">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class=\"line\">    _buckets = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[newSize];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entries[i].next &gt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">entries[i].hashCode</span>)</span>;</span><br><span class=\"line\">            entries[i].next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">            bucket = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _entries = entries;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出扩容操作其实就是，申请新的<code>Entry</code>和<code>buckets</code>，之后将现有的元素拷贝进去。</p>\n<h2 id=\"索引器\">索引器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> TValue <span class=\"keyword\">this</span>[TKey key]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">ref</span> TValue <span class=\"keyword\">value</span> = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">FindValue</span>(<span class=\"params\">key</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Unsafe.IsNullRef(<span class=\"keyword\">ref</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ThrowHelper.ThrowKeyNotFoundException(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">default</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> modified = TryInsert(key, <span class=\"keyword\">value</span>, InsertionBehavior.OverwriteExisting);</span><br><span class=\"line\">        Debug.Assert(modified);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>get</code>既查找是否有<code>key</code>。</p>\n<p><code>set</code>即插入。注意参数为<code>InsertionBehavior.OverwriteExisting</code>，所以可以覆盖元素。</p>\n<h2 id=\"迭代器\">迭代器</h2>\n<p>这里虽然我还没有写！！但是在<code>foreach</code>中是可以删除元素的，不能增加元素，看了源码，会发现删除不会修改版本号。！！</p>\n<h2 id=\"源码目录\">源码目录</h2>\n<h3 id=\"HashHelpers类部分源码\">HashHelpers类部分源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Licensed to the .NET Foundation under one or more agreements.</span></span><br><span class=\"line\"><span class=\"comment\">// The .NET Foundation licenses this file to you under the MIT license.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Diagnostics;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Runtime.CompilerServices;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">System.Collections</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">internal</span> <span class=\"keyword\">static</span> <span class=\"keyword\">partial</span> <span class=\"keyword\">class</span> <span class=\"title\">HashHelpers</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">const</span> <span class=\"built_in\">uint</span> HashCollisionThreshold = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This is the maximum prime smaller than Array.MaxLength.</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> MaxPrimeArrayLength = <span class=\"number\">0x7FFFFFC3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> HashPrime = <span class=\"number\">101</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Table of prime numbers to use as hash table sizes.</span></span><br><span class=\"line\">        <span class=\"comment\">// A typical resize algorithm would pick the smallest prime number in this array</span></span><br><span class=\"line\">        <span class=\"comment\">// that is larger than twice the previous capacity.</span></span><br><span class=\"line\">        <span class=\"comment\">// Suppose our Hashtable currently has capacity x and enough elements are added</span></span><br><span class=\"line\">        <span class=\"comment\">// such that a resize needs to occur. Resizing first computes 2x then finds the</span></span><br><span class=\"line\">        <span class=\"comment\">// first prime in the table greater than 2x, i.e. if primes are ordered</span></span><br><span class=\"line\">        <span class=\"comment\">// p_1, p_2, ..., p_i, ..., it finds p_n such that p_n-1 &lt; 2x &lt; p_n.</span></span><br><span class=\"line\">        <span class=\"comment\">// Doubling is important for preserving the asymptotic complexity of the</span></span><br><span class=\"line\">        <span class=\"comment\">// hashtable operations such as add.  Having a prime guarantees that double</span></span><br><span class=\"line\">        <span class=\"comment\">// hashing does not lead to infinite loops.  IE, your hash function will be</span></span><br><span class=\"line\">        <span class=\"comment\">// h1(key) + i*h2(key), 0 &lt;= i &lt; size.  h2 and the size must be relatively prime.</span></span><br><span class=\"line\">        <span class=\"comment\">// We prefer the low computation costs of higher prime numbers over the increased</span></span><br><span class=\"line\">        <span class=\"comment\">// memory allocation of a fixed prime number i.e. when right sizing a HashSet.</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span>[] s_primes =</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">17</span>, <span class=\"number\">23</span>, <span class=\"number\">29</span>, <span class=\"number\">37</span>, <span class=\"number\">47</span>, <span class=\"number\">59</span>, <span class=\"number\">71</span>, <span class=\"number\">89</span>, <span class=\"number\">107</span>, <span class=\"number\">131</span>, <span class=\"number\">163</span>, <span class=\"number\">197</span>, <span class=\"number\">239</span>, <span class=\"number\">293</span>, <span class=\"number\">353</span>, <span class=\"number\">431</span>, <span class=\"number\">521</span>, <span class=\"number\">631</span>, <span class=\"number\">761</span>, <span class=\"number\">919</span>,</span><br><span class=\"line\">            <span class=\"number\">1103</span>, <span class=\"number\">1327</span>, <span class=\"number\">1597</span>, <span class=\"number\">1931</span>, <span class=\"number\">2333</span>, <span class=\"number\">2801</span>, <span class=\"number\">3371</span>, <span class=\"number\">4049</span>, <span class=\"number\">4861</span>, <span class=\"number\">5839</span>, <span class=\"number\">7013</span>, <span class=\"number\">8419</span>, <span class=\"number\">10103</span>, <span class=\"number\">12143</span>, <span class=\"number\">14591</span>,</span><br><span class=\"line\">            <span class=\"number\">17519</span>, <span class=\"number\">21023</span>, <span class=\"number\">25229</span>, <span class=\"number\">30293</span>, <span class=\"number\">36353</span>, <span class=\"number\">43627</span>, <span class=\"number\">52361</span>, <span class=\"number\">62851</span>, <span class=\"number\">75431</span>, <span class=\"number\">90523</span>, <span class=\"number\">108631</span>, <span class=\"number\">130363</span>, <span class=\"number\">156437</span>,</span><br><span class=\"line\">            <span class=\"number\">187751</span>, <span class=\"number\">225307</span>, <span class=\"number\">270371</span>, <span class=\"number\">324449</span>, <span class=\"number\">389357</span>, <span class=\"number\">467237</span>, <span class=\"number\">560689</span>, <span class=\"number\">672827</span>, <span class=\"number\">807403</span>, <span class=\"number\">968897</span>, <span class=\"number\">1162687</span>, <span class=\"number\">1395263</span>,</span><br><span class=\"line\">            <span class=\"number\">1674319</span>, <span class=\"number\">2009191</span>, <span class=\"number\">2411033</span>, <span class=\"number\">2893249</span>, <span class=\"number\">3471899</span>, <span class=\"number\">4166287</span>, <span class=\"number\">4999559</span>, <span class=\"number\">5999471</span>, <span class=\"number\">7199369</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsPrime</span>(<span class=\"params\"><span class=\"built_in\">int</span> candidate</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((candidate &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span> limit = (<span class=\"built_in\">int</span>)Math.Sqrt(candidate);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> divisor = <span class=\"number\">3</span>; divisor &lt;= limit; divisor += <span class=\"number\">2</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((candidate % divisor) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> candidate == <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"title\">GetPrime</span>(<span class=\"params\"><span class=\"built_in\">int</span> min</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArgumentException(SR.Arg_HTCapacityOverflow);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">foreach</span> (<span class=\"built_in\">int</span> prime <span class=\"keyword\">in</span> s_primes)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (prime &gt;= min)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> prime;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Outside of our predefined table. Compute the hard way.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = (min | <span class=\"number\">1</span>); i &lt; <span class=\"built_in\">int</span>.MaxValue; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (IsPrime(i) &amp;&amp; ((i - <span class=\"number\">1</span>) % HashPrime != <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Returns size of hashtable to grow to.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">int</span> <span class=\"title\">ExpandPrime</span>(<span class=\"params\"><span class=\"built_in\">int</span> oldSize</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> newSize = <span class=\"number\">2</span> * oldSize;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Allow the hashtables to grow to maximum possible size (~2G elements) before encountering capacity overflow.</span></span><br><span class=\"line\">            <span class=\"comment\">// Note that this check works even when _items.Length overflowed thanks to the (uint) cast</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)newSize &gt; MaxPrimeArrayLength &amp;&amp; MaxPrimeArrayLength &gt; oldSize)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Debug.Assert(MaxPrimeArrayLength == GetPrime(MaxPrimeArrayLength), <span class=\"string\">&quot;Invalid MaxPrimeArrayLength&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> MaxPrimeArrayLength;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> GetPrime(newSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).<span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;remarks&gt;</span>This should only be used on 64-bit.<span class=\"doctag\">&lt;/remarks&gt;</span></span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">ulong</span> <span class=\"title\">GetFastModMultiplier</span>(<span class=\"params\"><span class=\"built_in\">uint</span> divisor</span>)</span> =&gt;</span><br><span class=\"line\">            <span class=\"built_in\">ulong</span>.MaxValue / divisor + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span>Performs a mod operation using the multiplier pre-computed with <span class=\"doctag\">&lt;see cref=&quot;GetFastModMultiplier&quot;/&gt;</span>.<span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">        <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;remarks&gt;</span>This should only be used on 64-bit.<span class=\"doctag\">&lt;/remarks&gt;</span></span></span><br><span class=\"line\">        [<span class=\"meta\">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">uint</span> <span class=\"title\">FastMod</span>(<span class=\"params\"><span class=\"built_in\">uint</span> <span class=\"keyword\">value</span>, <span class=\"built_in\">uint</span> divisor, <span class=\"built_in\">ulong</span> multiplier</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We use modified Daniel Lemire&#x27;s fastmod algorithm (https://github.com/dotnet/runtime/pull/406),</span></span><br><span class=\"line\">            <span class=\"comment\">// which allows to avoid the long multiplication if the divisor is less than 2**31.</span></span><br><span class=\"line\">            Debug.Assert(divisor &lt;= <span class=\"built_in\">int</span>.MaxValue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// This is equivalent of (uint)Math.BigMul(multiplier * value, divisor, out _). This version</span></span><br><span class=\"line\">            <span class=\"comment\">// is faster than BigMul currently because we only need the high bits.</span></span><br><span class=\"line\">            <span class=\"built_in\">uint</span> highbits = (<span class=\"built_in\">uint</span>)(((((multiplier * <span class=\"keyword\">value</span>) &gt;&gt; <span class=\"number\">32</span>) + <span class=\"number\">1</span>) * divisor) &gt;&gt; <span class=\"number\">32</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            Debug.Assert(highbits == <span class=\"keyword\">value</span> % divisor);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> highbits;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"TryInsert源码\">TryInsert源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> <span class=\"title\">TryInsert</span>(<span class=\"params\">TKey key, TValue <span class=\"keyword\">value</span>, InsertionBehavior behavior</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> this method is mirrored in CollectionsMarshal.GetValueRefOrAddDefault below.</span></span><br><span class=\"line\">    <span class=\"comment\">// If you make any changes here, make sure to keep that version in sync as well.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_buckets == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Initialize(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Debug.Assert(_buckets != <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[]? entries = _entries;</span><br><span class=\"line\">    Debug.Assert(entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;expected entries to be non-null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class=\"line\">    <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)((comparer == <span class=\"literal\">null</span>) ? key.GetHashCode() : comparer.GetHashCode(key));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparer == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey).IsValueType)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entries[i].key, key))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">                collisionCount++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                    <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Object type: Shared Generic, EqualityComparer&lt;TValue&gt;.Default won&#x27;t devirtualize</span></span><br><span class=\"line\">            <span class=\"comment\">// https://github.com/dotnet/runtime/issues/10050</span></span><br><span class=\"line\">            <span class=\"comment\">// So cache in a local rather than get EqualityComparer per loop iteration</span></span><br><span class=\"line\">            EqualityComparer&lt;TKey&gt; defaultComparer = EqualityComparer&lt;TKey&gt;.Default;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; defaultComparer.Equals(entries[i].key, key))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">                collisionCount++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                    <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">            <span class=\"comment\">// Test uint in if rather than loop condition to drop range check for following array access</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (behavior == InsertionBehavior.OverwriteExisting)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entries[i].<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (behavior == InsertionBehavior.ThrowOnExisting)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            i = entries[i].next;</span><br><span class=\"line\"></span><br><span class=\"line\">            collisionCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_freeCount &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        index = _freeList;</span><br><span class=\"line\">        Debug.Assert((StartOfFreeList - entries[_freeList].next) &gt;= <span class=\"number\">-1</span>, <span class=\"string\">&quot;shouldn&#x27;t overflow because `next` cannot underflow&quot;</span>);</span><br><span class=\"line\">        _freeList = StartOfFreeList - entries[_freeList].next;</span><br><span class=\"line\">        _freeCount--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == entries.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Resize();</span><br><span class=\"line\">            bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = count;</span><br><span class=\"line\">        _count = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">        entries = _entries;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries![index];</span><br><span class=\"line\">    entry.hashCode = hashCode;</span><br><span class=\"line\">    entry.next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">    entry.key = key;</span><br><span class=\"line\">    entry.<span class=\"keyword\">value</span> = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    bucket = index + <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">    _version++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Value types never rehash</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">typeof</span>(TKey).IsValueType &amp;&amp; collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; comparer <span class=\"keyword\">is</span> NonRandomizedStringEqualityComparer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If we hit the collision threshold we&#x27;ll need to switch to the comparer which is using randomized string hashing</span></span><br><span class=\"line\">        <span class=\"comment\">// i.e. EqualityComparer&lt;string&gt;.Default.</span></span><br><span class=\"line\">        Resize(entries.Length, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Resize源码\">Resize源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"></span>)</span> =&gt; Resize(HashHelpers.ExpandPrime(_count), <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Resize</span>(<span class=\"params\"><span class=\"built_in\">int</span> newSize, <span class=\"built_in\">bool</span> forceNewHashCodes</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Value types never rehash</span></span><br><span class=\"line\">    Debug.Assert(!forceNewHashCodes || !<span class=\"keyword\">typeof</span>(TKey).IsValueType);</span><br><span class=\"line\">    Debug.Assert(_entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;_entries should be non-null&quot;</span>);</span><br><span class=\"line\">    Debug.Assert(newSize &gt;= _entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[] entries = <span class=\"keyword\">new</span> Entry[newSize];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> count = _count;</span><br><span class=\"line\">    Array.Copy(_entries, entries, count);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">typeof</span>(TKey).IsValueType &amp;&amp; forceNewHashCodes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Assert(_comparer <span class=\"keyword\">is</span> NonRandomizedStringEqualityComparer);</span><br><span class=\"line\">        _comparer = (IEqualityComparer&lt;TKey&gt;)((NonRandomizedStringEqualityComparer)_comparer)</span><br><span class=\"line\">            .GetRandomizedEqualityComparer();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entries[i].next &gt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                entries[i].hashCode = (<span class=\"built_in\">uint</span>)_comparer.GetHashCode(entries[i].key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ReferenceEquals(_comparer, EqualityComparer&lt;TKey&gt;.Default))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _comparer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Assign member variables after both arrays allocated to guard against corruption from OOM if second fails</span></span><br><span class=\"line\">    _buckets = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[newSize];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_64BIT</span></span><br><span class=\"line\">            _fastModMultiplier = HashHelpers.GetFastModMultiplier((<span class=\"built_in\">uint</span>)newSize);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entries[i].next &gt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">entries[i].hashCode</span>)</span>;</span><br><span class=\"line\">            entries[i].next = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in _buckets is 1-based</span></span><br><span class=\"line\">            bucket = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _entries = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove源码\">Remove源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Remove</span>(<span class=\"params\">TKey key</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// The overload Remove(TKey key, out TValue value) is a copy of this method with one additional</span></span><br><span class=\"line\">    <span class=\"comment\">// statement to copy the value for entry being removed into the output parameter.</span></span><br><span class=\"line\">    <span class=\"comment\">// Code has been intentionally duplicated for performance reasons.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_buckets != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Assert(_entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;entries should be non-null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)(_comparer?.GetHashCode(key) ?? key.GetHashCode());</span><br><span class=\"line\">        <span class=\"keyword\">ref</span> <span class=\"built_in\">int</span> bucket = <span class=\"function\"><span class=\"keyword\">ref</span> <span class=\"title\">GetBucket</span>(<span class=\"params\">hashCode</span>)</span>;</span><br><span class=\"line\">        Entry[]? entries = _entries;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> i = bucket - <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp;</span><br><span class=\"line\">                (_comparer?.Equals(entry.key, key) ?? EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key)))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (last &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    bucket = entry.next + <span class=\"number\">1</span>; <span class=\"comment\">// Value in buckets is 1-based</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entries[last].next = entry.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                Debug.Assert((StartOfFreeList - _freeList) &lt; <span class=\"number\">0</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;shouldn&#x27;t underflow because max hashtable length is MaxPrimeArrayLength = 0x7FEFFFFD(2146435069) _freelist underflow threshold 2147483646&quot;</span>);</span><br><span class=\"line\">                entry.next = StartOfFreeList - _freeList;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TKey&gt;())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entry.key = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;TValue&gt;())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    entry.<span class=\"keyword\">value</span> = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                _freeList = i;</span><br><span class=\"line\">                _freeCount++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            last = i;</span><br><span class=\"line\">            i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">            collisionCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (collisionCount &gt; (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FindValue源码\">FindValue源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"keyword\">ref</span> TValue <span class=\"title\">FindValue</span>(<span class=\"params\">TKey key</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">ref</span> Entry entry = <span class=\"keyword\">ref</span> Unsafe.NullRef&lt;Entry&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_buckets != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Assert(_entries != <span class=\"literal\">null</span>, <span class=\"string\">&quot;expected entries to be != null&quot;</span>);</span><br><span class=\"line\">        IEqualityComparer&lt;TKey&gt;? comparer = _comparer;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparer == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)key.GetHashCode();</span><br><span class=\"line\">            <span class=\"built_in\">int</span> i = GetBucket(hashCode);</span><br><span class=\"line\">            Entry[]? entries = _entries;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>(TKey).IsValueType)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ValueType: Devirtualize with EqualityComparer&lt;TValue&gt;.Default intrinsic</span></span><br><span class=\"line\"></span><br><span class=\"line\">                i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                    <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; EqualityComparer&lt;TKey&gt;.Default.Equals(entry.key, key))</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">                    collisionCount++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                <span class=\"keyword\">goto</span> ConcurrentOperation;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Object type: Shared Generic, EqualityComparer&lt;TValue&gt;.Default won&#x27;t devirtualize</span></span><br><span class=\"line\">                <span class=\"comment\">// https://github.com/dotnet/runtime/issues/10050</span></span><br><span class=\"line\">                <span class=\"comment\">// So cache in a local rather than get EqualityComparer per loop iteration</span></span><br><span class=\"line\">                EqualityComparer&lt;TKey&gt; defaultComparer = EqualityComparer&lt;TKey&gt;.Default;</span><br><span class=\"line\"></span><br><span class=\"line\">                i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                    <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; defaultComparer.Equals(entry.key, key))</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">                    collisionCount++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">                <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">                <span class=\"keyword\">goto</span> ConcurrentOperation;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> hashCode = (<span class=\"built_in\">uint</span>)comparer.GetHashCode(key);</span><br><span class=\"line\">            <span class=\"built_in\">int</span> i = GetBucket(hashCode);</span><br><span class=\"line\">            Entry[]? entries = _entries;</span><br><span class=\"line\">            <span class=\"built_in\">uint</span> collisionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            i--; <span class=\"comment\">// Value in _buckets is 1-based; subtract 1 from i. We do it here so it fuses with the following conditional.</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Should be a while loop https://github.com/dotnet/runtime/issues/9422</span></span><br><span class=\"line\">                <span class=\"comment\">// Test in if to drop range check for following array access</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)i &gt;= (<span class=\"built_in\">uint</span>)entries.Length)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                entry = <span class=\"keyword\">ref</span> entries[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entry.hashCode == hashCode &amp;&amp; comparer.Equals(entry.key, key))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">goto</span> ReturnFound;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                i = entry.next;</span><br><span class=\"line\"></span><br><span class=\"line\">                collisionCount++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (collisionCount &lt;= (<span class=\"built_in\">uint</span>)entries.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The chain of entries forms a loop; which means a concurrent update has happened.</span></span><br><span class=\"line\">            <span class=\"comment\">// Break out of the loop and throw, rather than looping forever.</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> ConcurrentOperation;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> ReturnNotFound;</span><br><span class=\"line\"></span><br><span class=\"line\">ConcurrentOperation:</span><br><span class=\"line\">    ThrowHelper.ThrowInvalidOperationException_ConcurrentOperationsNotSupported();</span><br><span class=\"line\">ReturnFound:</span><br><span class=\"line\">    <span class=\"keyword\">ref</span> TValue <span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> entry.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">Return:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">ref</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">ReturnNotFound:</span><br><span class=\"line\">    <span class=\"keyword\">value</span> = <span class=\"keyword\">ref</span> Unsafe.NullRef&lt;TValue&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> Return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"leetcode刷题记录","date":"2021-11-01T05:50:37.000Z","_content":"\n# 搜索\n\n## [1609. 奇偶树](https://leetcode-cn.com/problems/even-odd-tree/)\n\n---\n\n难度 `中等` | 标签 `树` `广度优先搜索` `二叉树` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<p><strong><img style=\"height: 229px; width: 362px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n<p><strong>示例 2：</strong></p>\n<p><strong><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n<p><strong>示例 3：</strong></p>\n<p><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" alt=\"\"></p>\n<pre><strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsEvenOddTree(TreeNode root) {\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n\n        int layer = 0;\n        while(queue.Count > 0)\n        {\n            int size = queue.Count;\n            int prev = layer % 2 == 0 ? int.MinValue : int.MaxValue;\n            for(int i = 0; i < size; i++)\n            {\n                TreeNode node = queue.Dequeue();\n                int value = node.val;\n\n                if(layer % 2 == value % 2)\n                    return false;\n                if((layer % 2 == 0 && value <= prev) || (layer % 2 == 1 && value >= prev))\n                    return false;\n                prev = value;\n                if(node.left != null)\n                    queue.Enqueue(node.left);\n                if(node.right != null)\n                    queue.Enqueue(node.right);\n            }\n            layer++;\n        }\n        return true;\n    }\n}\n```\n\n# 字符串\n\n## [1629. 按键持续时间最长的键](https://leetcode-cn.com/problems/slowest-key/)\n\n---\n\n难度 `简单` | 标签 `数组` `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n<p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public char SlowestKey(int[] releaseTimes, string keysPressed) {\n        int n = releaseTimes.Length;\n        char ans = keysPressed[0];\n        int maxTime = releaseTimes[0];\n        for (int i = 1; i < n; i++) {\n            char key = keysPressed[i];\n            int time = releaseTimes[i] - releaseTimes[i - 1];\n            if (time > maxTime || (time == maxTime && key > ans)) {\n                ans = key;\n                maxTime = time;\n            }\n        }\n        return ans;\n    }\n}\n\n\n```\n\n## [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n---\n\n难度 `中等` | 标签 `栈` `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的&nbsp;Unix 风格 <strong>绝对路径 </strong>（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>\n<p class=\"MachineTrans-lang-zh-CN\">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>）&nbsp;表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>\n<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>\n<ul>\n\t<li>始终以斜杠 <code>'/'</code> 开头。</li>\n\t<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>\n\t<li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>'/'</code> 结尾。</li>\n\t<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>\n</ul>\n<p>返回简化后得到的 <strong>规范路径</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>path = \"/home/\"\n<strong>输出：</strong>\"/home\"\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>path = \"/../\"\n<strong>输出：</strong>\"/\"\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>path = \"/home//foo/\"\n<strong>输出：</strong>\"/home/foo\"\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>path = \"/a/./b/../../c/\"\n<strong>输出：</strong>\"/c\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>\n\t<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string SimplifyPath(string path) {\n        string[] names = path.Split(\"/\");\n        IList<string> stack = new List<string>();\n        foreach (string name in names) {\n            if (\"..\".Equals(name)) {\n                if (stack.Count > 0) {\n                    stack.RemoveAt(stack.Count - 1);\n                }\n            } else if (name.Length > 0 && !\".\".Equals(name)) {\n                stack.Add(name);\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        if (stack.Count == 0) {\n            ans.Append('/');\n        } else {\n            foreach (string name in stack) {\n                ans.Append('/');\n                ans.Append(name);\n            }\n        }\n        return ans.ToString();\n    }\n}\n```\n\n## [1078. Bigram 分词](https://leetcode-cn.com/problems/occurrences-after-bigram/)\n\n---\n\n难度 `简单` | 标签 `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出第一个词&nbsp;<code>first</code> 和第二个词&nbsp;<code>second</code>，考虑在某些文本&nbsp;<code>text</code>&nbsp;中可能以 <code>\"first second third\"</code> 形式出现的情况，其中&nbsp;<code>second</code>&nbsp;紧随&nbsp;<code>first</code>&nbsp;出现，<code>third</code>&nbsp;紧随&nbsp;<code>second</code>&nbsp;出现。</p>\n<p>对于每种这样的情况，将第三个词 \"<code>third</code>\" 添加到答案中，并返回答案。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n<strong>输出：</strong>[\"girl\",\"student\"]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>text = \"we will we will rock you\", first = \"we\", second = \"will\"\n<strong>输出：</strong>[\"we\",\"rock\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;由小写英文字母和空格组成</li>\n\t<li><code>text</code> 中的所有单词之间都由 <strong>单个空格字符</strong> 分隔</li>\n\t<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>\n\t<li><code>first</code> 和&nbsp;<code>second</code>&nbsp;由小写英文字母组成</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string[] FindOcurrences(string text, string first, string second) {\n        string[] words = text.Split(\" \");\n        IList<string> list = new List<string>();\n        for (int i = 2; i < words.Length; i++) {\n            if (words[i - 2].Equals(first) && words[i - 1].Equals(second)) {\n                list.Add(words[i]);\n            }\n        }\n        int size = list.Count;\n        string[] ret = new string[size];\n        for (int i = 0; i < size; i++) {\n            ret[i] = list[i];\n        }\n        return ret;\n    }\n}\n\n```\n\n## [1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)\n\n---\n\n难度 `简单` | 标签 `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个仅包含小写英文字母和 <code>'?'</code> 字符的字符串 <code>s</code>，请你将所有的 <code>'?'</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>\n<p>注意：你 <strong>不能</strong> 修改非 <code>'?'</code> 字符。</p>\n<p>题目测试用例保证 <strong>除</strong> <code>'?'</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>\n<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"?zs\"\n<strong>输出：</strong>\"azs\"\n<strong>解释：</strong>该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"ubv?w\"\n<strong>输出：</strong>\"ubvaw\"\n<strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>s = \"j?qg??b\"\n<strong>输出：</strong>\"jaqgacb\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>s = \"??yw?ipkj?\"\n<strong>输出：</strong>\"acywaipkja\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 100</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母和 <code>'?'</code> 字符</p>\n\t</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string ModifyString(string s) {\n        int n = s.Length;\n        char[] arr = s.ToCharArray();\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] == '?') {\n                for (char ch = 'a'; ch <= 'c'; ++ch) {\n                    if ((i > 0 && arr[i - 1] == ch) || (i < n - 1 && arr[i + 1] == ch)) {\n                        continue;\n                    }\n                    arr[i] = ch;\n                    break;\n                }\n            }\n        }\n        return new String(arr);\n    }\n}\n\n```\n\n# 数学\n\n## [390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)\n\n---\n\n难度 `中等` | 标签 `数学` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p>\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li>\n\t<li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li>\n\t<li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li>\n</ul>\n<p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 9\n<strong>输出：</strong>6\n<strong>解释：</strong>\narr = [<strong><em>1</em></strong>, 2, <em><strong>3</strong></em>, 4, <em><strong>5</strong></em>, 6, <em><strong>7</strong></em>, 8, <em><strong>9</strong></em>]\narr = [2, <em><strong>4</strong></em>, 6, <em><strong>8</strong></em>]\narr = [<em><strong>2</strong></em>, 6]\narr = [6]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n</div>\n</div>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public int LastRemaining(int n) {\n        int a1 = 1;\n        int k = 0, cnt = n, step = 1;\n        while(cnt > 1)\n        {\n            if(k % 2 == 0)\n            {\n                a1 = a1 + step;\n            }\n            else\n            {\n                a1 = (cnt % 2 == 0) ? a1 : a1 + step;\n            }\n            k++;\n            cnt = cnt >> 1;\n            step = step << 1;\n        }\n        return a1;\n    }\n}\n```\n\n## [1185. 一周中的第几天](https://leetcode-cn.com/problems/day-of-the-week/)\n\n---\n\n难度 `简单` | 标签 `数学` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>\n<p>输入为三个整数：<code>day</code>、<code>month</code> 和&nbsp;<code>year</code>，分别表示日、月、年。</p>\n<p>您返回的结果必须是这几个值中的一个&nbsp;<code>{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}</code>。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>day = 31, month = 8, year = 2019\n<strong>输出：</strong>\"Saturday\"\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>day = 18, month = 7, year = 1999\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>day = 15, month = 8, year = 1993\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>给出的日期一定是在&nbsp;<code>1971</code> 到&nbsp;<code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string DayOfTheWeek(int day, int month, int year) {\n        string[] week = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \n\"Sunday\"};\n        int[] monthDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n        int ans = 3;\n        for(int i = 1971; i < year; i++)\n        {\n            bool isLeap = (i % 4 == 0 && i % 100 != 0) || i % 400 == 0;\n            ans += isLeap ? 366 : 365;\n        }\n\n        for(int i = 0; i < month - 1; i++)\n        {\n            ans += monthDays[i];\n            if(i == 1 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) ans += 1;\n        }\n        ans += day;\n        return week[ans % 7];\n    }\n}\n```\n\n# 我也不知道是什么鬼题型\n\n## [1995. 统计特殊四元组](https://leetcode-cn.com/problems/count-special-quadruplets/)\n\n---\n\n难度 `简单` | 标签 `数组` `枚举` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p>\n<ul>\n\t<li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li>\n\t<li><code>a &lt; b &lt; c &lt; d</code></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [1,2,3,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [3,3,6,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>[3,3,6,4,5] 中不存在满足要求的四元组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [1,1,1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足要求的 4 个四元组如下：\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public int CountQuadruplets(int[] nums) {\n\n    }\n}apublic class Solution {\n    public int CountQuadruplets(int[] nums) {\n        int n = nums.Length;\n        int ans = 0;\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        for (int c = n - 2; c >= 2; --c) {\n            if (!cnt.ContainsKey(nums[c + 1])) {\n                cnt.Add(nums[c + 1], 1);\n            } else {\n                ++cnt[nums[c + 1]];\n            }\n            for (int a = 0; a < c; ++a) {\n                for (int b = a + 1; b < c; ++b) {\n                    int sum = nums[a] + nums[b] + nums[c];\n                    if (cnt.ContainsKey(sum)) {\n                        ans += cnt[sum];\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n# 模拟\n\n## [2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)\n\n---\n\n难度 `简单` | 标签 `数组` `矩阵` `模拟` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的一维整数数组&nbsp;<code>original</code>&nbsp;和两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;&nbsp;<code>n</code>&nbsp;。你需要使用&nbsp;<code>original</code>&nbsp;中&nbsp;<strong>所有</strong>&nbsp;元素创建一个&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的二维数组。</p>\n<p><code>original</code>&nbsp;中下标从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code>&nbsp;到 <code>2 * n - 1</code>&nbsp;（都 <strong>包含</strong>&nbsp;）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个<em>&nbsp;</em><code>m x n</code>&nbsp;的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 500px; height: 174px;\" src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\">\n<pre><b>输入：</b>original = [1,2,3,4], m = 2, n = 2\n<b>输出：</b>[[1,2],[3,4]]\n<strong>解释：\n</strong>构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><b>输入：</b>original = [1,2,3], m = 1, n = 3\n<b>输出：</b>[[1,2,3]]\n<b>解释：</b>\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><b>输入：</b>original = [1,2], m = 1, n = 1\n<b>输出：</b>[]\n<strong>解释：\n</strong>original 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><b>输入：</b>original = [3], m = 1, n = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= original.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= original[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public int[][] Construct2DArray(int[] original, int m, int n) {\n        if (original.Length != m * n) {\n            return new int[0][];\n        }\n        int[][] ans = new int[m][];\n        for (int i = 0; i < m; ++i) {\n            ans[i] = new int[n];\n        }\n        for (int i = 0; i < original.Length; i += n) {\n            Array.Copy(original, i, ans[i / n], 0, n);\n        }\n        return ans;\n    }\n}\n```\n\n","source":"_posts/leetcode.md","raw":"---\ntitle: leetcode刷题记录\ndate: 2021-11-01 13:50:37\ntags: 算法\ncategories: 计算机基础知识\n---\n\n# 搜索\n\n## [1609. 奇偶树](https://leetcode-cn.com/problems/even-odd-tree/)\n\n---\n\n难度 `中等` | 标签 `树` `广度优先搜索` `二叉树` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<p><strong><img style=\"height: 229px; width: 362px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n<p><strong>示例 2：</strong></p>\n<p><strong><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n<p><strong>示例 3：</strong></p>\n<p><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" alt=\"\"></p>\n<pre><strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsEvenOddTree(TreeNode root) {\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n\n        int layer = 0;\n        while(queue.Count > 0)\n        {\n            int size = queue.Count;\n            int prev = layer % 2 == 0 ? int.MinValue : int.MaxValue;\n            for(int i = 0; i < size; i++)\n            {\n                TreeNode node = queue.Dequeue();\n                int value = node.val;\n\n                if(layer % 2 == value % 2)\n                    return false;\n                if((layer % 2 == 0 && value <= prev) || (layer % 2 == 1 && value >= prev))\n                    return false;\n                prev = value;\n                if(node.left != null)\n                    queue.Enqueue(node.left);\n                if(node.right != null)\n                    queue.Enqueue(node.right);\n            }\n            layer++;\n        }\n        return true;\n    }\n}\n```\n\n# 字符串\n\n## [1629. 按键持续时间最长的键](https://leetcode-cn.com/problems/slowest-key/)\n\n---\n\n难度 `简单` | 标签 `数组` `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n<p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public char SlowestKey(int[] releaseTimes, string keysPressed) {\n        int n = releaseTimes.Length;\n        char ans = keysPressed[0];\n        int maxTime = releaseTimes[0];\n        for (int i = 1; i < n; i++) {\n            char key = keysPressed[i];\n            int time = releaseTimes[i] - releaseTimes[i - 1];\n            if (time > maxTime || (time == maxTime && key > ans)) {\n                ans = key;\n                maxTime = time;\n            }\n        }\n        return ans;\n    }\n}\n\n\n```\n\n## [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n---\n\n难度 `中等` | 标签 `栈` `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的&nbsp;Unix 风格 <strong>绝对路径 </strong>（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>\n<p class=\"MachineTrans-lang-zh-CN\">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>）&nbsp;表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>\n<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>\n<ul>\n\t<li>始终以斜杠 <code>'/'</code> 开头。</li>\n\t<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>\n\t<li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>'/'</code> 结尾。</li>\n\t<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>\n</ul>\n<p>返回简化后得到的 <strong>规范路径</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>path = \"/home/\"\n<strong>输出：</strong>\"/home\"\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>path = \"/../\"\n<strong>输出：</strong>\"/\"\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>path = \"/home//foo/\"\n<strong>输出：</strong>\"/home/foo\"\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>path = \"/a/./b/../../c/\"\n<strong>输出：</strong>\"/c\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>\n\t<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string SimplifyPath(string path) {\n        string[] names = path.Split(\"/\");\n        IList<string> stack = new List<string>();\n        foreach (string name in names) {\n            if (\"..\".Equals(name)) {\n                if (stack.Count > 0) {\n                    stack.RemoveAt(stack.Count - 1);\n                }\n            } else if (name.Length > 0 && !\".\".Equals(name)) {\n                stack.Add(name);\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        if (stack.Count == 0) {\n            ans.Append('/');\n        } else {\n            foreach (string name in stack) {\n                ans.Append('/');\n                ans.Append(name);\n            }\n        }\n        return ans.ToString();\n    }\n}\n```\n\n## [1078. Bigram 分词](https://leetcode-cn.com/problems/occurrences-after-bigram/)\n\n---\n\n难度 `简单` | 标签 `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出第一个词&nbsp;<code>first</code> 和第二个词&nbsp;<code>second</code>，考虑在某些文本&nbsp;<code>text</code>&nbsp;中可能以 <code>\"first second third\"</code> 形式出现的情况，其中&nbsp;<code>second</code>&nbsp;紧随&nbsp;<code>first</code>&nbsp;出现，<code>third</code>&nbsp;紧随&nbsp;<code>second</code>&nbsp;出现。</p>\n<p>对于每种这样的情况，将第三个词 \"<code>third</code>\" 添加到答案中，并返回答案。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n<strong>输出：</strong>[\"girl\",\"student\"]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>text = \"we will we will rock you\", first = \"we\", second = \"will\"\n<strong>输出：</strong>[\"we\",\"rock\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;由小写英文字母和空格组成</li>\n\t<li><code>text</code> 中的所有单词之间都由 <strong>单个空格字符</strong> 分隔</li>\n\t<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>\n\t<li><code>first</code> 和&nbsp;<code>second</code>&nbsp;由小写英文字母组成</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string[] FindOcurrences(string text, string first, string second) {\n        string[] words = text.Split(\" \");\n        IList<string> list = new List<string>();\n        for (int i = 2; i < words.Length; i++) {\n            if (words[i - 2].Equals(first) && words[i - 1].Equals(second)) {\n                list.Add(words[i]);\n            }\n        }\n        int size = list.Count;\n        string[] ret = new string[size];\n        for (int i = 0; i < size; i++) {\n            ret[i] = list[i];\n        }\n        return ret;\n    }\n}\n\n```\n\n## [1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)\n\n---\n\n难度 `简单` | 标签 `字符串` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个仅包含小写英文字母和 <code>'?'</code> 字符的字符串 <code>s</code>，请你将所有的 <code>'?'</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>\n<p>注意：你 <strong>不能</strong> 修改非 <code>'?'</code> 字符。</p>\n<p>题目测试用例保证 <strong>除</strong> <code>'?'</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>\n<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"?zs\"\n<strong>输出：</strong>\"azs\"\n<strong>解释：</strong>该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"ubv?w\"\n<strong>输出：</strong>\"ubvaw\"\n<strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>s = \"j?qg??b\"\n<strong>输出：</strong>\"jaqgacb\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>s = \"??yw?ipkj?\"\n<strong>输出：</strong>\"acywaipkja\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 100</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母和 <code>'?'</code> 字符</p>\n\t</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string ModifyString(string s) {\n        int n = s.Length;\n        char[] arr = s.ToCharArray();\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] == '?') {\n                for (char ch = 'a'; ch <= 'c'; ++ch) {\n                    if ((i > 0 && arr[i - 1] == ch) || (i < n - 1 && arr[i + 1] == ch)) {\n                        continue;\n                    }\n                    arr[i] = ch;\n                    break;\n                }\n            }\n        }\n        return new String(arr);\n    }\n}\n\n```\n\n# 数学\n\n## [390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)\n\n---\n\n难度 `中等` | 标签 `数学` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p>\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li>\n\t<li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li>\n\t<li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li>\n</ul>\n<p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 9\n<strong>输出：</strong>6\n<strong>解释：</strong>\narr = [<strong><em>1</em></strong>, 2, <em><strong>3</strong></em>, 4, <em><strong>5</strong></em>, 6, <em><strong>7</strong></em>, 8, <em><strong>9</strong></em>]\narr = [2, <em><strong>4</strong></em>, 6, <em><strong>8</strong></em>]\narr = [<em><strong>2</strong></em>, 6]\narr = [6]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n</div>\n</div>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public int LastRemaining(int n) {\n        int a1 = 1;\n        int k = 0, cnt = n, step = 1;\n        while(cnt > 1)\n        {\n            if(k % 2 == 0)\n            {\n                a1 = a1 + step;\n            }\n            else\n            {\n                a1 = (cnt % 2 == 0) ? a1 : a1 + step;\n            }\n            k++;\n            cnt = cnt >> 1;\n            step = step << 1;\n        }\n        return a1;\n    }\n}\n```\n\n## [1185. 一周中的第几天](https://leetcode-cn.com/problems/day-of-the-week/)\n\n---\n\n难度 `简单` | 标签 `数学` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>\n<p>输入为三个整数：<code>day</code>、<code>month</code> 和&nbsp;<code>year</code>，分别表示日、月、年。</p>\n<p>您返回的结果必须是这几个值中的一个&nbsp;<code>{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}</code>。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>day = 31, month = 8, year = 2019\n<strong>输出：</strong>\"Saturday\"\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>day = 18, month = 7, year = 1999\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>day = 15, month = 8, year = 1993\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>给出的日期一定是在&nbsp;<code>1971</code> 到&nbsp;<code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public string DayOfTheWeek(int day, int month, int year) {\n        string[] week = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \n\"Sunday\"};\n        int[] monthDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n        int ans = 3;\n        for(int i = 1971; i < year; i++)\n        {\n            bool isLeap = (i % 4 == 0 && i % 100 != 0) || i % 400 == 0;\n            ans += isLeap ? 366 : 365;\n        }\n\n        for(int i = 0; i < month - 1; i++)\n        {\n            ans += monthDays[i];\n            if(i == 1 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) ans += 1;\n        }\n        ans += day;\n        return week[ans % 7];\n    }\n}\n```\n\n# 我也不知道是什么鬼题型\n\n## [1995. 统计特殊四元组](https://leetcode-cn.com/problems/count-special-quadruplets/)\n\n---\n\n难度 `简单` | 标签 `数组` `枚举` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p>\n<ul>\n\t<li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li>\n\t<li><code>a &lt; b &lt; c &lt; d</code></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [1,2,3,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [3,3,6,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>[3,3,6,4,5] 中不存在满足要求的四元组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [1,1,1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足要求的 4 个四元组如下：\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public int CountQuadruplets(int[] nums) {\n\n    }\n}apublic class Solution {\n    public int CountQuadruplets(int[] nums) {\n        int n = nums.Length;\n        int ans = 0;\n        Dictionary<int, int> cnt = new Dictionary<int, int>();\n        for (int c = n - 2; c >= 2; --c) {\n            if (!cnt.ContainsKey(nums[c + 1])) {\n                cnt.Add(nums[c + 1], 1);\n            } else {\n                ++cnt[nums[c + 1]];\n            }\n            for (int a = 0; a < c; ++a) {\n                for (int b = a + 1; b < c; ++b) {\n                    int sum = nums[a] + nums[b] + nums[c];\n                    if (cnt.ContainsKey(sum)) {\n                        ans += cnt[sum];\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n# 模拟\n\n## [2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)\n\n---\n\n难度 `简单` | 标签 `数组` `矩阵` `模拟` \n\n---\n\n### Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的一维整数数组&nbsp;<code>original</code>&nbsp;和两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;&nbsp;<code>n</code>&nbsp;。你需要使用&nbsp;<code>original</code>&nbsp;中&nbsp;<strong>所有</strong>&nbsp;元素创建一个&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的二维数组。</p>\n<p><code>original</code>&nbsp;中下标从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code>&nbsp;到 <code>2 * n - 1</code>&nbsp;（都 <strong>包含</strong>&nbsp;）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个<em>&nbsp;</em><code>m x n</code>&nbsp;的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 500px; height: 174px;\" src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\">\n<pre><b>输入：</b>original = [1,2,3,4], m = 2, n = 2\n<b>输出：</b>[[1,2],[3,4]]\n<strong>解释：\n</strong>构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><b>输入：</b>original = [1,2,3], m = 1, n = 3\n<b>输出：</b>[[1,2,3]]\n<b>解释：</b>\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><b>输入：</b>original = [1,2], m = 1, n = 1\n<b>输出：</b>[]\n<strong>解释：\n</strong>original 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><b>输入：</b>original = [3], m = 1, n = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= original.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= original[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n</section>\n\n### My Solution\n\n```csharp\npublic class Solution {\n    public int[][] Construct2DArray(int[] original, int m, int n) {\n        if (original.Length != m * n) {\n            return new int[0][];\n        }\n        int[][] ans = new int[m][];\n        for (int i = 0; i < m; ++i) {\n            ans[i] = new int[n];\n        }\n        for (int i = 0; i < original.Length; i += n) {\n            Array.Copy(original, i, ans[i / n], 0, n);\n        }\n        return ans;\n    }\n}\n```\n\n","slug":"leetcode","published":1,"updated":"2022-01-09T13:25:50.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztq500072cup43h8cc4p","content":"<h1 id=\"搜索\">搜索</h1>\n<h2 id=\"1609-奇偶树\"><a href=\"https://leetcode-cn.com/problems/even-odd-tree/\">1609. 奇偶树</a></h2>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>树</code> <code>广度优先搜索</code> <code>二叉树</code></p>\n<hr>\n<h3 id=\"Description\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<p><strong><img style=\"height: 229px; width: 362px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n<p><strong>示例 2：</strong></p>\n<p><strong><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n<p><strong>示例 3：</strong></p>\n<p><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" alt=\"\"></p>\n<pre><strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n</section>\n<h3 id=\"My-Solution\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsEvenOddTree</span>(<span class=\"params\">TreeNode root</span>)</span> &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.Enqueue(root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> layer = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(queue.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> size = queue.Count;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> prev = layer % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? <span class=\"built_in\">int</span>.MinValue : <span class=\"built_in\">int</span>.MaxValue;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode node = queue.Dequeue();</span><br><span class=\"line\">                <span class=\"built_in\">int</span> <span class=\"keyword\">value</span> = node.val;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(layer % <span class=\"number\">2</span> == <span class=\"keyword\">value</span> % <span class=\"number\">2</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((layer % <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">value</span> &lt;= prev) || (layer % <span class=\"number\">2</span> == <span class=\"number\">1</span> &amp;&amp; <span class=\"keyword\">value</span> &gt;= prev))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                prev = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.left != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    queue.Enqueue(node.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.right != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    queue.Enqueue(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            layer++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串\">字符串</h1>\n<h2 id=\"1629-按键持续时间最长的键\"><a href=\"https://leetcode-cn.com/problems/slowest-key/\">1629. 按键持续时间最长的键</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-2\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n<p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-2\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">char</span> <span class=\"title\">SlowestKey</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] releaseTimes, <span class=\"built_in\">string</span> keysPressed</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = releaseTimes.Length;</span><br><span class=\"line\">        <span class=\"built_in\">char</span> ans = keysPressed[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span> maxTime = releaseTimes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">char</span> key = keysPressed[i];</span><br><span class=\"line\">            <span class=\"built_in\">int</span> time = releaseTimes[i] - releaseTimes[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; maxTime || (time == maxTime &amp;&amp; key &gt; ans)) &#123;</span><br><span class=\"line\">                ans = key;</span><br><span class=\"line\">                maxTime = time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"71-简化路径\"><a href=\"https://leetcode-cn.com/problems/simplify-path/\">71. 简化路径</a></h2>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>栈</code> <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-3\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的&nbsp;Unix 风格 <strong>绝对路径 </strong>（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>\n<p class=\"MachineTrans-lang-zh-CN\">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>）&nbsp;表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>\n<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>\n<ul>\n\t<li>始终以斜杠 <code>'/'</code> 开头。</li>\n\t<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>\n\t<li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>'/'</code> 结尾。</li>\n\t<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>\n</ul>\n<p>返回简化后得到的 <strong>规范路径</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>path = \"/home/\"\n<strong>输出：</strong>\"/home\"\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>path = \"/../\"\n<strong>输出：</strong>\"/\"\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>path = \"/home//foo/\"\n<strong>输出：</strong>\"/home/foo\"\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>path = \"/a/./b/../../c/\"\n<strong>输出：</strong>\"/c\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>\n\t<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-3\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">SimplifyPath</span>(<span class=\"params\"><span class=\"built_in\">string</span> path</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] names = path.Split(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">        IList&lt;<span class=\"built_in\">string</span>&gt; stack = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"built_in\">string</span> name <span class=\"keyword\">in</span> names) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;..&quot;</span>.Equals(name)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stack.Count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    stack.RemoveAt(stack.Count - <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (name.Length &gt; <span class=\"number\">0</span> &amp;&amp; !<span class=\"string\">&quot;.&quot;</span>.Equals(name)) &#123;</span><br><span class=\"line\">                stack.Add(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder ans = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stack.Count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.Append(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">foreach</span> (<span class=\"built_in\">string</span> name <span class=\"keyword\">in</span> stack) &#123;</span><br><span class=\"line\">                ans.Append(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">                ans.Append(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1078-Bigram-分词\"><a href=\"https://leetcode-cn.com/problems/occurrences-after-bigram/\">1078. Bigram 分词</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-4\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出第一个词&nbsp;<code>first</code> 和第二个词&nbsp;<code>second</code>，考虑在某些文本&nbsp;<code>text</code>&nbsp;中可能以 <code>\"first second third\"</code> 形式出现的情况，其中&nbsp;<code>second</code>&nbsp;紧随&nbsp;<code>first</code>&nbsp;出现，<code>third</code>&nbsp;紧随&nbsp;<code>second</code>&nbsp;出现。</p>\n<p>对于每种这样的情况，将第三个词 \"<code>third</code>\" 添加到答案中，并返回答案。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n<strong>输出：</strong>[\"girl\",\"student\"]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>text = \"we will we will rock you\", first = \"we\", second = \"will\"\n<strong>输出：</strong>[\"we\",\"rock\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;由小写英文字母和空格组成</li>\n\t<li><code>text</code> 中的所有单词之间都由 <strong>单个空格字符</strong> 分隔</li>\n\t<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>\n\t<li><code>first</code> 和&nbsp;<code>second</code>&nbsp;由小写英文字母组成</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-4\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span>[] <span class=\"title\">FindOcurrences</span>(<span class=\"params\"><span class=\"built_in\">string</span> text, <span class=\"built_in\">string</span> first, <span class=\"built_in\">string</span> second</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] words = text.Split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        IList&lt;<span class=\"built_in\">string</span>&gt; list = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">2</span>; i &lt; words.Length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (words[i - <span class=\"number\">2</span>].Equals(first) &amp;&amp; words[i - <span class=\"number\">1</span>].Equals(second)) &#123;</span><br><span class=\"line\">                list.Add(words[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> size = list.Count;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] ret = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>[size];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            ret[i] = list[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"1576-替换所有的问号\"><a href=\"https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/\">1576. 替换所有的问号</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-5\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个仅包含小写英文字母和 <code>'?'</code> 字符的字符串 <code>s</code>，请你将所有的 <code>'?'</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>\n<p>注意：你 <strong>不能</strong> 修改非 <code>'?'</code> 字符。</p>\n<p>题目测试用例保证 <strong>除</strong> <code>'?'</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>\n<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"?zs\"\n<strong>输出：</strong>\"azs\"\n<strong>解释：</strong>该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"ubv?w\"\n<strong>输出：</strong>\"ubvaw\"\n<strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>s = \"j?qg??b\"\n<strong>输出：</strong>\"jaqgacb\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>s = \"??yw?ipkj?\"\n<strong>输出：</strong>\"acywaipkja\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 100</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母和 <code>'?'</code> 字符</p>\n\t</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-5\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ModifyString</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = s.Length;</span><br><span class=\"line\">        <span class=\"built_in\">char</span>[] arr = s.ToCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] == <span class=\"string\">&#x27;?&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">char</span> ch = <span class=\"string\">&#x27;a&#x27;</span>; ch &lt;= <span class=\"string\">&#x27;c&#x27;</span>; ++ch) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((i &gt; <span class=\"number\">0</span> &amp;&amp; arr[i - <span class=\"number\">1</span>] == ch) || (i &lt; n - <span class=\"number\">1</span> &amp;&amp; arr[i + <span class=\"number\">1</span>] == ch)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    arr[i] = ch;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"数学\">数学</h1>\n<h2 id=\"390-消除游戏\"><a href=\"https://leetcode-cn.com/problems/elimination-game/\">390. 消除游戏</a></h2>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>数学</code></p>\n<hr>\n<h3 id=\"Description-6\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p>\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li>\n\t<li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li>\n\t<li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li>\n</ul>\n<p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 9\n<strong>输出：</strong>6\n<strong>解释：</strong>\narr = [<strong><em>1</em></strong>, 2, <em><strong>3</strong></em>, 4, <em><strong>5</strong></em>, 6, <em><strong>7</strong></em>, 8, <em><strong>9</strong></em>]\narr = [2, <em><strong>4</strong></em>, 6, <em><strong>8</strong></em>]\narr = [<em><strong>2</strong></em>, 6]\narr = [6]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n</div>\n</div>\n</section>\n<h3 id=\"My-Solution-6\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">LastRemaining</span>(<span class=\"params\"><span class=\"built_in\">int</span> n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>, cnt = n, step = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                a1 = a1 + step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                a1 = (cnt % <span class=\"number\">2</span> == <span class=\"number\">0</span>) ? a1 : a1 + step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            cnt = cnt &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            step = step &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1185-一周中的第几天\"><a href=\"https://leetcode-cn.com/problems/day-of-the-week/\">1185. 一周中的第几天</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数学</code></p>\n<hr>\n<h3 id=\"Description-7\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>\n<p>输入为三个整数：<code>day</code>、<code>month</code> 和&nbsp;<code>year</code>，分别表示日、月、年。</p>\n<p>您返回的结果必须是这几个值中的一个&nbsp;<code>&#123;\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;</code>。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>day = 31, month = 8, year = 2019\n<strong>输出：</strong>\"Saturday\"\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>day = 18, month = 7, year = 1999\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>day = 15, month = 8, year = 1993\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>给出的日期一定是在&nbsp;<code>1971</code> 到&nbsp;<code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-7\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">DayOfTheWeek</span>(<span class=\"params\"><span class=\"built_in\">int</span> day, <span class=\"built_in\">int</span> month, <span class=\"built_in\">int</span> year</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] week = &#123;<span class=\"string\">&quot;Monday&quot;</span>, <span class=\"string\">&quot;Tuesday&quot;</span>, <span class=\"string\">&quot;Wednesday&quot;</span>, <span class=\"string\">&quot;Thursday&quot;</span>, <span class=\"string\">&quot;Friday&quot;</span>, <span class=\"string\">&quot;Saturday&quot;</span>, </span><br><span class=\"line\"><span class=\"string\">&quot;Sunday&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] monthDays = &#123;<span class=\"number\">31</span>, <span class=\"number\">28</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">1971</span>; i &lt; year; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">bool</span> isLeap = (i % <span class=\"number\">4</span> == <span class=\"number\">0</span> &amp;&amp; i % <span class=\"number\">100</span> != <span class=\"number\">0</span>) || i % <span class=\"number\">400</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">            ans += isLeap ? <span class=\"number\">366</span> : <span class=\"number\">365</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; month - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans += monthDays[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span> &amp;&amp; ((year % <span class=\"number\">4</span> == <span class=\"number\">0</span> &amp;&amp; year % <span class=\"number\">100</span> != <span class=\"number\">0</span>) || year % <span class=\"number\">400</span> == <span class=\"number\">0</span>)) ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += day;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> week[ans % <span class=\"number\">7</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"我也不知道是什么鬼题型\">我也不知道是什么鬼题型</h1>\n<h2 id=\"1995-统计特殊四元组\"><a href=\"https://leetcode-cn.com/problems/count-special-quadruplets/\">1995. 统计特殊四元组</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>枚举</code></p>\n<hr>\n<h3 id=\"Description-8\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p>\n<ul>\n\t<li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li>\n\t<li><code>a &lt; b &lt; c &lt; d</code></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [1,2,3,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [3,3,6,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>[3,3,6,4,5] 中不存在满足要求的四元组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [1,1,1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足要求的 4 个四元组如下：\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n</section>\n<h3 id=\"My-Solution-8\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountQuadruplets</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;apublic <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountQuadruplets</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = nums.Length;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; cnt = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> c = n - <span class=\"number\">2</span>; c &gt;= <span class=\"number\">2</span>; --c) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cnt.ContainsKey(nums[c + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                cnt.Add(nums[c + <span class=\"number\">1</span>], <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++cnt[nums[c + <span class=\"number\">1</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> a = <span class=\"number\">0</span>; a &lt; c; ++a) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> b = a + <span class=\"number\">1</span>; b &lt; c; ++b) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">int</span> sum = nums[a] + nums[b] + nums[c];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cnt.ContainsKey(sum)) &#123;</span><br><span class=\"line\">                        ans += cnt[sum];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"模拟\">模拟</h1>\n<h2 id=\"2022-将一维数组转变成二维数组\"><a href=\"https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/\">2022. 将一维数组转变成二维数组</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>矩阵</code> <code>模拟</code></p>\n<hr>\n<h3 id=\"Description-9\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的一维整数数组&nbsp;<code>original</code>&nbsp;和两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;&nbsp;<code>n</code>&nbsp;。你需要使用&nbsp;<code>original</code>&nbsp;中&nbsp;<strong>所有</strong>&nbsp;元素创建一个&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的二维数组。</p>\n<p><code>original</code>&nbsp;中下标从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code>&nbsp;到 <code>2 * n - 1</code>&nbsp;（都 <strong>包含</strong>&nbsp;）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个<em>&nbsp;</em><code>m x n</code>&nbsp;的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 500px; height: 174px;\" src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\">\n<pre><b>输入：</b>original = [1,2,3,4], m = 2, n = 2\n<b>输出：</b>[[1,2],[3,4]]\n<strong>解释：\n</strong>构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><b>输入：</b>original = [1,2,3], m = 1, n = 3\n<b>输出：</b>[[1,2,3]]\n<b>解释：</b>\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><b>输入：</b>original = [1,2], m = 1, n = 1\n<b>输出：</b>[]\n<strong>解释：\n</strong>original 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><b>输入：</b>original = [3], m = 1, n = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= original.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= original[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n</section>\n<h3 id=\"My-Solution-9\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[][] Construct2DArray(<span class=\"built_in\">int</span>[] original, <span class=\"built_in\">int</span> m, <span class=\"built_in\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (original.Length != m * n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">0</span>][];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[][] ans = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[m][];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            ans[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; original.Length; i += n) &#123;</span><br><span class=\"line\">            Array.Copy(original, i, ans[i / n], <span class=\"number\">0</span>, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/qvfB7Vk1hZiAJ3G.jpg","excerpt":"","more":"<h1 id=\"搜索\">搜索</h1>\n<h2 id=\"1609-奇偶树\"><a href=\"https://leetcode-cn.com/problems/even-odd-tree/\">1609. 奇偶树</a></h2>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>树</code> <code>广度优先搜索</code> <code>二叉树</code></p>\n<hr>\n<h3 id=\"Description\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<p><strong><img style=\"height: 229px; width: 362px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n<p><strong>示例 2：</strong></p>\n<p><strong><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" alt=\"\"></strong></p>\n<pre><strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n<p><strong>示例 3：</strong></p>\n<p><img style=\"height: 167px; width: 363px;\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" alt=\"\"></p>\n<pre><strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n</section>\n<h3 id=\"My-Solution\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsEvenOddTree</span>(<span class=\"params\">TreeNode root</span>)</span> &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.Enqueue(root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> layer = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(queue.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> size = queue.Count;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> prev = layer % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? <span class=\"built_in\">int</span>.MinValue : <span class=\"built_in\">int</span>.MaxValue;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode node = queue.Dequeue();</span><br><span class=\"line\">                <span class=\"built_in\">int</span> <span class=\"keyword\">value</span> = node.val;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(layer % <span class=\"number\">2</span> == <span class=\"keyword\">value</span> % <span class=\"number\">2</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((layer % <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">value</span> &lt;= prev) || (layer % <span class=\"number\">2</span> == <span class=\"number\">1</span> &amp;&amp; <span class=\"keyword\">value</span> &gt;= prev))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                prev = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.left != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    queue.Enqueue(node.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.right != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    queue.Enqueue(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            layer++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"字符串\">字符串</h1>\n<h2 id=\"1629-按键持续时间最长的键\"><a href=\"https://leetcode-cn.com/problems/slowest-key/\">1629. 按键持续时间最长的键</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-2\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n<p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-2\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">char</span> <span class=\"title\">SlowestKey</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] releaseTimes, <span class=\"built_in\">string</span> keysPressed</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = releaseTimes.Length;</span><br><span class=\"line\">        <span class=\"built_in\">char</span> ans = keysPressed[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span> maxTime = releaseTimes[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">char</span> key = keysPressed[i];</span><br><span class=\"line\">            <span class=\"built_in\">int</span> time = releaseTimes[i] - releaseTimes[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; maxTime || (time == maxTime &amp;&amp; key &gt; ans)) &#123;</span><br><span class=\"line\">                ans = key;</span><br><span class=\"line\">                maxTime = time;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"71-简化路径\"><a href=\"https://leetcode-cn.com/problems/simplify-path/\">71. 简化路径</a></h2>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>栈</code> <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-3\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的&nbsp;Unix 风格 <strong>绝对路径 </strong>（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>\n<p class=\"MachineTrans-lang-zh-CN\">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>）&nbsp;表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>\n<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>\n<ul>\n\t<li>始终以斜杠 <code>'/'</code> 开头。</li>\n\t<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>\n\t<li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>'/'</code> 结尾。</li>\n\t<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>\n</ul>\n<p>返回简化后得到的 <strong>规范路径</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>path = \"/home/\"\n<strong>输出：</strong>\"/home\"\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>path = \"/../\"\n<strong>输出：</strong>\"/\"\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>path = \"/home//foo/\"\n<strong>输出：</strong>\"/home/foo\"\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>path = \"/a/./b/../../c/\"\n<strong>输出：</strong>\"/c\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>\n\t<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-3\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">SimplifyPath</span>(<span class=\"params\"><span class=\"built_in\">string</span> path</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] names = path.Split(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">        IList&lt;<span class=\"built_in\">string</span>&gt; stack = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"built_in\">string</span> name <span class=\"keyword\">in</span> names) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;..&quot;</span>.Equals(name)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stack.Count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    stack.RemoveAt(stack.Count - <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (name.Length &gt; <span class=\"number\">0</span> &amp;&amp; !<span class=\"string\">&quot;.&quot;</span>.Equals(name)) &#123;</span><br><span class=\"line\">                stack.Add(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder ans = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stack.Count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.Append(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">foreach</span> (<span class=\"built_in\">string</span> name <span class=\"keyword\">in</span> stack) &#123;</span><br><span class=\"line\">                ans.Append(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">                ans.Append(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1078-Bigram-分词\"><a href=\"https://leetcode-cn.com/problems/occurrences-after-bigram/\">1078. Bigram 分词</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-4\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出第一个词&nbsp;<code>first</code> 和第二个词&nbsp;<code>second</code>，考虑在某些文本&nbsp;<code>text</code>&nbsp;中可能以 <code>\"first second third\"</code> 形式出现的情况，其中&nbsp;<code>second</code>&nbsp;紧随&nbsp;<code>first</code>&nbsp;出现，<code>third</code>&nbsp;紧随&nbsp;<code>second</code>&nbsp;出现。</p>\n<p>对于每种这样的情况，将第三个词 \"<code>third</code>\" 添加到答案中，并返回答案。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n<strong>输出：</strong>[\"girl\",\"student\"]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>text = \"we will we will rock you\", first = \"we\", second = \"will\"\n<strong>输出：</strong>[\"we\",\"rock\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;由小写英文字母和空格组成</li>\n\t<li><code>text</code> 中的所有单词之间都由 <strong>单个空格字符</strong> 分隔</li>\n\t<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>\n\t<li><code>first</code> 和&nbsp;<code>second</code>&nbsp;由小写英文字母组成</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-4\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span>[] <span class=\"title\">FindOcurrences</span>(<span class=\"params\"><span class=\"built_in\">string</span> text, <span class=\"built_in\">string</span> first, <span class=\"built_in\">string</span> second</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] words = text.Split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        IList&lt;<span class=\"built_in\">string</span>&gt; list = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">2</span>; i &lt; words.Length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (words[i - <span class=\"number\">2</span>].Equals(first) &amp;&amp; words[i - <span class=\"number\">1</span>].Equals(second)) &#123;</span><br><span class=\"line\">                list.Add(words[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> size = list.Count;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] ret = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>[size];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            ret[i] = list[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"1576-替换所有的问号\"><a href=\"https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/\">1576. 替换所有的问号</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>字符串</code></p>\n<hr>\n<h3 id=\"Description-5\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个仅包含小写英文字母和 <code>'?'</code> 字符的字符串 <code>s</code>，请你将所有的 <code>'?'</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>\n<p>注意：你 <strong>不能</strong> 修改非 <code>'?'</code> 字符。</p>\n<p>题目测试用例保证 <strong>除</strong> <code>'?'</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>\n<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"?zs\"\n<strong>输出：</strong>\"azs\"\n<strong>解释：</strong>该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"ubv?w\"\n<strong>输出：</strong>\"ubvaw\"\n<strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>s = \"j?qg??b\"\n<strong>输出：</strong>\"jaqgacb\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>s = \"??yw?ipkj?\"\n<strong>输出：</strong>\"acywaipkja\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 100</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母和 <code>'?'</code> 字符</p>\n\t</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-5\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ModifyString</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = s.Length;</span><br><span class=\"line\">        <span class=\"built_in\">char</span>[] arr = s.ToCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] == <span class=\"string\">&#x27;?&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">char</span> ch = <span class=\"string\">&#x27;a&#x27;</span>; ch &lt;= <span class=\"string\">&#x27;c&#x27;</span>; ++ch) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((i &gt; <span class=\"number\">0</span> &amp;&amp; arr[i - <span class=\"number\">1</span>] == ch) || (i &lt; n - <span class=\"number\">1</span> &amp;&amp; arr[i + <span class=\"number\">1</span>] == ch)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    arr[i] = ch;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"数学\">数学</h1>\n<h2 id=\"390-消除游戏\"><a href=\"https://leetcode-cn.com/problems/elimination-game/\">390. 消除游戏</a></h2>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>数学</code></p>\n<hr>\n<h3 id=\"Description-6\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p>\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li>\n\t<li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li>\n\t<li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li>\n</ul>\n<p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 9\n<strong>输出：</strong>6\n<strong>解释：</strong>\narr = [<strong><em>1</em></strong>, 2, <em><strong>3</strong></em>, 4, <em><strong>5</strong></em>, 6, <em><strong>7</strong></em>, 8, <em><strong>9</strong></em>]\narr = [2, <em><strong>4</strong></em>, 6, <em><strong>8</strong></em>]\narr = [<em><strong>2</strong></em>, 6]\narr = [6]\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n</div>\n</div>\n</section>\n<h3 id=\"My-Solution-6\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">LastRemaining</span>(<span class=\"params\"><span class=\"built_in\">int</span> n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>, cnt = n, step = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                a1 = a1 + step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                a1 = (cnt % <span class=\"number\">2</span> == <span class=\"number\">0</span>) ? a1 : a1 + step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            cnt = cnt &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            step = step &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1185-一周中的第几天\"><a href=\"https://leetcode-cn.com/problems/day-of-the-week/\">1185. 一周中的第几天</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数学</code></p>\n<hr>\n<h3 id=\"Description-7\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>\n<p>输入为三个整数：<code>day</code>、<code>month</code> 和&nbsp;<code>year</code>，分别表示日、月、年。</p>\n<p>您返回的结果必须是这几个值中的一个&nbsp;<code>&#123;\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;</code>。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>day = 31, month = 8, year = 2019\n<strong>输出：</strong>\"Saturday\"\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>day = 18, month = 7, year = 1999\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>day = 15, month = 8, year = 1993\n<strong>输出：</strong>\"Sunday\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>给出的日期一定是在&nbsp;<code>1971</code> 到&nbsp;<code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n</section>\n<h3 id=\"My-Solution-7\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">DayOfTheWeek</span>(<span class=\"params\"><span class=\"built_in\">int</span> day, <span class=\"built_in\">int</span> month, <span class=\"built_in\">int</span> year</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] week = &#123;<span class=\"string\">&quot;Monday&quot;</span>, <span class=\"string\">&quot;Tuesday&quot;</span>, <span class=\"string\">&quot;Wednesday&quot;</span>, <span class=\"string\">&quot;Thursday&quot;</span>, <span class=\"string\">&quot;Friday&quot;</span>, <span class=\"string\">&quot;Saturday&quot;</span>, </span><br><span class=\"line\"><span class=\"string\">&quot;Sunday&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] monthDays = &#123;<span class=\"number\">31</span>, <span class=\"number\">28</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">1971</span>; i &lt; year; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">bool</span> isLeap = (i % <span class=\"number\">4</span> == <span class=\"number\">0</span> &amp;&amp; i % <span class=\"number\">100</span> != <span class=\"number\">0</span>) || i % <span class=\"number\">400</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">            ans += isLeap ? <span class=\"number\">366</span> : <span class=\"number\">365</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; month - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans += monthDays[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span> &amp;&amp; ((year % <span class=\"number\">4</span> == <span class=\"number\">0</span> &amp;&amp; year % <span class=\"number\">100</span> != <span class=\"number\">0</span>) || year % <span class=\"number\">400</span> == <span class=\"number\">0</span>)) ans += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += day;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> week[ans % <span class=\"number\">7</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"我也不知道是什么鬼题型\">我也不知道是什么鬼题型</h1>\n<h2 id=\"1995-统计特殊四元组\"><a href=\"https://leetcode-cn.com/problems/count-special-quadruplets/\">1995. 统计特殊四元组</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>枚举</code></p>\n<hr>\n<h3 id=\"Description-8\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p>\n<ul>\n\t<li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li>\n\t<li><code>a &lt; b &lt; c &lt; d</code></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [1,2,3,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [3,3,6,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>[3,3,6,4,5] 中不存在满足要求的四元组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [1,1,1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足要求的 4 个四元组如下：\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n</section>\n<h3 id=\"My-Solution-8\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountQuadruplets</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;apublic <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountQuadruplets</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = nums.Length;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; cnt = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> c = n - <span class=\"number\">2</span>; c &gt;= <span class=\"number\">2</span>; --c) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cnt.ContainsKey(nums[c + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                cnt.Add(nums[c + <span class=\"number\">1</span>], <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++cnt[nums[c + <span class=\"number\">1</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> a = <span class=\"number\">0</span>; a &lt; c; ++a) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> b = a + <span class=\"number\">1</span>; b &lt; c; ++b) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">int</span> sum = nums[a] + nums[b] + nums[c];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cnt.ContainsKey(sum)) &#123;</span><br><span class=\"line\">                        ans += cnt[sum];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"模拟\">模拟</h1>\n<h2 id=\"2022-将一维数组转变成二维数组\"><a href=\"https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/\">2022. 将一维数组转变成二维数组</a></h2>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>矩阵</code> <code>模拟</code></p>\n<hr>\n<h3 id=\"Description-9\">Description</h3>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的一维整数数组&nbsp;<code>original</code>&nbsp;和两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;&nbsp;<code>n</code>&nbsp;。你需要使用&nbsp;<code>original</code>&nbsp;中&nbsp;<strong>所有</strong>&nbsp;元素创建一个&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的二维数组。</p>\n<p><code>original</code>&nbsp;中下标从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code>&nbsp;到 <code>2 * n - 1</code>&nbsp;（都 <strong>包含</strong>&nbsp;）的元素构成二维数组的第二行，依此类推。</p>\n<p>请你根据上述过程返回一个<em>&nbsp;</em><code>m x n</code>&nbsp;的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 500px; height: 174px;\" src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\">\n<pre><b>输入：</b>original = [1,2,3,4], m = 2, n = 2\n<b>输出：</b>[[1,2],[3,4]]\n<strong>解释：\n</strong>构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><b>输入：</b>original = [1,2,3], m = 1, n = 3\n<b>输出：</b>[[1,2,3]]\n<b>解释：</b>\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><b>输入：</b>original = [1,2], m = 1, n = 1\n<b>输出：</b>[]\n<strong>解释：\n</strong>original 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><b>输入：</b>original = [3], m = 1, n = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= original.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= original[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n</section>\n<h3 id=\"My-Solution-9\">My Solution</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[][] Construct2DArray(<span class=\"built_in\">int</span>[] original, <span class=\"built_in\">int</span> m, <span class=\"built_in\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (original.Length != m * n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">0</span>][];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[][] ans = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[m][];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            ans[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; original.Length; i += n) &#123;</span><br><span class=\"line\">            Array.Copy(original, i, ans[i / n], <span class=\"number\">0</span>, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Lua设计与实现读书笔记","date":"2022-05-02T12:48:59.000Z","_content":"\n# 简介\n\nlua设计与实现的摸鱼笔记。主要是为了记录那些我觉得比较重要的东西。\n\n本书的实现由为Lua5.1，后续可能会存在区别。\n\n> 比如说Lua5.1的gc方式是三色标记，而后续是引用。\n\n入门的话我推荐《Lua程序设计》搭配[简介 · GitBook (shenjun-coder.github.io)](https://shenjun-coder.github.io/LuaBook/)进行学习。\n\n同时后续也可以看一下[云风的 BLOG (codingnow.com)](https://blog.codingnow.com/)。\n\n# 基础数据类型\n\n## 字符串\n\n### 性能优化\n\n因字符串拼接会产生新的字符串，所以会对性能上有所影响。\n\n比如说：\n\n```lua\na = os.clock()\nlocal s = ''\nfor i = 1, 300000 do\n    s = s .. 'a'\nend\nb = os.clock()\nprint(b - a)   -- 2.301\n```\n\n这段代码使用字符串拼接来生成新的字符串。\n\n```lua\na = os.clock()\nlocal s = ''\nlocal t = {}\nfor i = 1, 300000 do\n    t[#t + 1] = 'a'\nend\ns = table.concat(t, '')\nb = os.clock()\nprint(b - a) --0.019\n```\n\n这段代码使用table来模拟字符串，避免使用拼接，很明显性能得到了很大的提升。\n\n## 表\n\n### 操作算法\n\n#### 查找\n\n查找的伪代码大概如下：\n\n1. 输入的key为正整数，并且它的值大于0并且小于等于数组大小，那么他会尝试在数组部分查找。\n2. 否则会尝试在散列表部分进行查找，首先会计算出该key具体的散列值，再根据散列值得到桶所在的位置，遍历该散列桶下所有的链表元素，直到找到该key为止。\n\n可以从上发现，即使是一个正整数的key，他也不一定会存储在数组部分，这完全取决于当前数组大小。\n\n比如说，下面代码便会发现只有1作为数组部分存储下来了，而100存储在散列表部分。\n\n```lua\nlocal t = {}\nt[1] = 0\nt[100] = 10\nfor i, v in ipairs(t) do\n    print(i)\nend\n```\n\n既然涉及到这种数据是如何进行存储的，那最佳的方案就是去看元素是如何增加的。\n\n#### 新增元素\n\n#### 取长度\n\n```lua\n--如果表存在数组部分：\n--    初始化i = 0,j = table的sizearray\n--    满足(j - i) > 1的条件下，循环：\n--        m = (j + i) / 2\n--        如果array[m - 1]为nil值: j = m   右边界收缩\n--        否则 i = m                      左边界收缩\n--    返回 i\n--否则进入散列表中进行查找，具体规则同上\n```\n\n可以看出，如果表中同时拥有数组和散列表的数据，那么会优先取数组部分的长度。\n\n# Lua 虚拟机\n\n## 指令格式\n\n[![OUn5UP.png](https://s1.ax1x.com/2022/05/11/OUn5UP.png)](https://imgtu.com/i/OUn5UP)\n\n可以看出Lua的指令是32位的，从低位到高位开始解析。\n\n首先，最低位是**OpCode**，称为操作数，接下来就是A，B，C参数。\n\n列出目前所有的指令。这个枚举可以直接从`lopcodes.h`从寻找。\n\n```c\ntypedef enum {\n/*----------------------------------------------------------------------\n  name\t\targs\tdescription\n------------------------------------------------------------------------*/\nOP_MOVE,/*\tA B\tR[A] := R[B]\t\t\t\t\t*/\nOP_LOADI,/*\tA sBx\tR[A] := sBx\t\t\t\t\t*/\nOP_LOADF,/*\tA sBx\tR[A] := (lua_Number)sBx\t\t\t\t*/\nOP_LOADK,/*\tA Bx\tR[A] := K[Bx]\t\t\t\t\t*/\nOP_LOADKX,/*\tA\tR[A] := K[extra arg]\t\t\t\t*/\nOP_LOADFALSE,/*\tA\tR[A] := false\t\t\t\t\t*/\nOP_LFALSESKIP,/*A\tR[A] := false; pc++\t(*)\t\t\t*/\nOP_LOADTRUE,/*\tA\tR[A] := true\t\t\t\t\t*/\nOP_LOADNIL,/*\tA B\tR[A], R[A+1], ..., R[A+B] := nil\t\t*/\nOP_GETUPVAL,/*\tA B\tR[A] := UpValue[B]\t\t\t\t*/\nOP_SETUPVAL,/*\tA B\tUpValue[B] := R[A]\t\t\t\t*/\n\nOP_GETTABUP,/*\tA B C\tR[A] := UpValue[B][K[C]:string]\t\t\t*/\nOP_GETTABLE,/*\tA B C\tR[A] := R[B][R[C]]\t\t\t\t*/\nOP_GETI,/*\tA B C\tR[A] := R[B][C]\t\t\t\t\t*/\nOP_GETFIELD,/*\tA B C\tR[A] := R[B][K[C]:string]\t\t\t*/\n\nOP_SETTABUP,/*\tA B C\tUpValue[A][K[B]:string] := RK(C)\t\t*/\nOP_SETTABLE,/*\tA B C\tR[A][R[B]] := RK(C)\t\t\t\t*/\nOP_SETI,/*\tA B C\tR[A][B] := RK(C)\t\t\t\t*/\nOP_SETFIELD,/*\tA B C\tR[A][K[B]:string] := RK(C)\t\t\t*/\n\nOP_NEWTABLE,/*\tA B C k\tR[A] := {}\t\t\t\t\t*/\n\nOP_SELF,/*\tA B C\tR[A+1] := R[B]; R[A] := R[B][RK(C):string]\t*/\n\nOP_ADDI,/*\tA B sC\tR[A] := R[B] + sC\t\t\t\t*/\n\nOP_ADDK,/*\tA B C\tR[A] := R[B] + K[C]:number\t\t\t*/\nOP_SUBK,/*\tA B C\tR[A] := R[B] - K[C]:number\t\t\t*/\nOP_MULK,/*\tA B C\tR[A] := R[B] * K[C]:number\t\t\t*/\nOP_MODK,/*\tA B C\tR[A] := R[B] % K[C]:number\t\t\t*/\nOP_POWK,/*\tA B C\tR[A] := R[B] ^ K[C]:number\t\t\t*/\nOP_DIVK,/*\tA B C\tR[A] := R[B] / K[C]:number\t\t\t*/\nOP_IDIVK,/*\tA B C\tR[A] := R[B] // K[C]:number\t\t\t*/\n\nOP_BANDK,/*\tA B C\tR[A] := R[B] & K[C]:integer\t\t\t*/\nOP_BORK,/*\tA B C\tR[A] := R[B] | K[C]:integer\t\t\t*/\nOP_BXORK,/*\tA B C\tR[A] := R[B] ~ K[C]:integer\t\t\t*/\n\nOP_SHRI,/*\tA B sC\tR[A] := R[B] >> sC\t\t\t\t*/\nOP_SHLI,/*\tA B sC\tR[A] := sC << R[B]\t\t\t\t*/\n\nOP_ADD,/*\tA B C\tR[A] := R[B] + R[C]\t\t\t\t*/\nOP_SUB,/*\tA B C\tR[A] := R[B] - R[C]\t\t\t\t*/\nOP_MUL,/*\tA B C\tR[A] := R[B] * R[C]\t\t\t\t*/\nOP_MOD,/*\tA B C\tR[A] := R[B] % R[C]\t\t\t\t*/\nOP_POW,/*\tA B C\tR[A] := R[B] ^ R[C]\t\t\t\t*/\nOP_DIV,/*\tA B C\tR[A] := R[B] / R[C]\t\t\t\t*/\nOP_IDIV,/*\tA B C\tR[A] := R[B] // R[C]\t\t\t\t*/\n\nOP_BAND,/*\tA B C\tR[A] := R[B] & R[C]\t\t\t\t*/\nOP_BOR,/*\tA B C\tR[A] := R[B] | R[C]\t\t\t\t*/\nOP_BXOR,/*\tA B C\tR[A] := R[B] ~ R[C]\t\t\t\t*/\nOP_SHL,/*\tA B C\tR[A] := R[B] << R[C]\t\t\t\t*/\nOP_SHR,/*\tA B C\tR[A] := R[B] >> R[C]\t\t\t\t*/\n\nOP_MMBIN,/*\tA B C\tcall C metamethod over R[A] and R[B]\t(*)\t*/\nOP_MMBINI,/*\tA sB C k\tcall C metamethod over R[A] and sB\t*/\nOP_MMBINK,/*\tA B C k\t\tcall C metamethod over R[A] and K[B]\t*/\n\nOP_UNM,/*\tA B\tR[A] := -R[B]\t\t\t\t\t*/\nOP_BNOT,/*\tA B\tR[A] := ~R[B]\t\t\t\t\t*/\nOP_NOT,/*\tA B\tR[A] := not R[B]\t\t\t\t*/\nOP_LEN,/*\tA B\tR[A] := #R[B] (length operator)\t\t\t*/\n\nOP_CONCAT,/*\tA B\tR[A] := R[A].. ... ..R[A + B - 1]\t\t*/\n\nOP_CLOSE,/*\tA\tclose all upvalues >= R[A]\t\t\t*/\nOP_TBC,/*\tA\tmark variable A \"to be closed\"\t\t\t*/\nOP_JMP,/*\tsJ\tpc += sJ\t\t\t\t\t*/\nOP_EQ,/*\tA B k\tif ((R[A] == R[B]) ~= k) then pc++\t\t*/\nOP_LT,/*\tA B k\tif ((R[A] <  R[B]) ~= k) then pc++\t\t*/\nOP_LE,/*\tA B k\tif ((R[A] <= R[B]) ~= k) then pc++\t\t*/\n\nOP_EQK,/*\tA B k\tif ((R[A] == K[B]) ~= k) then pc++\t\t*/\nOP_EQI,/*\tA sB k\tif ((R[A] == sB) ~= k) then pc++\t\t*/\nOP_LTI,/*\tA sB k\tif ((R[A] < sB) ~= k) then pc++\t\t\t*/\nOP_LEI,/*\tA sB k\tif ((R[A] <= sB) ~= k) then pc++\t\t*/\nOP_GTI,/*\tA sB k\tif ((R[A] > sB) ~= k) then pc++\t\t\t*/\nOP_GEI,/*\tA sB k\tif ((R[A] >= sB) ~= k) then pc++\t\t*/\n\nOP_TEST,/*\tA k\tif (not R[A] == k) then pc++\t\t\t*/\nOP_TESTSET,/*\tA B k\tif (not R[B] == k) then pc++ else R[A] := R[B] (*) */\n\nOP_CALL,/*\tA B C\tR[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */\nOP_TAILCALL,/*\tA B C k\treturn R[A](R[A+1], ... ,R[A+B-1])\t\t*/\n\nOP_RETURN,/*\tA B C k\treturn R[A], ... ,R[A+B-2]\t(see note)\t*/\nOP_RETURN0,/*\t\treturn\t\t\t\t\t\t*/\nOP_RETURN1,/*\tA\treturn R[A]\t\t\t\t\t*/\n\nOP_FORLOOP,/*\tA Bx\tupdate counters; if loop continues then pc-=Bx; */\nOP_FORPREP,/*\tA Bx\t<check values and prepare counters>;\n                        if not to run then pc+=Bx+1;\t\t\t*/\n\nOP_TFORPREP,/*\tA Bx\tcreate upvalue for R[A + 3]; pc+=Bx\t\t*/\nOP_TFORCALL,/*\tA C\tR[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);\t*/\nOP_TFORLOOP,/*\tA Bx\tif R[A+2] ~= nil then { R[A]=R[A+2]; pc -= Bx }\t*/\n\nOP_SETLIST,/*\tA B C k\tR[A][C+i] := R[A+i], 1 <= i <= B\t\t*/\n\nOP_CLOSURE,/*\tA Bx\tR[A] := closure(KPROTO[Bx])\t\t\t*/\n\nOP_VARARG,/*\tA C\tR[A], R[A+1], ..., R[A+C-2] = vararg\t\t*/\n\nOP_VARARGPREP,/*A\t(adjust vararg parameters)\t\t\t*/\n\nOP_EXTRAARG/*\tAx\textra (larger) argument for previous opcode\t*/\n} OpCode;\n```\n\n再这些指令中，有不同的取值方式，具体可以看下图。\n\n[![OUu0MQ.png](https://s1.ax1x.com/2022/05/11/OUu0MQ.png)](https://imgtu.com/i/OUu0MQ)\n\n# 附录\n","source":"_posts/Lua设计与实现读书笔记.md","raw":"---\ntitle: Lua设计与实现读书笔记\ndate: 2022-05-02 20:48:59\ntags: Lua\ncategories: 语言基础\n---\n\n# 简介\n\nlua设计与实现的摸鱼笔记。主要是为了记录那些我觉得比较重要的东西。\n\n本书的实现由为Lua5.1，后续可能会存在区别。\n\n> 比如说Lua5.1的gc方式是三色标记，而后续是引用。\n\n入门的话我推荐《Lua程序设计》搭配[简介 · GitBook (shenjun-coder.github.io)](https://shenjun-coder.github.io/LuaBook/)进行学习。\n\n同时后续也可以看一下[云风的 BLOG (codingnow.com)](https://blog.codingnow.com/)。\n\n# 基础数据类型\n\n## 字符串\n\n### 性能优化\n\n因字符串拼接会产生新的字符串，所以会对性能上有所影响。\n\n比如说：\n\n```lua\na = os.clock()\nlocal s = ''\nfor i = 1, 300000 do\n    s = s .. 'a'\nend\nb = os.clock()\nprint(b - a)   -- 2.301\n```\n\n这段代码使用字符串拼接来生成新的字符串。\n\n```lua\na = os.clock()\nlocal s = ''\nlocal t = {}\nfor i = 1, 300000 do\n    t[#t + 1] = 'a'\nend\ns = table.concat(t, '')\nb = os.clock()\nprint(b - a) --0.019\n```\n\n这段代码使用table来模拟字符串，避免使用拼接，很明显性能得到了很大的提升。\n\n## 表\n\n### 操作算法\n\n#### 查找\n\n查找的伪代码大概如下：\n\n1. 输入的key为正整数，并且它的值大于0并且小于等于数组大小，那么他会尝试在数组部分查找。\n2. 否则会尝试在散列表部分进行查找，首先会计算出该key具体的散列值，再根据散列值得到桶所在的位置，遍历该散列桶下所有的链表元素，直到找到该key为止。\n\n可以从上发现，即使是一个正整数的key，他也不一定会存储在数组部分，这完全取决于当前数组大小。\n\n比如说，下面代码便会发现只有1作为数组部分存储下来了，而100存储在散列表部分。\n\n```lua\nlocal t = {}\nt[1] = 0\nt[100] = 10\nfor i, v in ipairs(t) do\n    print(i)\nend\n```\n\n既然涉及到这种数据是如何进行存储的，那最佳的方案就是去看元素是如何增加的。\n\n#### 新增元素\n\n#### 取长度\n\n```lua\n--如果表存在数组部分：\n--    初始化i = 0,j = table的sizearray\n--    满足(j - i) > 1的条件下，循环：\n--        m = (j + i) / 2\n--        如果array[m - 1]为nil值: j = m   右边界收缩\n--        否则 i = m                      左边界收缩\n--    返回 i\n--否则进入散列表中进行查找，具体规则同上\n```\n\n可以看出，如果表中同时拥有数组和散列表的数据，那么会优先取数组部分的长度。\n\n# Lua 虚拟机\n\n## 指令格式\n\n[![OUn5UP.png](https://s1.ax1x.com/2022/05/11/OUn5UP.png)](https://imgtu.com/i/OUn5UP)\n\n可以看出Lua的指令是32位的，从低位到高位开始解析。\n\n首先，最低位是**OpCode**，称为操作数，接下来就是A，B，C参数。\n\n列出目前所有的指令。这个枚举可以直接从`lopcodes.h`从寻找。\n\n```c\ntypedef enum {\n/*----------------------------------------------------------------------\n  name\t\targs\tdescription\n------------------------------------------------------------------------*/\nOP_MOVE,/*\tA B\tR[A] := R[B]\t\t\t\t\t*/\nOP_LOADI,/*\tA sBx\tR[A] := sBx\t\t\t\t\t*/\nOP_LOADF,/*\tA sBx\tR[A] := (lua_Number)sBx\t\t\t\t*/\nOP_LOADK,/*\tA Bx\tR[A] := K[Bx]\t\t\t\t\t*/\nOP_LOADKX,/*\tA\tR[A] := K[extra arg]\t\t\t\t*/\nOP_LOADFALSE,/*\tA\tR[A] := false\t\t\t\t\t*/\nOP_LFALSESKIP,/*A\tR[A] := false; pc++\t(*)\t\t\t*/\nOP_LOADTRUE,/*\tA\tR[A] := true\t\t\t\t\t*/\nOP_LOADNIL,/*\tA B\tR[A], R[A+1], ..., R[A+B] := nil\t\t*/\nOP_GETUPVAL,/*\tA B\tR[A] := UpValue[B]\t\t\t\t*/\nOP_SETUPVAL,/*\tA B\tUpValue[B] := R[A]\t\t\t\t*/\n\nOP_GETTABUP,/*\tA B C\tR[A] := UpValue[B][K[C]:string]\t\t\t*/\nOP_GETTABLE,/*\tA B C\tR[A] := R[B][R[C]]\t\t\t\t*/\nOP_GETI,/*\tA B C\tR[A] := R[B][C]\t\t\t\t\t*/\nOP_GETFIELD,/*\tA B C\tR[A] := R[B][K[C]:string]\t\t\t*/\n\nOP_SETTABUP,/*\tA B C\tUpValue[A][K[B]:string] := RK(C)\t\t*/\nOP_SETTABLE,/*\tA B C\tR[A][R[B]] := RK(C)\t\t\t\t*/\nOP_SETI,/*\tA B C\tR[A][B] := RK(C)\t\t\t\t*/\nOP_SETFIELD,/*\tA B C\tR[A][K[B]:string] := RK(C)\t\t\t*/\n\nOP_NEWTABLE,/*\tA B C k\tR[A] := {}\t\t\t\t\t*/\n\nOP_SELF,/*\tA B C\tR[A+1] := R[B]; R[A] := R[B][RK(C):string]\t*/\n\nOP_ADDI,/*\tA B sC\tR[A] := R[B] + sC\t\t\t\t*/\n\nOP_ADDK,/*\tA B C\tR[A] := R[B] + K[C]:number\t\t\t*/\nOP_SUBK,/*\tA B C\tR[A] := R[B] - K[C]:number\t\t\t*/\nOP_MULK,/*\tA B C\tR[A] := R[B] * K[C]:number\t\t\t*/\nOP_MODK,/*\tA B C\tR[A] := R[B] % K[C]:number\t\t\t*/\nOP_POWK,/*\tA B C\tR[A] := R[B] ^ K[C]:number\t\t\t*/\nOP_DIVK,/*\tA B C\tR[A] := R[B] / K[C]:number\t\t\t*/\nOP_IDIVK,/*\tA B C\tR[A] := R[B] // K[C]:number\t\t\t*/\n\nOP_BANDK,/*\tA B C\tR[A] := R[B] & K[C]:integer\t\t\t*/\nOP_BORK,/*\tA B C\tR[A] := R[B] | K[C]:integer\t\t\t*/\nOP_BXORK,/*\tA B C\tR[A] := R[B] ~ K[C]:integer\t\t\t*/\n\nOP_SHRI,/*\tA B sC\tR[A] := R[B] >> sC\t\t\t\t*/\nOP_SHLI,/*\tA B sC\tR[A] := sC << R[B]\t\t\t\t*/\n\nOP_ADD,/*\tA B C\tR[A] := R[B] + R[C]\t\t\t\t*/\nOP_SUB,/*\tA B C\tR[A] := R[B] - R[C]\t\t\t\t*/\nOP_MUL,/*\tA B C\tR[A] := R[B] * R[C]\t\t\t\t*/\nOP_MOD,/*\tA B C\tR[A] := R[B] % R[C]\t\t\t\t*/\nOP_POW,/*\tA B C\tR[A] := R[B] ^ R[C]\t\t\t\t*/\nOP_DIV,/*\tA B C\tR[A] := R[B] / R[C]\t\t\t\t*/\nOP_IDIV,/*\tA B C\tR[A] := R[B] // R[C]\t\t\t\t*/\n\nOP_BAND,/*\tA B C\tR[A] := R[B] & R[C]\t\t\t\t*/\nOP_BOR,/*\tA B C\tR[A] := R[B] | R[C]\t\t\t\t*/\nOP_BXOR,/*\tA B C\tR[A] := R[B] ~ R[C]\t\t\t\t*/\nOP_SHL,/*\tA B C\tR[A] := R[B] << R[C]\t\t\t\t*/\nOP_SHR,/*\tA B C\tR[A] := R[B] >> R[C]\t\t\t\t*/\n\nOP_MMBIN,/*\tA B C\tcall C metamethod over R[A] and R[B]\t(*)\t*/\nOP_MMBINI,/*\tA sB C k\tcall C metamethod over R[A] and sB\t*/\nOP_MMBINK,/*\tA B C k\t\tcall C metamethod over R[A] and K[B]\t*/\n\nOP_UNM,/*\tA B\tR[A] := -R[B]\t\t\t\t\t*/\nOP_BNOT,/*\tA B\tR[A] := ~R[B]\t\t\t\t\t*/\nOP_NOT,/*\tA B\tR[A] := not R[B]\t\t\t\t*/\nOP_LEN,/*\tA B\tR[A] := #R[B] (length operator)\t\t\t*/\n\nOP_CONCAT,/*\tA B\tR[A] := R[A].. ... ..R[A + B - 1]\t\t*/\n\nOP_CLOSE,/*\tA\tclose all upvalues >= R[A]\t\t\t*/\nOP_TBC,/*\tA\tmark variable A \"to be closed\"\t\t\t*/\nOP_JMP,/*\tsJ\tpc += sJ\t\t\t\t\t*/\nOP_EQ,/*\tA B k\tif ((R[A] == R[B]) ~= k) then pc++\t\t*/\nOP_LT,/*\tA B k\tif ((R[A] <  R[B]) ~= k) then pc++\t\t*/\nOP_LE,/*\tA B k\tif ((R[A] <= R[B]) ~= k) then pc++\t\t*/\n\nOP_EQK,/*\tA B k\tif ((R[A] == K[B]) ~= k) then pc++\t\t*/\nOP_EQI,/*\tA sB k\tif ((R[A] == sB) ~= k) then pc++\t\t*/\nOP_LTI,/*\tA sB k\tif ((R[A] < sB) ~= k) then pc++\t\t\t*/\nOP_LEI,/*\tA sB k\tif ((R[A] <= sB) ~= k) then pc++\t\t*/\nOP_GTI,/*\tA sB k\tif ((R[A] > sB) ~= k) then pc++\t\t\t*/\nOP_GEI,/*\tA sB k\tif ((R[A] >= sB) ~= k) then pc++\t\t*/\n\nOP_TEST,/*\tA k\tif (not R[A] == k) then pc++\t\t\t*/\nOP_TESTSET,/*\tA B k\tif (not R[B] == k) then pc++ else R[A] := R[B] (*) */\n\nOP_CALL,/*\tA B C\tR[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */\nOP_TAILCALL,/*\tA B C k\treturn R[A](R[A+1], ... ,R[A+B-1])\t\t*/\n\nOP_RETURN,/*\tA B C k\treturn R[A], ... ,R[A+B-2]\t(see note)\t*/\nOP_RETURN0,/*\t\treturn\t\t\t\t\t\t*/\nOP_RETURN1,/*\tA\treturn R[A]\t\t\t\t\t*/\n\nOP_FORLOOP,/*\tA Bx\tupdate counters; if loop continues then pc-=Bx; */\nOP_FORPREP,/*\tA Bx\t<check values and prepare counters>;\n                        if not to run then pc+=Bx+1;\t\t\t*/\n\nOP_TFORPREP,/*\tA Bx\tcreate upvalue for R[A + 3]; pc+=Bx\t\t*/\nOP_TFORCALL,/*\tA C\tR[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);\t*/\nOP_TFORLOOP,/*\tA Bx\tif R[A+2] ~= nil then { R[A]=R[A+2]; pc -= Bx }\t*/\n\nOP_SETLIST,/*\tA B C k\tR[A][C+i] := R[A+i], 1 <= i <= B\t\t*/\n\nOP_CLOSURE,/*\tA Bx\tR[A] := closure(KPROTO[Bx])\t\t\t*/\n\nOP_VARARG,/*\tA C\tR[A], R[A+1], ..., R[A+C-2] = vararg\t\t*/\n\nOP_VARARGPREP,/*A\t(adjust vararg parameters)\t\t\t*/\n\nOP_EXTRAARG/*\tAx\textra (larger) argument for previous opcode\t*/\n} OpCode;\n```\n\n再这些指令中，有不同的取值方式，具体可以看下图。\n\n[![OUu0MQ.png](https://s1.ax1x.com/2022/05/11/OUu0MQ.png)](https://imgtu.com/i/OUu0MQ)\n\n# 附录\n","slug":"Lua设计与实现读书笔记","published":1,"updated":"2022-05-21T19:06:34.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztq700092cupgmsa7yqm","content":"<h1 id=\"简介\">简介</h1>\n<p>lua设计与实现的摸鱼笔记。主要是为了记录那些我觉得比较重要的东西。</p>\n<p>本书的实现由为Lua5.1，后续可能会存在区别。</p>\n<blockquote>\n<p>比如说Lua5.1的gc方式是三色标记，而后续是引用。</p>\n</blockquote>\n<p>入门的话我推荐《Lua程序设计》搭配<a href=\"https://shenjun-coder.github.io/LuaBook/\">简介 · GitBook (shenjun-coder.github.io)</a>进行学习。</p>\n<p>同时后续也可以看一下<a href=\"https://blog.codingnow.com/\">云风的 BLOG (codingnow.com)</a>。</p>\n<h1 id=\"基础数据类型\">基础数据类型</h1>\n<h2 id=\"字符串\">字符串</h2>\n<h3 id=\"性能优化\">性能优化</h3>\n<p>因字符串拼接会产生新的字符串，所以会对性能上有所影响。</p>\n<p>比如说：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"keyword\">local</span> s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">300000</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    s = s .. <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">b = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b - a)   <span class=\"comment\">-- 2.301</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用字符串拼接来生成新的字符串。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"keyword\">local</span> s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> t = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">300000</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    t[#t + <span class=\"number\">1</span>] = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">s = <span class=\"built_in\">table</span>.<span class=\"built_in\">concat</span>(t, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">b = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b - a) <span class=\"comment\">--0.019</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用table来模拟字符串，避免使用拼接，很明显性能得到了很大的提升。</p>\n<h2 id=\"表\">表</h2>\n<h3 id=\"操作算法\">操作算法</h3>\n<h4 id=\"查找\">查找</h4>\n<p>查找的伪代码大概如下：</p>\n<ol>\n<li>输入的key为正整数，并且它的值大于0并且小于等于数组大小，那么他会尝试在数组部分查找。</li>\n<li>否则会尝试在散列表部分进行查找，首先会计算出该key具体的散列值，再根据散列值得到桶所在的位置，遍历该散列桶下所有的链表元素，直到找到该key为止。</li>\n</ol>\n<p>可以从上发现，即使是一个正整数的key，他也不一定会存储在数组部分，这完全取决于当前数组大小。</p>\n<p>比如说，下面代码便会发现只有1作为数组部分存储下来了，而100存储在散列表部分。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> t = &#123;&#125;</span><br><span class=\"line\">t[<span class=\"number\">1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">t[<span class=\"number\">100</span>] = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(t) <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>既然涉及到这种数据是如何进行存储的，那最佳的方案就是去看元素是如何增加的。</p>\n<h4 id=\"新增元素\">新增元素</h4>\n<h4 id=\"取长度\">取长度</h4>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--如果表存在数组部分：</span></span><br><span class=\"line\"><span class=\"comment\">--    初始化i = 0,j = table的sizearray</span></span><br><span class=\"line\"><span class=\"comment\">--    满足(j - i) &gt; 1的条件下，循环：</span></span><br><span class=\"line\"><span class=\"comment\">--        m = (j + i) / 2</span></span><br><span class=\"line\"><span class=\"comment\">--        如果array[m - 1]为nil值: j = m   右边界收缩</span></span><br><span class=\"line\"><span class=\"comment\">--        否则 i = m                      左边界收缩</span></span><br><span class=\"line\"><span class=\"comment\">--    返回 i</span></span><br><span class=\"line\"><span class=\"comment\">--否则进入散列表中进行查找，具体规则同上</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，如果表中同时拥有数组和散列表的数据，那么会优先取数组部分的长度。</p>\n<h1 id=\"Lua-虚拟机\">Lua 虚拟机</h1>\n<h2 id=\"指令格式\">指令格式</h2>\n<p><a href=\"https://imgtu.com/i/OUn5UP\"><img src=\"https://s1.ax1x.com/2022/05/11/OUn5UP.png\" alt=\"OUn5UP.png\"></a></p>\n<p>可以看出Lua的指令是32位的，从低位到高位开始解析。</p>\n<p>首先，最低位是<strong>OpCode</strong>，称为操作数，接下来就是A，B，C参数。</p>\n<p>列出目前所有的指令。这个枚举可以直接从<code>lopcodes.h</code>从寻找。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">  name\t\targs\tdescription</span></span><br><span class=\"line\"><span class=\"comment\">------------------------------------------------------------------------*/</span></span><br><span class=\"line\">OP_MOVE,<span class=\"comment\">/*\tA B\tR[A] := R[B]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADI,<span class=\"comment\">/*\tA sBx\tR[A] := sBx\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADF,<span class=\"comment\">/*\tA sBx\tR[A] := (lua_Number)sBx\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADK,<span class=\"comment\">/*\tA Bx\tR[A] := K[Bx]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADKX,<span class=\"comment\">/*\tA\tR[A] := K[extra arg]\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADFALSE,<span class=\"comment\">/*\tA\tR[A] := false\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LFALSESKIP,<span class=\"comment\">/*A\tR[A] := false; pc++\t(*)\t\t\t*/</span></span><br><span class=\"line\">OP_LOADTRUE,<span class=\"comment\">/*\tA\tR[A] := true\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADNIL,<span class=\"comment\">/*\tA B\tR[A], R[A+1], ..., R[A+B] := nil\t\t*/</span></span><br><span class=\"line\">OP_GETUPVAL,<span class=\"comment\">/*\tA B\tR[A] := UpValue[B]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SETUPVAL,<span class=\"comment\">/*\tA B\tUpValue[B] := R[A]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_GETTABUP,<span class=\"comment\">/*\tA B C\tR[A] := UpValue[B][K[C]:string]\t\t\t*/</span></span><br><span class=\"line\">OP_GETTABLE,<span class=\"comment\">/*\tA B C\tR[A] := R[B][R[C]]\t\t\t\t*/</span></span><br><span class=\"line\">OP_GETI,<span class=\"comment\">/*\tA B C\tR[A] := R[B][C]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_GETFIELD,<span class=\"comment\">/*\tA B C\tR[A] := R[B][K[C]:string]\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SETTABUP,<span class=\"comment\">/*\tA B C\tUpValue[A][K[B]:string] := RK(C)\t\t*/</span></span><br><span class=\"line\">OP_SETTABLE,<span class=\"comment\">/*\tA B C\tR[A][R[B]] := RK(C)\t\t\t\t*/</span></span><br><span class=\"line\">OP_SETI,<span class=\"comment\">/*\tA B C\tR[A][B] := RK(C)\t\t\t\t*/</span></span><br><span class=\"line\">OP_SETFIELD,<span class=\"comment\">/*\tA B C\tR[A][K[B]:string] := RK(C)\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_NEWTABLE,<span class=\"comment\">/*\tA B C k\tR[A] := &#123;&#125;\t\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SELF,<span class=\"comment\">/*\tA B C\tR[A+1] := R[B]; R[A] := R[B][RK(C):string]\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_ADDI,<span class=\"comment\">/*\tA B sC\tR[A] := R[B] + sC\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_ADDK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] + K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_SUBK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] - K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_MULK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] * K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_MODK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] % K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_POWK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ^ K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_DIVK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] / K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_IDIVK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] // K[C]:number\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_BANDK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &amp; K[C]:integer\t\t\t*/</span></span><br><span class=\"line\">OP_BORK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] | K[C]:integer\t\t\t*/</span></span><br><span class=\"line\">OP_BXORK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ~ K[C]:integer\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SHRI,<span class=\"comment\">/*\tA B sC\tR[A] := R[B] &gt;&gt; sC\t\t\t\t*/</span></span><br><span class=\"line\">OP_SHLI,<span class=\"comment\">/*\tA B sC\tR[A] := sC &lt;&lt; R[B]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_ADD,<span class=\"comment\">/*\tA B C\tR[A] := R[B] + R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SUB,<span class=\"comment\">/*\tA B C\tR[A] := R[B] - R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_MUL,<span class=\"comment\">/*\tA B C\tR[A] := R[B] * R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_MOD,<span class=\"comment\">/*\tA B C\tR[A] := R[B] % R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_POW,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ^ R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_DIV,<span class=\"comment\">/*\tA B C\tR[A] := R[B] / R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_IDIV,<span class=\"comment\">/*\tA B C\tR[A] := R[B] // R[C]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_BAND,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &amp; R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_BOR,<span class=\"comment\">/*\tA B C\tR[A] := R[B] | R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_BXOR,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ~ R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SHL,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &lt;&lt; R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SHR,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &gt;&gt; R[C]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_MMBIN,<span class=\"comment\">/*\tA B C\tcall C metamethod over R[A] and R[B]\t(*)\t*/</span></span><br><span class=\"line\">OP_MMBINI,<span class=\"comment\">/*\tA sB C k\tcall C metamethod over R[A] and sB\t*/</span></span><br><span class=\"line\">OP_MMBINK,<span class=\"comment\">/*\tA B C k\t\tcall C metamethod over R[A] and K[B]\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_UNM,<span class=\"comment\">/*\tA B\tR[A] := -R[B]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_BNOT,<span class=\"comment\">/*\tA B\tR[A] := ~R[B]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_NOT,<span class=\"comment\">/*\tA B\tR[A] := not R[B]\t\t\t\t*/</span></span><br><span class=\"line\">OP_LEN,<span class=\"comment\">/*\tA B\tR[A] := #R[B] (length operator)\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CONCAT,<span class=\"comment\">/*\tA B\tR[A] := R[A].. ... ..R[A + B - 1]\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CLOSE,<span class=\"comment\">/*\tA\tclose all upvalues &gt;= R[A]\t\t\t*/</span></span><br><span class=\"line\">OP_TBC,<span class=\"comment\">/*\tA\tmark variable A &quot;to be closed&quot;\t\t\t*/</span></span><br><span class=\"line\">OP_JMP,<span class=\"comment\">/*\tsJ\tpc += sJ\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_EQ,<span class=\"comment\">/*\tA B k\tif ((R[A] == R[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_LT,<span class=\"comment\">/*\tA B k\tif ((R[A] &lt;  R[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_LE,<span class=\"comment\">/*\tA B k\tif ((R[A] &lt;= R[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_EQK,<span class=\"comment\">/*\tA B k\tif ((R[A] == K[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_EQI,<span class=\"comment\">/*\tA sB k\tif ((R[A] == sB) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_LTI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &lt; sB) ~= k) then pc++\t\t\t*/</span></span><br><span class=\"line\">OP_LEI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &lt;= sB) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_GTI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &gt; sB) ~= k) then pc++\t\t\t*/</span></span><br><span class=\"line\">OP_GEI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &gt;= sB) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_TEST,<span class=\"comment\">/*\tA k\tif (not R[A] == k) then pc++\t\t\t*/</span></span><br><span class=\"line\">OP_TESTSET,<span class=\"comment\">/*\tA B k\tif (not R[B] == k) then pc++ else R[A] := R[B] (*) */</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CALL,<span class=\"comment\">/*\tA B C\tR[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */</span></span><br><span class=\"line\">OP_TAILCALL,<span class=\"comment\">/*\tA B C k\treturn R[A](R[A+1], ... ,R[A+B-1])\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_RETURN,<span class=\"comment\">/*\tA B C k\treturn R[A], ... ,R[A+B-2]\t(see note)\t*/</span></span><br><span class=\"line\">OP_RETURN0,<span class=\"comment\">/*\t\treturn\t\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_RETURN1,<span class=\"comment\">/*\tA\treturn R[A]\t\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_FORLOOP,<span class=\"comment\">/*\tA Bx\tupdate counters; if loop continues then pc-=Bx; */</span></span><br><span class=\"line\">OP_FORPREP,<span class=\"comment\">/*\tA Bx\t&lt;check values and prepare counters&gt;;</span></span><br><span class=\"line\"><span class=\"comment\">                        if not to run then pc+=Bx+1;\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_TFORPREP,<span class=\"comment\">/*\tA Bx\tcreate upvalue for R[A + 3]; pc+=Bx\t\t*/</span></span><br><span class=\"line\">OP_TFORCALL,<span class=\"comment\">/*\tA C\tR[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);\t*/</span></span><br><span class=\"line\">OP_TFORLOOP,<span class=\"comment\">/*\tA Bx\tif R[A+2] ~= nil then &#123; R[A]=R[A+2]; pc -= Bx &#125;\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SETLIST,<span class=\"comment\">/*\tA B C k\tR[A][C+i] := R[A+i], 1 &lt;= i &lt;= B\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CLOSURE,<span class=\"comment\">/*\tA Bx\tR[A] := closure(KPROTO[Bx])\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_VARARG,<span class=\"comment\">/*\tA C\tR[A], R[A+1], ..., R[A+C-2] = vararg\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_VARARGPREP,<span class=\"comment\">/*A\t(adjust vararg parameters)\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_EXTRAARG<span class=\"comment\">/*\tAx\textra (larger) argument for previous opcode\t*/</span></span><br><span class=\"line\">&#125; OpCode;</span><br></pre></td></tr></table></figure>\n<p>再这些指令中，有不同的取值方式，具体可以看下图。</p>\n<p><a href=\"https://imgtu.com/i/OUu0MQ\"><img src=\"https://s1.ax1x.com/2022/05/11/OUu0MQ.png\" alt=\"OUu0MQ.png\"></a></p>\n<h1 id=\"附录\">附录</h1>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://z3.ax1x.com/2021/11/20/Iq0ZTg.jpg","excerpt":"","more":"<h1 id=\"简介\">简介</h1>\n<p>lua设计与实现的摸鱼笔记。主要是为了记录那些我觉得比较重要的东西。</p>\n<p>本书的实现由为Lua5.1，后续可能会存在区别。</p>\n<blockquote>\n<p>比如说Lua5.1的gc方式是三色标记，而后续是引用。</p>\n</blockquote>\n<p>入门的话我推荐《Lua程序设计》搭配<a href=\"https://shenjun-coder.github.io/LuaBook/\">简介 · GitBook (shenjun-coder.github.io)</a>进行学习。</p>\n<p>同时后续也可以看一下<a href=\"https://blog.codingnow.com/\">云风的 BLOG (codingnow.com)</a>。</p>\n<h1 id=\"基础数据类型\">基础数据类型</h1>\n<h2 id=\"字符串\">字符串</h2>\n<h3 id=\"性能优化\">性能优化</h3>\n<p>因字符串拼接会产生新的字符串，所以会对性能上有所影响。</p>\n<p>比如说：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"keyword\">local</span> s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">300000</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    s = s .. <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">b = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b - a)   <span class=\"comment\">-- 2.301</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用字符串拼接来生成新的字符串。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"keyword\">local</span> s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> t = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">300000</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    t[#t + <span class=\"number\">1</span>] = <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">s = <span class=\"built_in\">table</span>.<span class=\"built_in\">concat</span>(t, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">b = <span class=\"built_in\">os</span>.<span class=\"built_in\">clock</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b - a) <span class=\"comment\">--0.019</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用table来模拟字符串，避免使用拼接，很明显性能得到了很大的提升。</p>\n<h2 id=\"表\">表</h2>\n<h3 id=\"操作算法\">操作算法</h3>\n<h4 id=\"查找\">查找</h4>\n<p>查找的伪代码大概如下：</p>\n<ol>\n<li>输入的key为正整数，并且它的值大于0并且小于等于数组大小，那么他会尝试在数组部分查找。</li>\n<li>否则会尝试在散列表部分进行查找，首先会计算出该key具体的散列值，再根据散列值得到桶所在的位置，遍历该散列桶下所有的链表元素，直到找到该key为止。</li>\n</ol>\n<p>可以从上发现，即使是一个正整数的key，他也不一定会存储在数组部分，这完全取决于当前数组大小。</p>\n<p>比如说，下面代码便会发现只有1作为数组部分存储下来了，而100存储在散列表部分。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> t = &#123;&#125;</span><br><span class=\"line\">t[<span class=\"number\">1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">t[<span class=\"number\">100</span>] = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(t) <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>既然涉及到这种数据是如何进行存储的，那最佳的方案就是去看元素是如何增加的。</p>\n<h4 id=\"新增元素\">新增元素</h4>\n<h4 id=\"取长度\">取长度</h4>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--如果表存在数组部分：</span></span><br><span class=\"line\"><span class=\"comment\">--    初始化i = 0,j = table的sizearray</span></span><br><span class=\"line\"><span class=\"comment\">--    满足(j - i) &gt; 1的条件下，循环：</span></span><br><span class=\"line\"><span class=\"comment\">--        m = (j + i) / 2</span></span><br><span class=\"line\"><span class=\"comment\">--        如果array[m - 1]为nil值: j = m   右边界收缩</span></span><br><span class=\"line\"><span class=\"comment\">--        否则 i = m                      左边界收缩</span></span><br><span class=\"line\"><span class=\"comment\">--    返回 i</span></span><br><span class=\"line\"><span class=\"comment\">--否则进入散列表中进行查找，具体规则同上</span></span><br></pre></td></tr></table></figure>\n<p>可以看出，如果表中同时拥有数组和散列表的数据，那么会优先取数组部分的长度。</p>\n<h1 id=\"Lua-虚拟机\">Lua 虚拟机</h1>\n<h2 id=\"指令格式\">指令格式</h2>\n<p><a href=\"https://imgtu.com/i/OUn5UP\"><img src=\"https://s1.ax1x.com/2022/05/11/OUn5UP.png\" alt=\"OUn5UP.png\"></a></p>\n<p>可以看出Lua的指令是32位的，从低位到高位开始解析。</p>\n<p>首先，最低位是<strong>OpCode</strong>，称为操作数，接下来就是A，B，C参数。</p>\n<p>列出目前所有的指令。这个枚举可以直接从<code>lopcodes.h</code>从寻找。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">  name\t\targs\tdescription</span></span><br><span class=\"line\"><span class=\"comment\">------------------------------------------------------------------------*/</span></span><br><span class=\"line\">OP_MOVE,<span class=\"comment\">/*\tA B\tR[A] := R[B]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADI,<span class=\"comment\">/*\tA sBx\tR[A] := sBx\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADF,<span class=\"comment\">/*\tA sBx\tR[A] := (lua_Number)sBx\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADK,<span class=\"comment\">/*\tA Bx\tR[A] := K[Bx]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADKX,<span class=\"comment\">/*\tA\tR[A] := K[extra arg]\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADFALSE,<span class=\"comment\">/*\tA\tR[A] := false\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LFALSESKIP,<span class=\"comment\">/*A\tR[A] := false; pc++\t(*)\t\t\t*/</span></span><br><span class=\"line\">OP_LOADTRUE,<span class=\"comment\">/*\tA\tR[A] := true\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADNIL,<span class=\"comment\">/*\tA B\tR[A], R[A+1], ..., R[A+B] := nil\t\t*/</span></span><br><span class=\"line\">OP_GETUPVAL,<span class=\"comment\">/*\tA B\tR[A] := UpValue[B]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SETUPVAL,<span class=\"comment\">/*\tA B\tUpValue[B] := R[A]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_GETTABUP,<span class=\"comment\">/*\tA B C\tR[A] := UpValue[B][K[C]:string]\t\t\t*/</span></span><br><span class=\"line\">OP_GETTABLE,<span class=\"comment\">/*\tA B C\tR[A] := R[B][R[C]]\t\t\t\t*/</span></span><br><span class=\"line\">OP_GETI,<span class=\"comment\">/*\tA B C\tR[A] := R[B][C]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_GETFIELD,<span class=\"comment\">/*\tA B C\tR[A] := R[B][K[C]:string]\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SETTABUP,<span class=\"comment\">/*\tA B C\tUpValue[A][K[B]:string] := RK(C)\t\t*/</span></span><br><span class=\"line\">OP_SETTABLE,<span class=\"comment\">/*\tA B C\tR[A][R[B]] := RK(C)\t\t\t\t*/</span></span><br><span class=\"line\">OP_SETI,<span class=\"comment\">/*\tA B C\tR[A][B] := RK(C)\t\t\t\t*/</span></span><br><span class=\"line\">OP_SETFIELD,<span class=\"comment\">/*\tA B C\tR[A][K[B]:string] := RK(C)\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_NEWTABLE,<span class=\"comment\">/*\tA B C k\tR[A] := &#123;&#125;\t\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SELF,<span class=\"comment\">/*\tA B C\tR[A+1] := R[B]; R[A] := R[B][RK(C):string]\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_ADDI,<span class=\"comment\">/*\tA B sC\tR[A] := R[B] + sC\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_ADDK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] + K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_SUBK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] - K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_MULK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] * K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_MODK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] % K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_POWK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ^ K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_DIVK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] / K[C]:number\t\t\t*/</span></span><br><span class=\"line\">OP_IDIVK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] // K[C]:number\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_BANDK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &amp; K[C]:integer\t\t\t*/</span></span><br><span class=\"line\">OP_BORK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] | K[C]:integer\t\t\t*/</span></span><br><span class=\"line\">OP_BXORK,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ~ K[C]:integer\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SHRI,<span class=\"comment\">/*\tA B sC\tR[A] := R[B] &gt;&gt; sC\t\t\t\t*/</span></span><br><span class=\"line\">OP_SHLI,<span class=\"comment\">/*\tA B sC\tR[A] := sC &lt;&lt; R[B]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_ADD,<span class=\"comment\">/*\tA B C\tR[A] := R[B] + R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SUB,<span class=\"comment\">/*\tA B C\tR[A] := R[B] - R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_MUL,<span class=\"comment\">/*\tA B C\tR[A] := R[B] * R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_MOD,<span class=\"comment\">/*\tA B C\tR[A] := R[B] % R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_POW,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ^ R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_DIV,<span class=\"comment\">/*\tA B C\tR[A] := R[B] / R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_IDIV,<span class=\"comment\">/*\tA B C\tR[A] := R[B] // R[C]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_BAND,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &amp; R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_BOR,<span class=\"comment\">/*\tA B C\tR[A] := R[B] | R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_BXOR,<span class=\"comment\">/*\tA B C\tR[A] := R[B] ~ R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SHL,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &lt;&lt; R[C]\t\t\t\t*/</span></span><br><span class=\"line\">OP_SHR,<span class=\"comment\">/*\tA B C\tR[A] := R[B] &gt;&gt; R[C]\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_MMBIN,<span class=\"comment\">/*\tA B C\tcall C metamethod over R[A] and R[B]\t(*)\t*/</span></span><br><span class=\"line\">OP_MMBINI,<span class=\"comment\">/*\tA sB C k\tcall C metamethod over R[A] and sB\t*/</span></span><br><span class=\"line\">OP_MMBINK,<span class=\"comment\">/*\tA B C k\t\tcall C metamethod over R[A] and K[B]\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_UNM,<span class=\"comment\">/*\tA B\tR[A] := -R[B]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_BNOT,<span class=\"comment\">/*\tA B\tR[A] := ~R[B]\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_NOT,<span class=\"comment\">/*\tA B\tR[A] := not R[B]\t\t\t\t*/</span></span><br><span class=\"line\">OP_LEN,<span class=\"comment\">/*\tA B\tR[A] := #R[B] (length operator)\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CONCAT,<span class=\"comment\">/*\tA B\tR[A] := R[A].. ... ..R[A + B - 1]\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CLOSE,<span class=\"comment\">/*\tA\tclose all upvalues &gt;= R[A]\t\t\t*/</span></span><br><span class=\"line\">OP_TBC,<span class=\"comment\">/*\tA\tmark variable A &quot;to be closed&quot;\t\t\t*/</span></span><br><span class=\"line\">OP_JMP,<span class=\"comment\">/*\tsJ\tpc += sJ\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_EQ,<span class=\"comment\">/*\tA B k\tif ((R[A] == R[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_LT,<span class=\"comment\">/*\tA B k\tif ((R[A] &lt;  R[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_LE,<span class=\"comment\">/*\tA B k\tif ((R[A] &lt;= R[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_EQK,<span class=\"comment\">/*\tA B k\tif ((R[A] == K[B]) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_EQI,<span class=\"comment\">/*\tA sB k\tif ((R[A] == sB) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_LTI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &lt; sB) ~= k) then pc++\t\t\t*/</span></span><br><span class=\"line\">OP_LEI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &lt;= sB) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\">OP_GTI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &gt; sB) ~= k) then pc++\t\t\t*/</span></span><br><span class=\"line\">OP_GEI,<span class=\"comment\">/*\tA sB k\tif ((R[A] &gt;= sB) ~= k) then pc++\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_TEST,<span class=\"comment\">/*\tA k\tif (not R[A] == k) then pc++\t\t\t*/</span></span><br><span class=\"line\">OP_TESTSET,<span class=\"comment\">/*\tA B k\tif (not R[B] == k) then pc++ else R[A] := R[B] (*) */</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CALL,<span class=\"comment\">/*\tA B C\tR[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */</span></span><br><span class=\"line\">OP_TAILCALL,<span class=\"comment\">/*\tA B C k\treturn R[A](R[A+1], ... ,R[A+B-1])\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_RETURN,<span class=\"comment\">/*\tA B C k\treturn R[A], ... ,R[A+B-2]\t(see note)\t*/</span></span><br><span class=\"line\">OP_RETURN0,<span class=\"comment\">/*\t\treturn\t\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_RETURN1,<span class=\"comment\">/*\tA\treturn R[A]\t\t\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_FORLOOP,<span class=\"comment\">/*\tA Bx\tupdate counters; if loop continues then pc-=Bx; */</span></span><br><span class=\"line\">OP_FORPREP,<span class=\"comment\">/*\tA Bx\t&lt;check values and prepare counters&gt;;</span></span><br><span class=\"line\"><span class=\"comment\">                        if not to run then pc+=Bx+1;\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_TFORPREP,<span class=\"comment\">/*\tA Bx\tcreate upvalue for R[A + 3]; pc+=Bx\t\t*/</span></span><br><span class=\"line\">OP_TFORCALL,<span class=\"comment\">/*\tA C\tR[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);\t*/</span></span><br><span class=\"line\">OP_TFORLOOP,<span class=\"comment\">/*\tA Bx\tif R[A+2] ~= nil then &#123; R[A]=R[A+2]; pc -= Bx &#125;\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_SETLIST,<span class=\"comment\">/*\tA B C k\tR[A][C+i] := R[A+i], 1 &lt;= i &lt;= B\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_CLOSURE,<span class=\"comment\">/*\tA Bx\tR[A] := closure(KPROTO[Bx])\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_VARARG,<span class=\"comment\">/*\tA C\tR[A], R[A+1], ..., R[A+C-2] = vararg\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_VARARGPREP,<span class=\"comment\">/*A\t(adjust vararg parameters)\t\t\t*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">OP_EXTRAARG<span class=\"comment\">/*\tAx\textra (larger) argument for previous opcode\t*/</span></span><br><span class=\"line\">&#125; OpCode;</span><br></pre></td></tr></table></figure>\n<p>再这些指令中，有不同的取值方式，具体可以看下图。</p>\n<p><a href=\"https://imgtu.com/i/OUu0MQ\"><img src=\"https://s1.ax1x.com/2022/05/11/OUu0MQ.png\" alt=\"OUu0MQ.png\"></a></p>\n<h1 id=\"附录\">附录</h1>\n"},{"title":"List源码解析","date":"2022-02-23T05:34:21.000Z","_content":"\n# List源码解析\n\n## List构造器\n\n```csharp\npublic class List<T> : IList<T>, IList, IReadOnlyList<T>\n{\n\tprivate const int DefaultCapacity = 4;\n\n\tinternal T[] _items; // Do not rename (binary serialization)\n \tinternal int _size; // Do not rename (binary serialization)\n\tprivate int _version; // Do not rename (binary serialization)\n \tprivate static readonly T[] s_emptyArray = new T[0];\n\tpublic List()\n     {\n  \t\t_items = s_emptyArray;\n     }\n\n  \t// Constructs a List with a given initial capacity. The list is\n  \t// initially empty, but will have room for the given number of elements\n\t// before any reallocations are required.\n  \t//\n \tpublic List(int capacity)\n  \t{\n\t\tif (capacity < 0)\n         \tThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);\n\n     \tif (capacity == 0)\n        \t_items = s_emptyArray;\n    \telse\n           \t_items = new T[capacity];\n \t}\n}\n```\n\n从构造函数部分可以看出List的底层是由数组构造的，部分人或许以为是链表，但链表在C#中是LinkedList\n\n## List部分API\n\n### Add\n\n```csharp\npublic void Add(T item)\n{\n    _version++;\n    T[] array = _items;\n    int size = _size;\n    if ((uint)size < (uint)array.Length)\n    {\n        _size = size + 1;\n        array[size] = item;\n    }\n    else\n    {\n        AddWithResize(item);\n    }\n}\n```\n\n**Add**函数每次会判断当前容量是否足够，如果足够放入即可，不够的话调用`AddWithResize(item)`\n\n```csharp\nprivate void AddWithResize(T item)\n{\n    Debug.Assert(_size == _items.Length);\n    int size = _size;\n    Grow(size + 1);\n    _size = size + 1;\n    _items[size] = item;\n}\n```\n\n从名字也可以看出，**AddWithResize**的作用是添加并且调整大小。其中调整大小的部分由**Grow**实现\n\n```csharp\nprivate void Grow(int capacity)\n{\n    Debug.Assert(_items.Length < capacity);\n\n    int newcapacity = _items.Length == 0 ? DefaultCapacity : 2 * _items.Length;\n\n    // Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.\n    // Note that this check works even when _items.Length overflowed thanks to the (uint) cast\n    if ((uint)newcapacity > Array.MaxLength) newcapacity = Array.MaxLength;\n\n    // If the computed capacity is still less than specified, set to the original argument.\n    // Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.\n    if (newcapacity < capacity) newcapacity = capacity;\n\n    Capacity = newcapacity;\n}\n```\n\n```csharp\npublic int Capacity\n{\n    get => _items.Length;\n    set\n    {\n        if (value < _size)\n        {\n            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.value, ExceptionResource.ArgumentOutOfRange_SmallCapacity);\n        }\n\n        if (value != _items.Length)\n        {\n            if (value > 0)\n            {\n                T[] newItems = new T[value];\n                if (_size > 0)\n                {\n                    Array.Copy(_items, newItems, _size);\n                }\n                _items = newItems;\n            }\n            else\n            {\n                _items = s_emptyArray;\n            }\n        }\n    }\n}\n```\n\n从这里也可以看出，如果初始不给List赋值大小的话默认大小为4，如果再频繁调用`Add`，每次new都会产生内存垃圾，给GC带来了负担。这里需要注意每次扩容都是两倍，并且扩容之后是通过调用` Array.Copy(_items, newItems, _size)`从原数组拷贝生成到新数组。\n\n### Remove\n\n```csharp\npublic bool Remove(T item)\n{\n    int index = IndexOf(item);\n    if (index >= 0)\n    {\n        RemoveAt(index);\n        return true;\n    }\n\n    return false;\n}\n```\n\n```csharp\npublic int IndexOf(T item)\n    => Array.IndexOf(_items, item, 0, _size);\n```\n\n```csharp\npublic void RemoveAt(int index)\n{\n    if ((uint)index >= (uint)_size)\n    {\n        ThrowHelper.ThrowArgumentOutOfRange_IndexException();\n    }\n    _size--;\n    if (index < _size)\n    {\n        Array.Copy(_items, index + 1, _items, index, _size - index);\n    }\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())\n    {\n        _items[_size] = default!;\n    }\n    _version++;\n}\n```\n\n> `Array.IndexOf` 方法在这里需要注意的是返回值\n>\n> 如果找到，则为 `array` 中 `value` 的第一个匹配项的索引；否则为该数组的下限减 1。\n>\n> 具体可查看[Array.IndexOf 方法 (System) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.array.indexof?view=net-6.0)\n>\n> `RuntimeHelpers.IsReferenceOrContainsReferences<T>`方法在这里需要注意的是返回值\n>\n> 如果给定类型是引用类型或包含引用的值类型，则为 `true`；否则为 `false`。\n>\n> 具体可查看[RuntimeHelpers.IsReferenceOrContainsReferences 方法 (System.Runtime.CompilerServices) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimehelpers.isreferenceorcontainsreferences?view=net-6.0)\n\n从源码中即可看出，删除的原理其实就是元素覆盖，通过`Array.IndexOf`找到元素索引，之后调用`Array.Copy`覆盖被删除的元素。\n\n### Insert\n\n```csharp\npublic void Insert(int index, T item)\n{\n    // Note that insertions at the end are legal.\n    if ((uint)index > (uint)_size)\n    {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);\n    }\n    if (_size == _items.Length) Grow(_size + 1);\n    if (index < _size)\n    {\n        Array.Copy(_items, index, _items, index + 1, _size - index);\n    }\n    _items[index] = item;\n    _size++;\n    _version++;\n}\n```\n\n同样，先检查容量是否足够，之后向后覆盖，接下来将元素放入即可。\n\n### Clear\n\n```csharp\npublic void Clear()\n{\n    _version++;\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())\n    {\n        int size = _size;\n        _size = 0;\n        if (size > 0)\n        {\n            Array.Clear(_items, 0, size); // Clear the elements so that the gc can reclaim the references.\n        }\n    }\n    else\n    {\n        _size = 0;\n    }\n}\n```\n\n> `Array.Clear`需要注意这不是删除方法，他是将数组中每个元素重置为元素的默认值。 它将引用类型的元素设置 (包括string) 到的元素 `null` ，并将值类型的元素设置为下表中显示的默认值。\n>\n> [Array.Clear(Array, Int32, Int32) 方法 (System) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.array.clear?view=net-6.0)中注解也提到了\n>\n> **此方法仅清除元素的值;它不会删除元素本身。 数组具有固定的大小;因此，无法添加或删除元素。**\n\n### Contains\n\n```csharp\npublic bool Contains(T item)\n{\n    // PERF: IndexOf calls Array.IndexOf, which internally\n    // calls EqualityComparer<T>.Default.IndexOf, which\n    // is specialized for different types. This\n    // boosts performance since instead of making a\n    // virtual method call each iteration of the loop,\n    // via EqualityComparer<T>.Default.Equals, we\n    // only make one virtual call to EqualityComparer.IndexOf.\n\n    return _size != 0 && IndexOf(item) != -1;\n}\n```\n\n同样这里是通过`IndexOf`来寻找元素\n\n### ToArray\n\n```csharp\npublic T[] ToArray()\n{\n    if (_size == 0)\n    {\n        return s_emptyArray;\n    }\n\n    T[] array = new T[_size];\n    Array.Copy(_items, array, _size);\n    return array;\n}\n```\n\nnew一个新的数组，拷贝一份返回\n\n### Sort\n\n```csharp\npublic void Sort(int index, int count, IComparer<T>? comparer)\n{\n    if (index < 0)\n    {\n        ThrowHelper.ThrowIndexArgumentOutOfRange_NeedNonNegNumException();\n    }\n\n    if (count < 0)\n    {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.count, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);\n    }\n\n    if (_size - index < count)\n        ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_InvalidOffLen);\n\n    if (count > 1)\n    {\n        Array.Sort<T>(_items, index, count, comparer);\n    }\n    _version++;\n}\n```\n\n调用`Array.Sort<T>(_items, index, count, comparer)`进行排序\n\n> 这里需要注意的是Sort函数不是单纯的快速排序，官网中同样也提到了，这里我将内容贴出来。[Array.Sort 方法 (System) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.array.sort?view=net-6.0#system-array-sort(system-array))\n>\n> 此方法使用的是反省sort(introsort)算法，如下所示：\n>\n> - 如果分区大小小于或等于16个元素，则它将使用 [插入排序](https://en.wikipedia.org/wiki/Insertion_sort) 算法\n> - 如果分区超过$2*log^n$,其中`n`为输入数组的范围，则使用则使用 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 算法(堆排序)。\n> - 否则，它使用的是[快速排序](https://en.wikipedia.org/wiki/Quicksort) 算法\n>\n> 此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。\n>\n> 此方法是一个 $O(nlog^n)$ 操作，其中 `n` 是 `length`。\n>\n> PS：当然如果你点进去并且看的是中文的话，你会发现很明显的翻译错误(狗头)\n\n## 索引器\n\n```csharp\npublic T this[int index]\n{\n\tget\n\t{\n    \t// Following trick can reduce the range check by one\n   \t\t if ((uint)index >= (uint)_size)\n   \t\t {\n     \t  \t ThrowHelper.ThrowArgumentOutOfRange_IndexException();\n   \t\t }\n   \t\treturn _items[index];\n\t}\n\n\tset\n\t{\n   \t \tif ((uint)index >= (uint)_size)\n    \t{\n     \t   ThrowHelper.ThrowArgumentOutOfRange_IndexException();\n    \t}\n    \t_items[index] = value;\n    \t_version++;\n\t}\n}\n```\n\n使用数组索引获取元素\n\n## 迭代器\n\n先分开讲解源码中比较重要的两个元素**IEnumerable**和**IEnumerator**。\n\n### IEnumerable\n\n```csharp\npublic interface IEnumerable\n{\n  IEnumerator GetEnumerator();\n}\n```\n\n公开枚举数，该枚举数支持在非泛型集合上进行简单迭代。(可枚举类型)。\n\n当`foreach`遍历可枚举类型的时候，比如`List`，他会调用`GetEnumerator`方法来获取Enumerator(枚举数)，接下来从枚举数中请求每一项并且作为迭代变量。\n\n[IEnumerable 接口 (System.Collections) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable?view=net-6.0)\n\n### IEnumerator\n\n```csharp\npublic interface IEnumerator\n{\n    bool MoveNext();\n\n    object Current { get; }\n\n    void Reset();\n}\n```\n\n支持对非泛型集合的简单迭代。(枚举数)\n\n该接口包含三个成员。\n\n1. `bool MoveNext()`从集合的一个元素移动到下个元素，同时检查是否遍历完毕\n2. 只读属性`Current`用于返回当前元素\n3. `Reset`重置为初始态，一般用于报错(bushi)，最好永远不要调用它，如果要重新开始枚举，重新创建一个新的即可。\n\n[IEnumerator 接口 (System.Collections) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator?view=net-6.0)\n\n### 源码\n\n```csharp\npublic Enumerator GetEnumerator() => new Enumerator(this);\nIEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);\nIEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);\npublic struct Enumerator : IEnumerator<T>, IEnumerator\n{\n    private readonly List<T> _list;\n    private int _index;\n    private readonly int _version;\n    private T? _current;\n    internal Enumerator(List<T> list)\n    {\n        _list = list;\n        _index = 0;\n        _version = list._version;\n        _current = default;\n    }\n\n    public void Dispose()\n    {\n    }\n\n    public bool MoveNext()\n    {\n        List<T> localList = _list;\n\n        if (_version == localList._version && ((uint)_index < (uint)localList._size))\n        {\n            _current = localList._items[_index];\n            _index++;\n            return true;\n        }\n\n        return MoveNextRare();\n    }\n\n    private bool MoveNextRare()\n    {\n        if (_version != _list._version)\n        {\n            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();\n        }\n\n        _index = _list._size + 1;\n        _current = default;\n        return false;\n    }\n\n    public T Current => _current!;\n\n    object? IEnumerator.Current\n    {\n        get\n        {\n            if (_index == 0 || _index == _list._size + 1)\n            {\n                ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();\n            }\n\n            return Current;\n        }\n    }\n\n    void IEnumerator.Reset()\n    {\n        if (_version != _list._version)\n        {\n            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();\n        }\n\n        _index = 0;\n        _current = default;\n    }\n}\n```\n上述模式大致可以简单描述为\n\n```csharp\n//当然具体不是这样的\nint number = 0;\nvar enumerator = list.GetEnumerator();\nwhile(enumerator.MoveNext())\n{\n\tnumber = enumerator.Current;\n}\n```\n\n或许会有人觉得`GetEnumerator()`有点多此一举,觉得可以像下面这么写也能做到一样的效果\n\n```csharp\nint number = 0;\nwhile(list.MoveNext())\n{\n\tnumber = list.Current;\n}\n```\n\n但这样，如果两个循环交错遍历同一个集合，或者是多线程循环，交错的循环将会产生干扰。所以不使用该方法，而是用`IEnumerator`来支持`IEnumerator`并且负责维护循环遍历的状态。这样遍历集合便不会产生影响。\n\nPs:不是非要实现IEnumerable才能对类型进行遍历。遍历器使用了一个名为\"Duck typing\"的概念，他会查找一个返回“包含Current属性和MoveNext()方法的一个类型”的GetEnumerator()方法。Duck typing按照名称查找方法，而不依赖接口或者显式方法调用。只有当找不到实现时，才会检查集合是否实现了接口。\n","source":"_posts/List源码解析.md","raw":"---\ntitle: List源码解析\ndate: 2022-02-23 13:34:21\ntags: c#\ncategories: 语言基础\n---\n\n# List源码解析\n\n## List构造器\n\n```csharp\npublic class List<T> : IList<T>, IList, IReadOnlyList<T>\n{\n\tprivate const int DefaultCapacity = 4;\n\n\tinternal T[] _items; // Do not rename (binary serialization)\n \tinternal int _size; // Do not rename (binary serialization)\n\tprivate int _version; // Do not rename (binary serialization)\n \tprivate static readonly T[] s_emptyArray = new T[0];\n\tpublic List()\n     {\n  \t\t_items = s_emptyArray;\n     }\n\n  \t// Constructs a List with a given initial capacity. The list is\n  \t// initially empty, but will have room for the given number of elements\n\t// before any reallocations are required.\n  \t//\n \tpublic List(int capacity)\n  \t{\n\t\tif (capacity < 0)\n         \tThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);\n\n     \tif (capacity == 0)\n        \t_items = s_emptyArray;\n    \telse\n           \t_items = new T[capacity];\n \t}\n}\n```\n\n从构造函数部分可以看出List的底层是由数组构造的，部分人或许以为是链表，但链表在C#中是LinkedList\n\n## List部分API\n\n### Add\n\n```csharp\npublic void Add(T item)\n{\n    _version++;\n    T[] array = _items;\n    int size = _size;\n    if ((uint)size < (uint)array.Length)\n    {\n        _size = size + 1;\n        array[size] = item;\n    }\n    else\n    {\n        AddWithResize(item);\n    }\n}\n```\n\n**Add**函数每次会判断当前容量是否足够，如果足够放入即可，不够的话调用`AddWithResize(item)`\n\n```csharp\nprivate void AddWithResize(T item)\n{\n    Debug.Assert(_size == _items.Length);\n    int size = _size;\n    Grow(size + 1);\n    _size = size + 1;\n    _items[size] = item;\n}\n```\n\n从名字也可以看出，**AddWithResize**的作用是添加并且调整大小。其中调整大小的部分由**Grow**实现\n\n```csharp\nprivate void Grow(int capacity)\n{\n    Debug.Assert(_items.Length < capacity);\n\n    int newcapacity = _items.Length == 0 ? DefaultCapacity : 2 * _items.Length;\n\n    // Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.\n    // Note that this check works even when _items.Length overflowed thanks to the (uint) cast\n    if ((uint)newcapacity > Array.MaxLength) newcapacity = Array.MaxLength;\n\n    // If the computed capacity is still less than specified, set to the original argument.\n    // Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.\n    if (newcapacity < capacity) newcapacity = capacity;\n\n    Capacity = newcapacity;\n}\n```\n\n```csharp\npublic int Capacity\n{\n    get => _items.Length;\n    set\n    {\n        if (value < _size)\n        {\n            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.value, ExceptionResource.ArgumentOutOfRange_SmallCapacity);\n        }\n\n        if (value != _items.Length)\n        {\n            if (value > 0)\n            {\n                T[] newItems = new T[value];\n                if (_size > 0)\n                {\n                    Array.Copy(_items, newItems, _size);\n                }\n                _items = newItems;\n            }\n            else\n            {\n                _items = s_emptyArray;\n            }\n        }\n    }\n}\n```\n\n从这里也可以看出，如果初始不给List赋值大小的话默认大小为4，如果再频繁调用`Add`，每次new都会产生内存垃圾，给GC带来了负担。这里需要注意每次扩容都是两倍，并且扩容之后是通过调用` Array.Copy(_items, newItems, _size)`从原数组拷贝生成到新数组。\n\n### Remove\n\n```csharp\npublic bool Remove(T item)\n{\n    int index = IndexOf(item);\n    if (index >= 0)\n    {\n        RemoveAt(index);\n        return true;\n    }\n\n    return false;\n}\n```\n\n```csharp\npublic int IndexOf(T item)\n    => Array.IndexOf(_items, item, 0, _size);\n```\n\n```csharp\npublic void RemoveAt(int index)\n{\n    if ((uint)index >= (uint)_size)\n    {\n        ThrowHelper.ThrowArgumentOutOfRange_IndexException();\n    }\n    _size--;\n    if (index < _size)\n    {\n        Array.Copy(_items, index + 1, _items, index, _size - index);\n    }\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())\n    {\n        _items[_size] = default!;\n    }\n    _version++;\n}\n```\n\n> `Array.IndexOf` 方法在这里需要注意的是返回值\n>\n> 如果找到，则为 `array` 中 `value` 的第一个匹配项的索引；否则为该数组的下限减 1。\n>\n> 具体可查看[Array.IndexOf 方法 (System) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.array.indexof?view=net-6.0)\n>\n> `RuntimeHelpers.IsReferenceOrContainsReferences<T>`方法在这里需要注意的是返回值\n>\n> 如果给定类型是引用类型或包含引用的值类型，则为 `true`；否则为 `false`。\n>\n> 具体可查看[RuntimeHelpers.IsReferenceOrContainsReferences 方法 (System.Runtime.CompilerServices) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimehelpers.isreferenceorcontainsreferences?view=net-6.0)\n\n从源码中即可看出，删除的原理其实就是元素覆盖，通过`Array.IndexOf`找到元素索引，之后调用`Array.Copy`覆盖被删除的元素。\n\n### Insert\n\n```csharp\npublic void Insert(int index, T item)\n{\n    // Note that insertions at the end are legal.\n    if ((uint)index > (uint)_size)\n    {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);\n    }\n    if (_size == _items.Length) Grow(_size + 1);\n    if (index < _size)\n    {\n        Array.Copy(_items, index, _items, index + 1, _size - index);\n    }\n    _items[index] = item;\n    _size++;\n    _version++;\n}\n```\n\n同样，先检查容量是否足够，之后向后覆盖，接下来将元素放入即可。\n\n### Clear\n\n```csharp\npublic void Clear()\n{\n    _version++;\n    if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())\n    {\n        int size = _size;\n        _size = 0;\n        if (size > 0)\n        {\n            Array.Clear(_items, 0, size); // Clear the elements so that the gc can reclaim the references.\n        }\n    }\n    else\n    {\n        _size = 0;\n    }\n}\n```\n\n> `Array.Clear`需要注意这不是删除方法，他是将数组中每个元素重置为元素的默认值。 它将引用类型的元素设置 (包括string) 到的元素 `null` ，并将值类型的元素设置为下表中显示的默认值。\n>\n> [Array.Clear(Array, Int32, Int32) 方法 (System) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.array.clear?view=net-6.0)中注解也提到了\n>\n> **此方法仅清除元素的值;它不会删除元素本身。 数组具有固定的大小;因此，无法添加或删除元素。**\n\n### Contains\n\n```csharp\npublic bool Contains(T item)\n{\n    // PERF: IndexOf calls Array.IndexOf, which internally\n    // calls EqualityComparer<T>.Default.IndexOf, which\n    // is specialized for different types. This\n    // boosts performance since instead of making a\n    // virtual method call each iteration of the loop,\n    // via EqualityComparer<T>.Default.Equals, we\n    // only make one virtual call to EqualityComparer.IndexOf.\n\n    return _size != 0 && IndexOf(item) != -1;\n}\n```\n\n同样这里是通过`IndexOf`来寻找元素\n\n### ToArray\n\n```csharp\npublic T[] ToArray()\n{\n    if (_size == 0)\n    {\n        return s_emptyArray;\n    }\n\n    T[] array = new T[_size];\n    Array.Copy(_items, array, _size);\n    return array;\n}\n```\n\nnew一个新的数组，拷贝一份返回\n\n### Sort\n\n```csharp\npublic void Sort(int index, int count, IComparer<T>? comparer)\n{\n    if (index < 0)\n    {\n        ThrowHelper.ThrowIndexArgumentOutOfRange_NeedNonNegNumException();\n    }\n\n    if (count < 0)\n    {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.count, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);\n    }\n\n    if (_size - index < count)\n        ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_InvalidOffLen);\n\n    if (count > 1)\n    {\n        Array.Sort<T>(_items, index, count, comparer);\n    }\n    _version++;\n}\n```\n\n调用`Array.Sort<T>(_items, index, count, comparer)`进行排序\n\n> 这里需要注意的是Sort函数不是单纯的快速排序，官网中同样也提到了，这里我将内容贴出来。[Array.Sort 方法 (System) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.array.sort?view=net-6.0#system-array-sort(system-array))\n>\n> 此方法使用的是反省sort(introsort)算法，如下所示：\n>\n> - 如果分区大小小于或等于16个元素，则它将使用 [插入排序](https://en.wikipedia.org/wiki/Insertion_sort) 算法\n> - 如果分区超过$2*log^n$,其中`n`为输入数组的范围，则使用则使用 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 算法(堆排序)。\n> - 否则，它使用的是[快速排序](https://en.wikipedia.org/wiki/Quicksort) 算法\n>\n> 此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。\n>\n> 此方法是一个 $O(nlog^n)$ 操作，其中 `n` 是 `length`。\n>\n> PS：当然如果你点进去并且看的是中文的话，你会发现很明显的翻译错误(狗头)\n\n## 索引器\n\n```csharp\npublic T this[int index]\n{\n\tget\n\t{\n    \t// Following trick can reduce the range check by one\n   \t\t if ((uint)index >= (uint)_size)\n   \t\t {\n     \t  \t ThrowHelper.ThrowArgumentOutOfRange_IndexException();\n   \t\t }\n   \t\treturn _items[index];\n\t}\n\n\tset\n\t{\n   \t \tif ((uint)index >= (uint)_size)\n    \t{\n     \t   ThrowHelper.ThrowArgumentOutOfRange_IndexException();\n    \t}\n    \t_items[index] = value;\n    \t_version++;\n\t}\n}\n```\n\n使用数组索引获取元素\n\n## 迭代器\n\n先分开讲解源码中比较重要的两个元素**IEnumerable**和**IEnumerator**。\n\n### IEnumerable\n\n```csharp\npublic interface IEnumerable\n{\n  IEnumerator GetEnumerator();\n}\n```\n\n公开枚举数，该枚举数支持在非泛型集合上进行简单迭代。(可枚举类型)。\n\n当`foreach`遍历可枚举类型的时候，比如`List`，他会调用`GetEnumerator`方法来获取Enumerator(枚举数)，接下来从枚举数中请求每一项并且作为迭代变量。\n\n[IEnumerable 接口 (System.Collections) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable?view=net-6.0)\n\n### IEnumerator\n\n```csharp\npublic interface IEnumerator\n{\n    bool MoveNext();\n\n    object Current { get; }\n\n    void Reset();\n}\n```\n\n支持对非泛型集合的简单迭代。(枚举数)\n\n该接口包含三个成员。\n\n1. `bool MoveNext()`从集合的一个元素移动到下个元素，同时检查是否遍历完毕\n2. 只读属性`Current`用于返回当前元素\n3. `Reset`重置为初始态，一般用于报错(bushi)，最好永远不要调用它，如果要重新开始枚举，重新创建一个新的即可。\n\n[IEnumerator 接口 (System.Collections) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator?view=net-6.0)\n\n### 源码\n\n```csharp\npublic Enumerator GetEnumerator() => new Enumerator(this);\nIEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);\nIEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);\npublic struct Enumerator : IEnumerator<T>, IEnumerator\n{\n    private readonly List<T> _list;\n    private int _index;\n    private readonly int _version;\n    private T? _current;\n    internal Enumerator(List<T> list)\n    {\n        _list = list;\n        _index = 0;\n        _version = list._version;\n        _current = default;\n    }\n\n    public void Dispose()\n    {\n    }\n\n    public bool MoveNext()\n    {\n        List<T> localList = _list;\n\n        if (_version == localList._version && ((uint)_index < (uint)localList._size))\n        {\n            _current = localList._items[_index];\n            _index++;\n            return true;\n        }\n\n        return MoveNextRare();\n    }\n\n    private bool MoveNextRare()\n    {\n        if (_version != _list._version)\n        {\n            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();\n        }\n\n        _index = _list._size + 1;\n        _current = default;\n        return false;\n    }\n\n    public T Current => _current!;\n\n    object? IEnumerator.Current\n    {\n        get\n        {\n            if (_index == 0 || _index == _list._size + 1)\n            {\n                ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();\n            }\n\n            return Current;\n        }\n    }\n\n    void IEnumerator.Reset()\n    {\n        if (_version != _list._version)\n        {\n            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();\n        }\n\n        _index = 0;\n        _current = default;\n    }\n}\n```\n上述模式大致可以简单描述为\n\n```csharp\n//当然具体不是这样的\nint number = 0;\nvar enumerator = list.GetEnumerator();\nwhile(enumerator.MoveNext())\n{\n\tnumber = enumerator.Current;\n}\n```\n\n或许会有人觉得`GetEnumerator()`有点多此一举,觉得可以像下面这么写也能做到一样的效果\n\n```csharp\nint number = 0;\nwhile(list.MoveNext())\n{\n\tnumber = list.Current;\n}\n```\n\n但这样，如果两个循环交错遍历同一个集合，或者是多线程循环，交错的循环将会产生干扰。所以不使用该方法，而是用`IEnumerator`来支持`IEnumerator`并且负责维护循环遍历的状态。这样遍历集合便不会产生影响。\n\nPs:不是非要实现IEnumerable才能对类型进行遍历。遍历器使用了一个名为\"Duck typing\"的概念，他会查找一个返回“包含Current属性和MoveNext()方法的一个类型”的GetEnumerator()方法。Duck typing按照名称查找方法，而不依赖接口或者显式方法调用。只有当找不到实现时，才会检查集合是否实现了接口。\n","slug":"List源码解析","published":1,"updated":"2022-05-02T12:50:27.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztq7000a2cup5o0hd4t9","content":"<h1 id=\"List源码解析\">List源码解析</h1>\n<h2 id=\"List构造器\">List构造器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">List</span>&lt;<span class=\"title\">T</span>&gt; : <span class=\"title\">IList</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">IList</span>, <span class=\"title\">IReadOnlyList</span>&lt;<span class=\"title\">T</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> DefaultCapacity = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">internal</span> T[] _items; <span class=\"comment\">// Do not rename (binary serialization)</span></span><br><span class=\"line\"> \t<span class=\"keyword\">internal</span> <span class=\"built_in\">int</span> _size; <span class=\"comment\">// Do not rename (binary serialization)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _version; <span class=\"comment\">// Do not rename (binary serialization)</span></span><br><span class=\"line\"> \t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> T[] s_emptyArray = <span class=\"keyword\">new</span> T[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">List</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">  \t\t_items = s_emptyArray;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">// Constructs a List with a given initial capacity. The list is</span></span><br><span class=\"line\">  \t<span class=\"comment\">// initially empty, but will have room for the given number of elements</span></span><br><span class=\"line\">\t<span class=\"comment\">// before any reallocations are required.</span></span><br><span class=\"line\">  \t<span class=\"comment\">//</span></span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">List</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity</span>)</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (capacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">         \tThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);</span><br><span class=\"line\"></span><br><span class=\"line\">     \t<span class=\"keyword\">if</span> (capacity == <span class=\"number\">0</span>)</span><br><span class=\"line\">        \t_items = s_emptyArray;</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span></span><br><span class=\"line\">           \t_items = <span class=\"keyword\">new</span> T[capacity];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从构造函数部分可以看出List的底层是由数组构造的，部分人或许以为是链表，但链表在C#中是LinkedList</p>\n<h2 id=\"List部分API\">List部分API</h2>\n<h3 id=\"Add\">Add</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Add</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">    T[] array = _items;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> size = _size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)size &lt; (<span class=\"built_in\">uint</span>)array.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _size = size + <span class=\"number\">1</span>;</span><br><span class=\"line\">        array[size] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AddWithResize(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Add</strong>函数每次会判断当前容量是否足够，如果足够放入即可，不够的话调用<code>AddWithResize(item)</code></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddWithResize</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Debug.Assert(_size == _items.Length);</span><br><span class=\"line\">    <span class=\"built_in\">int</span> size = _size;</span><br><span class=\"line\">    Grow(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    _size = size + <span class=\"number\">1</span>;</span><br><span class=\"line\">    _items[size] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从名字也可以看出，<strong>AddWithResize</strong>的作用是添加并且调整大小。其中调整大小的部分由<strong>Grow</strong>实现</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Grow</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Debug.Assert(_items.Length &lt; capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> newcapacity = _items.Length == <span class=\"number\">0</span> ? DefaultCapacity : <span class=\"number\">2</span> * _items.Length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.</span></span><br><span class=\"line\">    <span class=\"comment\">// Note that this check works even when _items.Length overflowed thanks to the (uint) cast</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)newcapacity &gt; Array.MaxLength) newcapacity = Array.MaxLength;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the computed capacity is still less than specified, set to the original argument.</span></span><br><span class=\"line\">    <span class=\"comment\">// Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newcapacity &lt; capacity) newcapacity = capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    Capacity = newcapacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Capacity</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> =&gt; _items.Length;</span><br><span class=\"line\">    <span class=\"keyword\">set</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> &lt; _size)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.<span class=\"keyword\">value</span>, ExceptionResource.ArgumentOutOfRange_SmallCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> != _items.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                T[] newItems = <span class=\"keyword\">new</span> T[<span class=\"keyword\">value</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (_size &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    Array.Copy(_items, newItems, _size);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                _items = newItems;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _items = s_emptyArray;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里也可以看出，如果初始不给List赋值大小的话默认大小为4，如果再频繁调用<code>Add</code>，每次new都会产生内存垃圾，给GC带来了负担。这里需要注意每次扩容都是两倍，并且扩容之后是通过调用<code> Array.Copy(_items, newItems, _size)</code>从原数组拷贝生成到新数组。</p>\n<h3 id=\"Remove\">Remove</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Remove</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> index = IndexOf(item);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        RemoveAt(index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">IndexOf</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">    =&gt; Array.IndexOf(_items, item, <span class=\"number\">0</span>, _size);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveAt</span>(<span class=\"params\"><span class=\"built_in\">int</span> index</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt;= (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRange_IndexException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; _size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Array.Copy(_items, index + <span class=\"number\">1</span>, _items, index, _size - index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _items[_size] = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Array.IndexOf</code> 方法在这里需要注意的是返回值</p>\n<p>如果找到，则为 <code>array</code> 中 <code>value</code> 的第一个匹配项的索引；否则为该数组的下限减 1。</p>\n<p>具体可查看<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.array.indexof?view=net-6.0\">Array.IndexOf 方法 (System) | Microsoft Docs</a></p>\n<p><code>RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;</code>方法在这里需要注意的是返回值</p>\n<p>如果给定类型是引用类型或包含引用的值类型，则为 <code>true</code>；否则为 <code>false</code>。</p>\n<p>具体可查看<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimehelpers.isreferenceorcontainsreferences?view=net-6.0\">RuntimeHelpers.IsReferenceOrContainsReferences 方法 (System.Runtime.CompilerServices) | Microsoft Docs</a></p>\n</blockquote>\n<p>从源码中即可看出，删除的原理其实就是元素覆盖，通过<code>Array.IndexOf</code>找到元素索引，之后调用<code>Array.Copy</code>覆盖被删除的元素。</p>\n<h3 id=\"Insert\">Insert</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Insert</span>(<span class=\"params\"><span class=\"built_in\">int</span> index, T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note that insertions at the end are legal.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt; (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size == _items.Length) Grow(_size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; _size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Array.Copy(_items, index, _items, index + <span class=\"number\">1</span>, _size - index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _items[index] = item;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，先检查容量是否足够，之后向后覆盖，接下来将元素放入即可。</p>\n<h3 id=\"Clear\">Clear</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Clear</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> size = _size;</span><br><span class=\"line\">        _size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Array.Clear(_items, <span class=\"number\">0</span>, size); <span class=\"comment\">// Clear the elements so that the gc can reclaim the references.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Array.Clear</code>需要注意这不是删除方法，他是将数组中每个元素重置为元素的默认值。 它将引用类型的元素设置 (包括string) 到的元素 <code>null</code> ，并将值类型的元素设置为下表中显示的默认值。</p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.array.clear?view=net-6.0\">Array.Clear(Array, Int32, Int32) 方法 (System) | Microsoft Docs</a>中注解也提到了</p>\n<p><strong>此方法仅清除元素的值;它不会删除元素本身。 数组具有固定的大小;因此，无法添加或删除元素。</strong></p>\n</blockquote>\n<h3 id=\"Contains\">Contains</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Contains</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// PERF: IndexOf calls Array.IndexOf, which internally</span></span><br><span class=\"line\">    <span class=\"comment\">// calls EqualityComparer&lt;T&gt;.Default.IndexOf, which</span></span><br><span class=\"line\">    <span class=\"comment\">// is specialized for different types. This</span></span><br><span class=\"line\">    <span class=\"comment\">// boosts performance since instead of making a</span></span><br><span class=\"line\">    <span class=\"comment\">// virtual method call each iteration of the loop,</span></span><br><span class=\"line\">    <span class=\"comment\">// via EqualityComparer&lt;T&gt;.Default.Equals, we</span></span><br><span class=\"line\">    <span class=\"comment\">// only make one virtual call to EqualityComparer.IndexOf.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _size != <span class=\"number\">0</span> &amp;&amp; IndexOf(item) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样这里是通过<code>IndexOf</code>来寻找元素</p>\n<h3 id=\"ToArray\">ToArray</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T[] <span class=\"title\">ToArray</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s_emptyArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T[] array = <span class=\"keyword\">new</span> T[_size];</span><br><span class=\"line\">    Array.Copy(_items, array, _size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>new一个新的数组，拷贝一份返回</p>\n<h3 id=\"Sort\">Sort</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Sort</span>(<span class=\"params\"><span class=\"built_in\">int</span> index, <span class=\"built_in\">int</span> count, IComparer&lt;T&gt;? comparer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowIndexArgumentOutOfRange_NeedNonNegNumException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.count, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size - index &lt; count)</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_InvalidOffLen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Array.Sort&lt;T&gt;(_items, index, count, comparer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>Array.Sort&lt;T&gt;(_items, index, count, comparer)</code>进行排序</p>\n<blockquote>\n<p>这里需要注意的是Sort函数不是单纯的快速排序，官网中同样也提到了，这里我将内容贴出来。<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.array.sort?view=net-6.0#system-array-sort(system-array)\">Array.Sort 方法 (System) | Microsoft Docs</a></p>\n<p>此方法使用的是反省sort(introsort)算法，如下所示：</p>\n<ul>\n<li>如果分区大小小于或等于16个元素，则它将使用 <a href=\"https://en.wikipedia.org/wiki/Insertion_sort\">插入排序</a> 算法</li>\n<li>如果分区超过<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2*log^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>,其中<code>n</code>为输入数组的范围，则使用则使用 <a href=\"https://en.wikipedia.org/wiki/Heapsort\">Heapsort</a> 算法(堆排序)。</li>\n<li>否则，它使用的是<a href=\"https://en.wikipedia.org/wiki/Quicksort\">快速排序</a> 算法</li>\n</ul>\n<p>此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。</p>\n<p>此方法是一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog^n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 操作，其中 <code>n</code> 是 <code>length</code>。</p>\n<p>PS：当然如果你点进去并且看的是中文的话，你会发现很明显的翻译错误(狗头)</p>\n</blockquote>\n<h2 id=\"索引器\">索引器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"keyword\">this</span>[<span class=\"built_in\">int</span> index]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">get</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// Following trick can reduce the range check by one</span></span><br><span class=\"line\">   \t\t <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt;= (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">   \t\t &#123;</span><br><span class=\"line\">     \t  \t ThrowHelper.ThrowArgumentOutOfRange_IndexException();</span><br><span class=\"line\">   \t\t &#125;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> _items[index];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">set</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">   \t \t<span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt;= (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">     \t   ThrowHelper.ThrowArgumentOutOfRange_IndexException();</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t_items[index] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    \t_version++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用数组索引获取元素</p>\n<h2 id=\"迭代器\">迭代器</h2>\n<p>先分开讲解源码中比较重要的两个元素<strong>IEnumerable</strong>和<strong>IEnumerator</strong>。</p>\n<h3 id=\"IEnumerable\">IEnumerable</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IEnumerable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\">IEnumerator <span class=\"title\">GetEnumerator</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>公开枚举数，该枚举数支持在非泛型集合上进行简单迭代。(可枚举类型)。</p>\n<p>当<code>foreach</code>遍历可枚举类型的时候，比如<code>List</code>，他会调用<code>GetEnumerator</code>方法来获取Enumerator(枚举数)，接下来从枚举数中请求每一项并且作为迭代变量。</p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable?view=net-6.0\">IEnumerable 接口 (System.Collections) | Microsoft Docs</a></p>\n<h3 id=\"IEnumerator\">IEnumerator</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IEnumerator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">bool</span> <span class=\"title\">MoveNext</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">object</span> Current &#123; <span class=\"keyword\">get</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reset</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>支持对非泛型集合的简单迭代。(枚举数)</p>\n<p>该接口包含三个成员。</p>\n<ol>\n<li><code>bool MoveNext()</code>从集合的一个元素移动到下个元素，同时检查是否遍历完毕</li>\n<li>只读属性<code>Current</code>用于返回当前元素</li>\n<li><code>Reset</code>重置为初始态，一般用于报错(bushi)，最好永远不要调用它，如果要重新开始枚举，重新创建一个新的即可。</li>\n</ol>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator?view=net-6.0\">IEnumerator 接口 (System.Collections) | Microsoft Docs</a></p>\n<h3 id=\"源码\">源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Enumerator <span class=\"title\">GetEnumerator</span>(<span class=\"params\"></span>)</span> =&gt; <span class=\"keyword\">new</span> Enumerator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator() =&gt; <span class=\"keyword\">new</span> Enumerator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">IEnumerator IEnumerable.GetEnumerator() =&gt; <span class=\"keyword\">new</span> Enumerator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> Enumerator : IEnumerator&lt;T&gt;, IEnumerator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> List&lt;T&gt; _list;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _index;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> _version;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T? _current;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"title\">Enumerator</span>(<span class=\"params\">List&lt;T&gt; list</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _list = list;</span><br><span class=\"line\">        _index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        _version = list._version;</span><br><span class=\"line\">        _current = <span class=\"literal\">default</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Dispose</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">MoveNext</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        List&lt;T&gt; localList = _list;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_version == localList._version &amp;&amp; ((<span class=\"built_in\">uint</span>)_index &lt; (<span class=\"built_in\">uint</span>)localList._size))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _current = localList._items[_index];</span><br><span class=\"line\">            _index++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> MoveNextRare();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> <span class=\"title\">MoveNextRare</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_version != _list._version)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        _index = _list._size + <span class=\"number\">1</span>;</span><br><span class=\"line\">        _current = <span class=\"literal\">default</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T Current =&gt; _current!;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">object</span>? IEnumerator.Current</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_index == <span class=\"number\">0</span> || _index == _list._size + <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> IEnumerator.Reset()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_version != _list._version)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        _index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        _current = <span class=\"literal\">default</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述模式大致可以简单描述为</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当然具体不是这样的</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> enumerator = list.GetEnumerator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(enumerator.MoveNext())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnumber = enumerator.Current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或许会有人觉得<code>GetEnumerator()</code>有点多此一举,觉得可以像下面这么写也能做到一样的效果</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(list.MoveNext())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnumber = list.Current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但这样，如果两个循环交错遍历同一个集合，或者是多线程循环，交错的循环将会产生干扰。所以不使用该方法，而是用<code>IEnumerator</code>来支持<code>IEnumerator</code>并且负责维护循环遍历的状态。这样遍历集合便不会产生影响。</p>\n<p>Ps:不是非要实现IEnumerable才能对类型进行遍历。遍历器使用了一个名为&quot;Duck typing&quot;的概念，他会查找一个返回“包含Current属性和MoveNext()方法的一个类型”的GetEnumerator()方法。Duck typing按照名称查找方法，而不依赖接口或者显式方法调用。只有当找不到实现时，才会检查集合是否实现了接口。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg","excerpt":"","more":"<h1 id=\"List源码解析\">List源码解析</h1>\n<h2 id=\"List构造器\">List构造器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">List</span>&lt;<span class=\"title\">T</span>&gt; : <span class=\"title\">IList</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">IList</span>, <span class=\"title\">IReadOnlyList</span>&lt;<span class=\"title\">T</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> DefaultCapacity = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">internal</span> T[] _items; <span class=\"comment\">// Do not rename (binary serialization)</span></span><br><span class=\"line\"> \t<span class=\"keyword\">internal</span> <span class=\"built_in\">int</span> _size; <span class=\"comment\">// Do not rename (binary serialization)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _version; <span class=\"comment\">// Do not rename (binary serialization)</span></span><br><span class=\"line\"> \t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> T[] s_emptyArray = <span class=\"keyword\">new</span> T[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">List</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">  \t\t_items = s_emptyArray;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">// Constructs a List with a given initial capacity. The list is</span></span><br><span class=\"line\">  \t<span class=\"comment\">// initially empty, but will have room for the given number of elements</span></span><br><span class=\"line\">\t<span class=\"comment\">// before any reallocations are required.</span></span><br><span class=\"line\">  \t<span class=\"comment\">//</span></span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">List</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity</span>)</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (capacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">         \tThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);</span><br><span class=\"line\"></span><br><span class=\"line\">     \t<span class=\"keyword\">if</span> (capacity == <span class=\"number\">0</span>)</span><br><span class=\"line\">        \t_items = s_emptyArray;</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span></span><br><span class=\"line\">           \t_items = <span class=\"keyword\">new</span> T[capacity];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从构造函数部分可以看出List的底层是由数组构造的，部分人或许以为是链表，但链表在C#中是LinkedList</p>\n<h2 id=\"List部分API\">List部分API</h2>\n<h3 id=\"Add\">Add</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Add</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">    T[] array = _items;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> size = _size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)size &lt; (<span class=\"built_in\">uint</span>)array.Length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _size = size + <span class=\"number\">1</span>;</span><br><span class=\"line\">        array[size] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AddWithResize(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Add</strong>函数每次会判断当前容量是否足够，如果足够放入即可，不够的话调用<code>AddWithResize(item)</code></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">AddWithResize</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Debug.Assert(_size == _items.Length);</span><br><span class=\"line\">    <span class=\"built_in\">int</span> size = _size;</span><br><span class=\"line\">    Grow(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    _size = size + <span class=\"number\">1</span>;</span><br><span class=\"line\">    _items[size] = item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从名字也可以看出，<strong>AddWithResize</strong>的作用是添加并且调整大小。其中调整大小的部分由<strong>Grow</strong>实现</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">Grow</span>(<span class=\"params\"><span class=\"built_in\">int</span> capacity</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Debug.Assert(_items.Length &lt; capacity);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> newcapacity = _items.Length == <span class=\"number\">0</span> ? DefaultCapacity : <span class=\"number\">2</span> * _items.Length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.</span></span><br><span class=\"line\">    <span class=\"comment\">// Note that this check works even when _items.Length overflowed thanks to the (uint) cast</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)newcapacity &gt; Array.MaxLength) newcapacity = Array.MaxLength;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the computed capacity is still less than specified, set to the original argument.</span></span><br><span class=\"line\">    <span class=\"comment\">// Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newcapacity &lt; capacity) newcapacity = capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    Capacity = newcapacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Capacity</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> =&gt; _items.Length;</span><br><span class=\"line\">    <span class=\"keyword\">set</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> &lt; _size)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.<span class=\"keyword\">value</span>, ExceptionResource.ArgumentOutOfRange_SmallCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> != _items.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                T[] newItems = <span class=\"keyword\">new</span> T[<span class=\"keyword\">value</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (_size &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    Array.Copy(_items, newItems, _size);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                _items = newItems;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _items = s_emptyArray;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里也可以看出，如果初始不给List赋值大小的话默认大小为4，如果再频繁调用<code>Add</code>，每次new都会产生内存垃圾，给GC带来了负担。这里需要注意每次扩容都是两倍，并且扩容之后是通过调用<code> Array.Copy(_items, newItems, _size)</code>从原数组拷贝生成到新数组。</p>\n<h3 id=\"Remove\">Remove</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Remove</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> index = IndexOf(item);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        RemoveAt(index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">IndexOf</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">    =&gt; Array.IndexOf(_items, item, <span class=\"number\">0</span>, _size);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RemoveAt</span>(<span class=\"params\"><span class=\"built_in\">int</span> index</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt;= (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRange_IndexException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _size--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; _size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Array.Copy(_items, index + <span class=\"number\">1</span>, _items, index, _size - index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _items[_size] = <span class=\"literal\">default</span>!;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Array.IndexOf</code> 方法在这里需要注意的是返回值</p>\n<p>如果找到，则为 <code>array</code> 中 <code>value</code> 的第一个匹配项的索引；否则为该数组的下限减 1。</p>\n<p>具体可查看<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.array.indexof?view=net-6.0\">Array.IndexOf 方法 (System) | Microsoft Docs</a></p>\n<p><code>RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;</code>方法在这里需要注意的是返回值</p>\n<p>如果给定类型是引用类型或包含引用的值类型，则为 <code>true</code>；否则为 <code>false</code>。</p>\n<p>具体可查看<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimehelpers.isreferenceorcontainsreferences?view=net-6.0\">RuntimeHelpers.IsReferenceOrContainsReferences 方法 (System.Runtime.CompilerServices) | Microsoft Docs</a></p>\n</blockquote>\n<p>从源码中即可看出，删除的原理其实就是元素覆盖，通过<code>Array.IndexOf</code>找到元素索引，之后调用<code>Array.Copy</code>覆盖被删除的元素。</p>\n<h3 id=\"Insert\">Insert</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Insert</span>(<span class=\"params\"><span class=\"built_in\">int</span> index, T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note that insertions at the end are legal.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt; (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size == _items.Length) Grow(_size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; _size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Array.Copy(_items, index, _items, index + <span class=\"number\">1</span>, _size - index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _items[index] = item;</span><br><span class=\"line\">    _size++;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，先检查容量是否足够，之后向后覆盖，接下来将元素放入即可。</p>\n<h3 id=\"Clear\">Clear</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Clear</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> size = _size;</span><br><span class=\"line\">        _size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Array.Clear(_items, <span class=\"number\">0</span>, size); <span class=\"comment\">// Clear the elements so that the gc can reclaim the references.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Array.Clear</code>需要注意这不是删除方法，他是将数组中每个元素重置为元素的默认值。 它将引用类型的元素设置 (包括string) 到的元素 <code>null</code> ，并将值类型的元素设置为下表中显示的默认值。</p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.array.clear?view=net-6.0\">Array.Clear(Array, Int32, Int32) 方法 (System) | Microsoft Docs</a>中注解也提到了</p>\n<p><strong>此方法仅清除元素的值;它不会删除元素本身。 数组具有固定的大小;因此，无法添加或删除元素。</strong></p>\n</blockquote>\n<h3 id=\"Contains\">Contains</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">Contains</span>(<span class=\"params\">T item</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// PERF: IndexOf calls Array.IndexOf, which internally</span></span><br><span class=\"line\">    <span class=\"comment\">// calls EqualityComparer&lt;T&gt;.Default.IndexOf, which</span></span><br><span class=\"line\">    <span class=\"comment\">// is specialized for different types. This</span></span><br><span class=\"line\">    <span class=\"comment\">// boosts performance since instead of making a</span></span><br><span class=\"line\">    <span class=\"comment\">// virtual method call each iteration of the loop,</span></span><br><span class=\"line\">    <span class=\"comment\">// via EqualityComparer&lt;T&gt;.Default.Equals, we</span></span><br><span class=\"line\">    <span class=\"comment\">// only make one virtual call to EqualityComparer.IndexOf.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _size != <span class=\"number\">0</span> &amp;&amp; IndexOf(item) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样这里是通过<code>IndexOf</code>来寻找元素</p>\n<h3 id=\"ToArray\">ToArray</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T[] <span class=\"title\">ToArray</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s_emptyArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T[] array = <span class=\"keyword\">new</span> T[_size];</span><br><span class=\"line\">    Array.Copy(_items, array, _size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>new一个新的数组，拷贝一份返回</p>\n<h3 id=\"Sort\">Sort</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Sort</span>(<span class=\"params\"><span class=\"built_in\">int</span> index, <span class=\"built_in\">int</span> count, IComparer&lt;T&gt;? comparer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowIndexArgumentOutOfRange_NeedNonNegNumException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.count, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size - index &lt; count)</span><br><span class=\"line\">        ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_InvalidOffLen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Array.Sort&lt;T&gt;(_items, index, count, comparer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _version++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>Array.Sort&lt;T&gt;(_items, index, count, comparer)</code>进行排序</p>\n<blockquote>\n<p>这里需要注意的是Sort函数不是单纯的快速排序，官网中同样也提到了，这里我将内容贴出来。<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.array.sort?view=net-6.0#system-array-sort(system-array)\">Array.Sort 方法 (System) | Microsoft Docs</a></p>\n<p>此方法使用的是反省sort(introsort)算法，如下所示：</p>\n<ul>\n<li>如果分区大小小于或等于16个元素，则它将使用 <a href=\"https://en.wikipedia.org/wiki/Insertion_sort\">插入排序</a> 算法</li>\n<li>如果分区超过<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2*log^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>,其中<code>n</code>为输入数组的范围，则使用则使用 <a href=\"https://en.wikipedia.org/wiki/Heapsort\">Heapsort</a> 算法(堆排序)。</li>\n<li>否则，它使用的是<a href=\"https://en.wikipedia.org/wiki/Quicksort\">快速排序</a> 算法</li>\n</ul>\n<p>此实现执行不稳定的排序;也就是说，如果两个元素相等，则可能不会保留它们的顺序。 相反，稳定排序会保留相等元素的顺序。</p>\n<p>此方法是一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog^n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 操作，其中 <code>n</code> 是 <code>length</code>。</p>\n<p>PS：当然如果你点进去并且看的是中文的话，你会发现很明显的翻译错误(狗头)</p>\n</blockquote>\n<h2 id=\"索引器\">索引器</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"keyword\">this</span>[<span class=\"built_in\">int</span> index]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">get</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// Following trick can reduce the range check by one</span></span><br><span class=\"line\">   \t\t <span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt;= (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">   \t\t &#123;</span><br><span class=\"line\">     \t  \t ThrowHelper.ThrowArgumentOutOfRange_IndexException();</span><br><span class=\"line\">   \t\t &#125;</span><br><span class=\"line\">   \t\t<span class=\"keyword\">return</span> _items[index];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">set</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">   \t \t<span class=\"keyword\">if</span> ((<span class=\"built_in\">uint</span>)index &gt;= (<span class=\"built_in\">uint</span>)_size)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">     \t   ThrowHelper.ThrowArgumentOutOfRange_IndexException();</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t_items[index] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    \t_version++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用数组索引获取元素</p>\n<h2 id=\"迭代器\">迭代器</h2>\n<p>先分开讲解源码中比较重要的两个元素<strong>IEnumerable</strong>和<strong>IEnumerator</strong>。</p>\n<h3 id=\"IEnumerable\">IEnumerable</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IEnumerable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\">IEnumerator <span class=\"title\">GetEnumerator</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>公开枚举数，该枚举数支持在非泛型集合上进行简单迭代。(可枚举类型)。</p>\n<p>当<code>foreach</code>遍历可枚举类型的时候，比如<code>List</code>，他会调用<code>GetEnumerator</code>方法来获取Enumerator(枚举数)，接下来从枚举数中请求每一项并且作为迭代变量。</p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable?view=net-6.0\">IEnumerable 接口 (System.Collections) | Microsoft Docs</a></p>\n<h3 id=\"IEnumerator\">IEnumerator</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IEnumerator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">bool</span> <span class=\"title\">MoveNext</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">object</span> Current &#123; <span class=\"keyword\">get</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reset</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>支持对非泛型集合的简单迭代。(枚举数)</p>\n<p>该接口包含三个成员。</p>\n<ol>\n<li><code>bool MoveNext()</code>从集合的一个元素移动到下个元素，同时检查是否遍历完毕</li>\n<li>只读属性<code>Current</code>用于返回当前元素</li>\n<li><code>Reset</code>重置为初始态，一般用于报错(bushi)，最好永远不要调用它，如果要重新开始枚举，重新创建一个新的即可。</li>\n</ol>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator?view=net-6.0\">IEnumerator 接口 (System.Collections) | Microsoft Docs</a></p>\n<h3 id=\"源码\">源码</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Enumerator <span class=\"title\">GetEnumerator</span>(<span class=\"params\"></span>)</span> =&gt; <span class=\"keyword\">new</span> Enumerator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator() =&gt; <span class=\"keyword\">new</span> Enumerator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">IEnumerator IEnumerable.GetEnumerator() =&gt; <span class=\"keyword\">new</span> Enumerator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> Enumerator : IEnumerator&lt;T&gt;, IEnumerator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> List&lt;T&gt; _list;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> _index;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> _version;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T? _current;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">internal</span> <span class=\"title\">Enumerator</span>(<span class=\"params\">List&lt;T&gt; list</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _list = list;</span><br><span class=\"line\">        _index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        _version = list._version;</span><br><span class=\"line\">        _current = <span class=\"literal\">default</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Dispose</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">MoveNext</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        List&lt;T&gt; localList = _list;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_version == localList._version &amp;&amp; ((<span class=\"built_in\">uint</span>)_index &lt; (<span class=\"built_in\">uint</span>)localList._size))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _current = localList._items[_index];</span><br><span class=\"line\">            _index++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> MoveNextRare();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">bool</span> <span class=\"title\">MoveNextRare</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_version != _list._version)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        _index = _list._size + <span class=\"number\">1</span>;</span><br><span class=\"line\">        _current = <span class=\"literal\">default</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T Current =&gt; _current!;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">object</span>? IEnumerator.Current</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_index == <span class=\"number\">0</span> || _index == _list._size + <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> IEnumerator.Reset()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_version != _list._version)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowHelper.ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        _index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        _current = <span class=\"literal\">default</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述模式大致可以简单描述为</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当然具体不是这样的</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> enumerator = list.GetEnumerator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(enumerator.MoveNext())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnumber = enumerator.Current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或许会有人觉得<code>GetEnumerator()</code>有点多此一举,觉得可以像下面这么写也能做到一样的效果</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(list.MoveNext())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tnumber = list.Current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但这样，如果两个循环交错遍历同一个集合，或者是多线程循环，交错的循环将会产生干扰。所以不使用该方法，而是用<code>IEnumerator</code>来支持<code>IEnumerator</code>并且负责维护循环遍历的状态。这样遍历集合便不会产生影响。</p>\n<p>Ps:不是非要实现IEnumerable才能对类型进行遍历。遍历器使用了一个名为&quot;Duck typing&quot;的概念，他会查找一个返回“包含Current属性和MoveNext()方法的一个类型”的GetEnumerator()方法。Duck typing按照名称查找方法，而不依赖接口或者显式方法调用。只有当找不到实现时，才会检查集合是否实现了接口。</p>\n"},{"title":"公共语言基础结构","date":"2022-01-19T09:00:00.000Z","_content":"\n# 公共语言基础结构\n\n## CLI的定义\n\nC#不会直接生成机器码，而是生成**公共中间语言(Common Intermediate Language,CIL)**，之后CIL被转换成处理器能理解的机器码。\n\n但如果要执行代码，仅仅转换为机器码是还不够的。还需要在一个代理的上下文中执行。负责C#程序执行的代理就是**虚拟执行系统(Virtual Execution System，VES)**，也称为**运行时**。它负责加载和运行程序，并在程序执行时提供额外的服务(比如安全性、垃圾回收等)。\n\nCIL和运行时规范包含在一项国际标准中，即**公共语言基础结构(Common Language Infrastructure，CLI)**。\n\n> CLI标准包含以下更详细的规范：\n>\n> - 虚拟执行系统(VES，也就是运行时)\n> - 公共中间语言(Common Intermediate Language，CIL)\n> - 公共语言规范(Common Language Specification, CLS)\n> - 公共类型系统(Common Type System，CTS)\n> - 元数据(Metadata)\n> - 框架(Framework)\n\n## CLI术语缩写\n\n| 缩写      | 定义               | 说明                                                         |\n| --------- | ------------------ | ------------------------------------------------------------ |\n| .NET      | 无                 | 这是微软所实现的CLI,其中包括CLR，CIL以及各种语言——全部都相容于CLS |\n| BCL       | 基类库             | CLI规范的一部分，定义了集合、线程处理、控制台以及用于生成几乎所有程序所需的其他基类 |\n| C#        | 无                 | 一种编程语言。注意C#语言规范独立于CLI标准，也得到了ECMA和ISO标准组织的认可 |\n| CIL（IL） | 公共中间语言       | CLI规范中的一种语言，为可在CLI的实现上执行的代码定义了指令。有时也称为中间语言(IL)或Microsoft IL(MSIL)，以为区别于其他中间语言 |\n| CLI       | 公共语言基础结构   | 这个规范定义了中间语言、基类和行为特征，允许实现人员创建虚拟执行系统和编译器，确保不同的源语言能在公共执行环境的顶部进行互操作 |\n| CLR       | 公共语言运行时     | 微软根据CLI规定的定义实现的运行时                            |\n| CLS       | 公共语言规范       | CLI规范的一部分，定义了源语言必须支持的核心功能子集。只有支持这些特性，才能在基于CLI规范而实现的运行时中执行 |\n| CTS       | 公共类型系统       | 一般要由CLI相容语言来实现的一个标准，定义了编程语言向模块外部公开的类型的表示及行为。包含如何对类型进行合并以构成新类型的一些概念 |\n| FCL       | .NET Framework类库 | 用于构成Microsoft .NET Framework的类库，包含微软事件的BCL以及用于Web开发、数据库访问等的一个大型类库 |\n| VES       | 虚拟执行系统       | 作为代理负责管理为CLI编译的程序的执行                        |\n\n","source":"_posts/公共语言基础结构.md","raw":"---\ntitle: 公共语言基础结构\ndate: 2022-01-19 17:00:00\ntags: c#\ncategories: 语言基础\n\n---\n\n# 公共语言基础结构\n\n## CLI的定义\n\nC#不会直接生成机器码，而是生成**公共中间语言(Common Intermediate Language,CIL)**，之后CIL被转换成处理器能理解的机器码。\n\n但如果要执行代码，仅仅转换为机器码是还不够的。还需要在一个代理的上下文中执行。负责C#程序执行的代理就是**虚拟执行系统(Virtual Execution System，VES)**，也称为**运行时**。它负责加载和运行程序，并在程序执行时提供额外的服务(比如安全性、垃圾回收等)。\n\nCIL和运行时规范包含在一项国际标准中，即**公共语言基础结构(Common Language Infrastructure，CLI)**。\n\n> CLI标准包含以下更详细的规范：\n>\n> - 虚拟执行系统(VES，也就是运行时)\n> - 公共中间语言(Common Intermediate Language，CIL)\n> - 公共语言规范(Common Language Specification, CLS)\n> - 公共类型系统(Common Type System，CTS)\n> - 元数据(Metadata)\n> - 框架(Framework)\n\n## CLI术语缩写\n\n| 缩写      | 定义               | 说明                                                         |\n| --------- | ------------------ | ------------------------------------------------------------ |\n| .NET      | 无                 | 这是微软所实现的CLI,其中包括CLR，CIL以及各种语言——全部都相容于CLS |\n| BCL       | 基类库             | CLI规范的一部分，定义了集合、线程处理、控制台以及用于生成几乎所有程序所需的其他基类 |\n| C#        | 无                 | 一种编程语言。注意C#语言规范独立于CLI标准，也得到了ECMA和ISO标准组织的认可 |\n| CIL（IL） | 公共中间语言       | CLI规范中的一种语言，为可在CLI的实现上执行的代码定义了指令。有时也称为中间语言(IL)或Microsoft IL(MSIL)，以为区别于其他中间语言 |\n| CLI       | 公共语言基础结构   | 这个规范定义了中间语言、基类和行为特征，允许实现人员创建虚拟执行系统和编译器，确保不同的源语言能在公共执行环境的顶部进行互操作 |\n| CLR       | 公共语言运行时     | 微软根据CLI规定的定义实现的运行时                            |\n| CLS       | 公共语言规范       | CLI规范的一部分，定义了源语言必须支持的核心功能子集。只有支持这些特性，才能在基于CLI规范而实现的运行时中执行 |\n| CTS       | 公共类型系统       | 一般要由CLI相容语言来实现的一个标准，定义了编程语言向模块外部公开的类型的表示及行为。包含如何对类型进行合并以构成新类型的一些概念 |\n| FCL       | .NET Framework类库 | 用于构成Microsoft .NET Framework的类库，包含微软事件的BCL以及用于Web开发、数据库访问等的一个大型类库 |\n| VES       | 虚拟执行系统       | 作为代理负责管理为CLI编译的程序的执行                        |\n\n","slug":"公共语言基础结构","published":1,"updated":"2022-05-02T12:54:32.245Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztq9000e2cup8ogj8ceb","content":"<h1 id=\"公共语言基础结构\">公共语言基础结构</h1>\n<h2 id=\"CLI的定义\">CLI的定义</h2>\n<p>C#不会直接生成机器码，而是生成<strong>公共中间语言(Common Intermediate Language,CIL)</strong>，之后CIL被转换成处理器能理解的机器码。</p>\n<p>但如果要执行代码，仅仅转换为机器码是还不够的。还需要在一个代理的上下文中执行。负责C#程序执行的代理就是<strong>虚拟执行系统(Virtual Execution System，VES)</strong>，也称为<strong>运行时</strong>。它负责加载和运行程序，并在程序执行时提供额外的服务(比如安全性、垃圾回收等)。</p>\n<p>CIL和运行时规范包含在一项国际标准中，即<strong>公共语言基础结构(Common Language Infrastructure，CLI)</strong>。</p>\n<blockquote>\n<p>CLI标准包含以下更详细的规范：</p>\n<ul>\n<li>虚拟执行系统(VES，也就是运行时)</li>\n<li>公共中间语言(Common Intermediate Language，CIL)</li>\n<li>公共语言规范(Common Language Specification, CLS)</li>\n<li>公共类型系统(Common Type System，CTS)</li>\n<li>元数据(Metadata)</li>\n<li>框架(Framework)</li>\n</ul>\n</blockquote>\n<h2 id=\"CLI术语缩写\">CLI术语缩写</h2>\n<table>\n<thead>\n<tr>\n<th>缩写</th>\n<th>定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.NET</td>\n<td>无</td>\n<td>这是微软所实现的CLI,其中包括CLR，CIL以及各种语言——全部都相容于CLS</td>\n</tr>\n<tr>\n<td>BCL</td>\n<td>基类库</td>\n<td>CLI规范的一部分，定义了集合、线程处理、控制台以及用于生成几乎所有程序所需的其他基类</td>\n</tr>\n<tr>\n<td>C#</td>\n<td>无</td>\n<td>一种编程语言。注意C#语言规范独立于CLI标准，也得到了ECMA和ISO标准组织的认可</td>\n</tr>\n<tr>\n<td>CIL（IL）</td>\n<td>公共中间语言</td>\n<td>CLI规范中的一种语言，为可在CLI的实现上执行的代码定义了指令。有时也称为中间语言(IL)或Microsoft IL(MSIL)，以为区别于其他中间语言</td>\n</tr>\n<tr>\n<td>CLI</td>\n<td>公共语言基础结构</td>\n<td>这个规范定义了中间语言、基类和行为特征，允许实现人员创建虚拟执行系统和编译器，确保不同的源语言能在公共执行环境的顶部进行互操作</td>\n</tr>\n<tr>\n<td>CLR</td>\n<td>公共语言运行时</td>\n<td>微软根据CLI规定的定义实现的运行时</td>\n</tr>\n<tr>\n<td>CLS</td>\n<td>公共语言规范</td>\n<td>CLI规范的一部分，定义了源语言必须支持的核心功能子集。只有支持这些特性，才能在基于CLI规范而实现的运行时中执行</td>\n</tr>\n<tr>\n<td>CTS</td>\n<td>公共类型系统</td>\n<td>一般要由CLI相容语言来实现的一个标准，定义了编程语言向模块外部公开的类型的表示及行为。包含如何对类型进行合并以构成新类型的一些概念</td>\n</tr>\n<tr>\n<td>FCL</td>\n<td>.NET Framework类库</td>\n<td>用于构成Microsoft .NET Framework的类库，包含微软事件的BCL以及用于Web开发、数据库访问等的一个大型类库</td>\n</tr>\n<tr>\n<td>VES</td>\n<td>虚拟执行系统</td>\n<td>作为代理负责管理为CLI编译的程序的执行</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/wm8CdvX1aHoLPJY.jpg","excerpt":"","more":"<h1 id=\"公共语言基础结构\">公共语言基础结构</h1>\n<h2 id=\"CLI的定义\">CLI的定义</h2>\n<p>C#不会直接生成机器码，而是生成<strong>公共中间语言(Common Intermediate Language,CIL)</strong>，之后CIL被转换成处理器能理解的机器码。</p>\n<p>但如果要执行代码，仅仅转换为机器码是还不够的。还需要在一个代理的上下文中执行。负责C#程序执行的代理就是<strong>虚拟执行系统(Virtual Execution System，VES)</strong>，也称为<strong>运行时</strong>。它负责加载和运行程序，并在程序执行时提供额外的服务(比如安全性、垃圾回收等)。</p>\n<p>CIL和运行时规范包含在一项国际标准中，即<strong>公共语言基础结构(Common Language Infrastructure，CLI)</strong>。</p>\n<blockquote>\n<p>CLI标准包含以下更详细的规范：</p>\n<ul>\n<li>虚拟执行系统(VES，也就是运行时)</li>\n<li>公共中间语言(Common Intermediate Language，CIL)</li>\n<li>公共语言规范(Common Language Specification, CLS)</li>\n<li>公共类型系统(Common Type System，CTS)</li>\n<li>元数据(Metadata)</li>\n<li>框架(Framework)</li>\n</ul>\n</blockquote>\n<h2 id=\"CLI术语缩写\">CLI术语缩写</h2>\n<table>\n<thead>\n<tr>\n<th>缩写</th>\n<th>定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.NET</td>\n<td>无</td>\n<td>这是微软所实现的CLI,其中包括CLR，CIL以及各种语言——全部都相容于CLS</td>\n</tr>\n<tr>\n<td>BCL</td>\n<td>基类库</td>\n<td>CLI规范的一部分，定义了集合、线程处理、控制台以及用于生成几乎所有程序所需的其他基类</td>\n</tr>\n<tr>\n<td>C#</td>\n<td>无</td>\n<td>一种编程语言。注意C#语言规范独立于CLI标准，也得到了ECMA和ISO标准组织的认可</td>\n</tr>\n<tr>\n<td>CIL（IL）</td>\n<td>公共中间语言</td>\n<td>CLI规范中的一种语言，为可在CLI的实现上执行的代码定义了指令。有时也称为中间语言(IL)或Microsoft IL(MSIL)，以为区别于其他中间语言</td>\n</tr>\n<tr>\n<td>CLI</td>\n<td>公共语言基础结构</td>\n<td>这个规范定义了中间语言、基类和行为特征，允许实现人员创建虚拟执行系统和编译器，确保不同的源语言能在公共执行环境的顶部进行互操作</td>\n</tr>\n<tr>\n<td>CLR</td>\n<td>公共语言运行时</td>\n<td>微软根据CLI规定的定义实现的运行时</td>\n</tr>\n<tr>\n<td>CLS</td>\n<td>公共语言规范</td>\n<td>CLI规范的一部分，定义了源语言必须支持的核心功能子集。只有支持这些特性，才能在基于CLI规范而实现的运行时中执行</td>\n</tr>\n<tr>\n<td>CTS</td>\n<td>公共类型系统</td>\n<td>一般要由CLI相容语言来实现的一个标准，定义了编程语言向模块外部公开的类型的表示及行为。包含如何对类型进行合并以构成新类型的一些概念</td>\n</tr>\n<tr>\n<td>FCL</td>\n<td>.NET Framework类库</td>\n<td>用于构成Microsoft .NET Framework的类库，包含微软事件的BCL以及用于Web开发、数据库访问等的一个大型类库</td>\n</tr>\n<tr>\n<td>VES</td>\n<td>虚拟执行系统</td>\n<td>作为代理负责管理为CLI编译的程序的执行</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"xlua踩坑","date":"2022-03-03T15:04:50.000Z","_content":"\n## 打包AB包时XLua报错\n\n和下面这个链接雀氏是同一个问题，但是我clear了五次莫名其妙又打包好了，我不能理解，我大受震撼。尤其是刚好在我搜出这个问题的时候，他打包好了？？\n\n[解决XLua运行正常，但是打包出错问题_CoffeMilk的博客-CSDN博客_xlua 打包报错](https://blog.csdn.net/xiaochenXIHUA/article/details/96910189)\n\n## emmylua使用xlua\n\n因为emmylua的原理是：lua代码中通过`local dbg = require(\"emmy_core\")` 主动加载 emmy_core.dll到宿主程序中，并启动调试内核代码。调试内核通过socket与IDEA/VSCode侧连接通讯。\n\n一般情况下，都会重新自定义`loader`，这里emmy_core并不是一个lua文件，在加载的时候会报错，需要特判。\n\n```csharp\nprivate byte[] MyCustomLoaderFormAB(ref string filepath)\n{\n\tif (filepath.Equals(\"emmy_core\"))\n    {\n        return null;\n    }\n}\n```\n\n调试的时候需要在lua代码入口处插入(可以直接打开插件看具体要插入的信息)\n\n```lua\ndbg.tcpListen('localhost', 9966)\n```\n\n## emmylua智能提示突然失效\n\n解决方案：将xlua从项目移除后重新导入解决。。我不能理解\n","source":"_posts/xlua踩坑.md","raw":"---\ntitle: xlua踩坑\ndate: 2022-03-03 23:04:50\ntags: \n- Unity\n- Lua\ncategories: Unity\n---\n\n## 打包AB包时XLua报错\n\n和下面这个链接雀氏是同一个问题，但是我clear了五次莫名其妙又打包好了，我不能理解，我大受震撼。尤其是刚好在我搜出这个问题的时候，他打包好了？？\n\n[解决XLua运行正常，但是打包出错问题_CoffeMilk的博客-CSDN博客_xlua 打包报错](https://blog.csdn.net/xiaochenXIHUA/article/details/96910189)\n\n## emmylua使用xlua\n\n因为emmylua的原理是：lua代码中通过`local dbg = require(\"emmy_core\")` 主动加载 emmy_core.dll到宿主程序中，并启动调试内核代码。调试内核通过socket与IDEA/VSCode侧连接通讯。\n\n一般情况下，都会重新自定义`loader`，这里emmy_core并不是一个lua文件，在加载的时候会报错，需要特判。\n\n```csharp\nprivate byte[] MyCustomLoaderFormAB(ref string filepath)\n{\n\tif (filepath.Equals(\"emmy_core\"))\n    {\n        return null;\n    }\n}\n```\n\n调试的时候需要在lua代码入口处插入(可以直接打开插件看具体要插入的信息)\n\n```lua\ndbg.tcpListen('localhost', 9966)\n```\n\n## emmylua智能提示突然失效\n\n解决方案：将xlua从项目移除后重新导入解决。。我不能理解\n","slug":"xlua踩坑","published":1,"updated":"2022-03-04T05:51:53.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztqa000g2cupa70nb55g","content":"<h2 id=\"打包AB包时XLua报错\">打包AB包时XLua报错</h2>\n<p>和下面这个链接雀氏是同一个问题，但是我clear了五次莫名其妙又打包好了，我不能理解，我大受震撼。尤其是刚好在我搜出这个问题的时候，他打包好了？？</p>\n<p><a href=\"https://blog.csdn.net/xiaochenXIHUA/article/details/96910189\">解决XLua运行正常，但是打包出错问题_CoffeMilk的博客-CSDN博客_xlua 打包报错</a></p>\n<h2 id=\"emmylua使用xlua\">emmylua使用xlua</h2>\n<p>因为emmylua的原理是：lua代码中通过<code>local dbg = require(&quot;emmy_core&quot;)</code> 主动加载 emmy_core.dll到宿主程序中，并启动调试内核代码。调试内核通过socket与IDEA/VSCode侧连接通讯。</p>\n<p>一般情况下，都会重新自定义<code>loader</code>，这里emmy_core并不是一个lua文件，在加载的时候会报错，需要特判。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">byte</span>[] <span class=\"title\">MyCustomLoaderFormAB</span>(<span class=\"params\"><span class=\"keyword\">ref</span> <span class=\"built_in\">string</span> filepath</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (filepath.Equals(<span class=\"string\">&quot;emmy_core&quot;</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调试的时候需要在lua代码入口处插入(可以直接打开插件看具体要插入的信息)</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">dbg.tcpListen(<span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"number\">9966</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"emmylua智能提示突然失效\">emmylua智能提示突然失效</h2>\n<p>解决方案：将xlua从项目移除后重新导入解决。。我不能理解</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/qvfB7Vk1hZiAJ3G.jpg","excerpt":"","more":"<h2 id=\"打包AB包时XLua报错\">打包AB包时XLua报错</h2>\n<p>和下面这个链接雀氏是同一个问题，但是我clear了五次莫名其妙又打包好了，我不能理解，我大受震撼。尤其是刚好在我搜出这个问题的时候，他打包好了？？</p>\n<p><a href=\"https://blog.csdn.net/xiaochenXIHUA/article/details/96910189\">解决XLua运行正常，但是打包出错问题_CoffeMilk的博客-CSDN博客_xlua 打包报错</a></p>\n<h2 id=\"emmylua使用xlua\">emmylua使用xlua</h2>\n<p>因为emmylua的原理是：lua代码中通过<code>local dbg = require(&quot;emmy_core&quot;)</code> 主动加载 emmy_core.dll到宿主程序中，并启动调试内核代码。调试内核通过socket与IDEA/VSCode侧连接通讯。</p>\n<p>一般情况下，都会重新自定义<code>loader</code>，这里emmy_core并不是一个lua文件，在加载的时候会报错，需要特判。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">byte</span>[] <span class=\"title\">MyCustomLoaderFormAB</span>(<span class=\"params\"><span class=\"keyword\">ref</span> <span class=\"built_in\">string</span> filepath</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (filepath.Equals(<span class=\"string\">&quot;emmy_core&quot;</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调试的时候需要在lua代码入口处插入(可以直接打开插件看具体要插入的信息)</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">dbg.tcpListen(<span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"number\">9966</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"emmylua智能提示突然失效\">emmylua智能提示突然失效</h2>\n<p>解决方案：将xlua从项目移除后重新导入解决。。我不能理解</p>\n"},{"title":"剑指Offer","date":"2022-07-10T18:55:27.000Z","_content":"\n# 第一天\n\n## [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)\n\n### 题解\n\n```csharp\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.AppendTail(value);\n * int param_2 = obj.DeleteHead();\n */\npublic class CQueue\n{\n    private Stack<int> _a, _b;\n\n    public CQueue()\n    {\n        _a = new Stack<int>();\n        _b = new Stack<int>();\n    }\n\n    public void AppendTail(int value)\n    {\n        _a.Push(value);\n    }\n\n    public int DeleteHead()\n    {\n        if (_b.Count > 0)\n            return _b.Pop();\n        if (_a.Count == 0)\n            return -1;\n        while (_a.Count > 0)\n            _b.Push(_a.Pop());\n        return _b.Pop();\n    }\n}\n```\n\n### 后记\n\n没什么，经典双栈拼接队列。\n\n## [剑指 Offer 30. 包含min函数的栈 - 力扣（LeetCode）](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)\n\n### 题解\n\n```csharp\npublic class MinStack\n{\n    private Stack<int> _a, _minStack;\n\n    /** initialize your data structure here. */\n    public MinStack()\n    {\n        _a = new Stack<int>();\n        _minStack = new Stack<int>();\n    }\n\n\n    public void Push(int x)\n    {\n        _a.Push(x);\n        if (_minStack.Count == 0 || _minStack.Peek() >= x)\n            _minStack.Push(x);\n    }\n\n    public void Pop()\n    {\n        if (_a.Pop() == _minStack.Peek())\n        {\n            _minStack.Pop();\n        }\n    }\n\n    public int Top()\n    {\n        return _a.Peek();\n    }\n\n    public int Min()\n    {\n        return _minStack.Peek();\n    }\n}\n```\n\n### 后记\n\n其实这个玩意 最好还是直接记录一下，但是感觉没必要。\n\n# 第二天\n\n## [剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode）](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\n\n## 题解\n\n```csharp\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution\n{\n    private Stack<int> _stack = new Stack<int>();\n\n    public int[] ReversePrint(ListNode head)\n    {\n        while (head != null)\n        {\n            _stack.Push(head.val);\n            head = head.next;\n        }\n\n        int[] res = new int[_stack.Count];\n        for (int i = 0; i < res.Length; i++)\n            res[i] = _stack.Pop();\n        return res;\n    }\n}\n```\n\n## 后记\n\n最大的难点居然是有人`Length`拼了四次才拼对。\n\n## [剑指 Offer 24. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)\n\n### 题解\n\n```csharp\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur != null)\n        {\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n```\n\n### 后记\n\n我是废物！\n\n## [剑指 Offer 35. 复杂链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n\n### 题解\n\n#### 哈希表 + 迭代\n\n```csharp\n/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public Node next;\n    public Node random;\n    \n    public Node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\n\npublic class Solution\n{\n    private Dictionary<Node, Node> _nodeDic;\n\n    public Node CopyRandomList(Node head)\n    {\n        _nodeDic = new Dictionary<Node, Node>();\n\n        if (head == null)\n        {\n            return null;\n        }\n\n        Node tempNode = head;\n\n        while (tempNode != null)\n        {\n            _nodeDic.Add(tempNode, new Node(tempNode.val));\n            tempNode = tempNode.next;\n        }\n\n        tempNode = head;\n        while (tempNode != null)\n        {\n            if (tempNode.next != null)\n                _nodeDic[tempNode].next = _nodeDic[tempNode.next];\n            if (tempNode.random != null)\n                _nodeDic[tempNode].random = _nodeDic[tempNode.random];\n            tempNode = tempNode.next;\n        }\n\n        return _nodeDic[head];\n    }\n}\n```\n\n#### 拼接 + 拆分\n\n```csharp\n    public Node CopyRandomList(Node head)\n    {\n        if (head == null)\n            return null;\n\n        Node tempNode = head;\n        while (tempNode != null)\n        {\n            Node temp = new Node(tempNode.val);\n            temp.next = tempNode.next;\n            tempNode.next = temp;\n\n            tempNode = tempNode.next.next;\n        }\n\n        tempNode = head;\n        while (tempNode != null)\n        {\n            if (tempNode.random != null)\n                tempNode.next.random = tempNode.random.next;\n            tempNode = tempNode.next.next;\n        }\n\n        Node cur = head.next;\n        Node res = head.next;\n        tempNode = head;\n\n        while (cur.next != null)\n        {\n            tempNode.next = cur.next;\n            cur.next = cur.next.next;\n\n            cur = cur.next;\n            tempNode = tempNode.next;\n        }\n\n        tempNode.next = null;\n        return res;\n    }\n}\n```\n\n### 后记\n\n第一种解法偏常规，主要需要判空。\n\n第二种解法你会发现题目十分阴间，比如37行的`tempNode.next = null`，如果没有这一句话，该题目错误。因为你必须还原原链表，但是我明明只需要返回新链表啊！！你怎么能检测原链表啊！！！你是怎么做到的啊。**第二种解法还是需要多看看。**\n\n# 第三天\n\n## [剑指 Offer 05. 替换空格 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)\n\n### 硬写\n\n```csharp\npublic class Solution\n{\n    public string ReplaceSpace(string s)\n    {\n        StringBuilder sb = new StringBuilder();\n        foreach (char c in s)\n        {\n            if (c == ' ')\n                sb.Append(\"%20\");\n            else\n                sb.Append(c);\n        }\n\n        return sb.ToString();\n    }\n}\n```\n\n### 后记\n\n没什么东西，标准题解的语言中大部分没有可变字符串。我是懒鬼，我选择可变。\n\n## [剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n### 硬写\n\n```csharp\npublic class Solution\n{\n    public string ReverseLeftWords(string s, int n)\n    {\n        StringBuilder sb = new StringBuilder();\n        for (int i = n; i < n + s.Length; i++)\n        {\n            sb.Append(s[i % s.Length]);\n        }\n\n        return sb.ToString();\n    }\n}\n```\n\n### 后记\n\nsb yyds。\n\n# 第四天\n\n## [剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int FindRepeatNumber(int[] nums)\n    {\n        int i = 0;\n        while (i < nums.Length)\n        {\n            // 当前索引满足条件\n            if (nums[i] == i)\n            {\n                i++;\n                continue;\n            }\n\n            if (nums[nums[i]] == nums[i])\n                return nums[i];\n            (nums[nums[i]], nums[i]) = (nums[i], nums[nums[i]]);\n        }\n\n        return 0;\n    }\n}\n```\n\n### 后记\n\n想笑啊。排行最优的算法是桶排序。\n\n## [剑指 Offer 53 - I. 在排序数组中查找数字 I - 力扣（LeetCode）](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution {\n    public int Search(int[] nums, int target) {\n        int left = 0, right = nums.Length - 1;\n        while(left <= right)\n        {\n            int mid = right - (right - left) / 2;\n            if(nums[mid] <= target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n\n        int resRight = left;\n        if(right >= 0 && nums[right] != target)\n            return 0;\n        left = 0;\n        right = nums.Length - 1;\n        while(left <= right)\n        {\n            int mid = right - (right - left) / 2;\n            if(nums[mid] < target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n\n        int resLeft = right;\n        return resRight - resLeft - 1;\n    }\n}\n```\n\n### 后记\n\n二分好难啊。但是？这玩意在leetcode不如一句`return nums.Count(num => num == target);`，Linq太强啦呜呜呜。\n\n## [剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int MissingNumber(int[] nums)\n    {\n        int left = 0, right = nums.Length - 1;\n        while (left <= right)\n        {\n            int mid = right - (right - left) / 2;\n            if (nums[mid] == mid)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n\n        return left;\n    }\n}\n```\n\n### 后记\n\n最快的还是暴力，我想笑啊。\n\n# 第五天\n\n## [剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode）](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public bool FindNumberIn2DArray(int[][] matrix, int target)\n    {\n        if (matrix == null || matrix.Length == 0)\n            return false;\n\n        int x = 0;\n        int y = matrix[0].Length - 1;\n\n        while (x < matrix.Length && y >= 0)\n        {\n            if (matrix[x][y] == target)\n                return true;\n            else if (matrix[x][y] < target)\n                x++;\n            else\n                y--;\n        }\n\n        return false;\n    }\n}\n```\n\n### 后记\n\n我好烦判空啊！\n\n## [剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int MinArray(int[] numbers)\n    {\n        int left = 0;\n        int right = numbers.Length - 1;\n\n        while (left < right)\n        {\n            int mid = left - (left - right) / 2;\n\n            if (numbers[mid] < numbers[right])\n            {\n                right = mid;\n            }\n            else if (numbers[mid] > numbers[right])\n            {\n                left = mid + 1;\n            }\n            else\n            {\n                right--;\n            }\n        }\n\n        return numbers[left];\n    }\n}\n```\n\n### 后记\n\n呜呜呜，我真的不会二分。\n\n## [剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution {\n    public char FirstUniqChar(string s) {\n        if (s.Length != 0) {\n            Dictionary<char, bool> dic = new Dictionary<char, bool>();\n            foreach(char c in s) {\n                if (dic.ContainsKey(c)) \n                    dic[c] = false;\n                else \n                    dic.Add(c, true);\n            }\n            foreach (var d in dic)\n            {\n                if (d.Value) \n                    return d.Key;\n            }\n        }\n        return ' ';\n    }\n}\n```\n\n### 后记\n\n没什么，感觉不如原神。\n\n# 第六天\n\n## [剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int[] LevelOrder(TreeNode root)\n    {\n        if (root == null)\n            return new int[0];\n\n        Queue<TreeNode> treeNodes = new Queue<TreeNode>();\n        List<int> res = new List<int>();\n        treeNodes.Enqueue(root);\n        while (treeNodes.Count > 0)\n        {\n            TreeNode now = treeNodes.Dequeue();\n            res.Add(now.val);\n            if (now.left != null)\n                treeNodes.Enqueue(now.left);\n            if (now.right != null)\n                treeNodes.Enqueue(now.right);\n        }\n\n        return res.ToArray();\n    }\n}\n```\n\n### 后记\n\n`treeNodes.Enqueue(root);` 添加元素\n\n`treeNodes.Dequeue();` 取出元素\n\n狠狠牢记API\n\n## [剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public IList<IList<int>> LevelOrder(TreeNode root)\n    {\n        var ans = new List<IList<int>>();\n        if (root == null) return ans;\n        var q = new Queue<TreeNode>();\n        q.Enqueue(root);\n        while (q.Count > 0)\n        {\n            var level = new List<int>();\n            for (int cnt = q.Count; cnt > 0; cnt--)\n            {\n                var cur = q.Dequeue();\n                level.Add(cur.val);\n                if (cur.left != null) q.Enqueue(cur.left);\n                if (cur.right != null) q.Enqueue(cur.right);\n            }\n\n            ans.Add(level);\n        }\n\n        return ans;\n    }\n}\n```\n\n### 后记\n\n这个BFS有点意思啊。\n\n## [剑指 Offer 32 - III. 从上到下打印二叉树 III - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public IList<IList<int>> LevelOrder(TreeNode root)\n    {\n        List<IList<int>> list = new List<IList<int>>();\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        if (root != null)\n        {\n            queue.Enqueue(root);\n        }\n\n        while (queue.Count > 0)\n        {\n            List<int> tempList = new List<int>();\n            int count = queue.Count;\n            for (int i = 0; i < count; i++)\n            {\n                TreeNode tree = queue.Dequeue();\n                if (list.Count % 2 == 0)\n                {\n                    tempList.Add(tree.val);\n                }\n                else\n                {\n                    tempList.Insert(0, tree.val);\n                }\n\n                if (tree.left != null)\n                {\n                    queue.Enqueue(tree.left);\n                }\n\n                if (tree.right != null)\n                {\n                    queue.Enqueue(tree.right);\n                }\n            }\n\n            list.Add(tempList);\n        }\n\n        return list;\n    }\n}\n```\n\n### 后记\n\n其实今天这几个题，都是BFS。。。\n","source":"_posts/剑指Offer.md","raw":"---\ntitle: 剑指Offer\ndate: 2022-07-11 02:55:27\ntags: 算法\ncategories: 计算机基础知识\n---\n\n# 第一天\n\n## [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)\n\n### 题解\n\n```csharp\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.AppendTail(value);\n * int param_2 = obj.DeleteHead();\n */\npublic class CQueue\n{\n    private Stack<int> _a, _b;\n\n    public CQueue()\n    {\n        _a = new Stack<int>();\n        _b = new Stack<int>();\n    }\n\n    public void AppendTail(int value)\n    {\n        _a.Push(value);\n    }\n\n    public int DeleteHead()\n    {\n        if (_b.Count > 0)\n            return _b.Pop();\n        if (_a.Count == 0)\n            return -1;\n        while (_a.Count > 0)\n            _b.Push(_a.Pop());\n        return _b.Pop();\n    }\n}\n```\n\n### 后记\n\n没什么，经典双栈拼接队列。\n\n## [剑指 Offer 30. 包含min函数的栈 - 力扣（LeetCode）](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)\n\n### 题解\n\n```csharp\npublic class MinStack\n{\n    private Stack<int> _a, _minStack;\n\n    /** initialize your data structure here. */\n    public MinStack()\n    {\n        _a = new Stack<int>();\n        _minStack = new Stack<int>();\n    }\n\n\n    public void Push(int x)\n    {\n        _a.Push(x);\n        if (_minStack.Count == 0 || _minStack.Peek() >= x)\n            _minStack.Push(x);\n    }\n\n    public void Pop()\n    {\n        if (_a.Pop() == _minStack.Peek())\n        {\n            _minStack.Pop();\n        }\n    }\n\n    public int Top()\n    {\n        return _a.Peek();\n    }\n\n    public int Min()\n    {\n        return _minStack.Peek();\n    }\n}\n```\n\n### 后记\n\n其实这个玩意 最好还是直接记录一下，但是感觉没必要。\n\n# 第二天\n\n## [剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode）](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\n\n## 题解\n\n```csharp\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution\n{\n    private Stack<int> _stack = new Stack<int>();\n\n    public int[] ReversePrint(ListNode head)\n    {\n        while (head != null)\n        {\n            _stack.Push(head.val);\n            head = head.next;\n        }\n\n        int[] res = new int[_stack.Count];\n        for (int i = 0; i < res.Length; i++)\n            res[i] = _stack.Pop();\n        return res;\n    }\n}\n```\n\n## 后记\n\n最大的难点居然是有人`Length`拼了四次才拼对。\n\n## [剑指 Offer 24. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)\n\n### 题解\n\n```csharp\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur != null)\n        {\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n}\n```\n\n### 后记\n\n我是废物！\n\n## [剑指 Offer 35. 复杂链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n\n### 题解\n\n#### 哈希表 + 迭代\n\n```csharp\n/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public Node next;\n    public Node random;\n    \n    public Node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\n\npublic class Solution\n{\n    private Dictionary<Node, Node> _nodeDic;\n\n    public Node CopyRandomList(Node head)\n    {\n        _nodeDic = new Dictionary<Node, Node>();\n\n        if (head == null)\n        {\n            return null;\n        }\n\n        Node tempNode = head;\n\n        while (tempNode != null)\n        {\n            _nodeDic.Add(tempNode, new Node(tempNode.val));\n            tempNode = tempNode.next;\n        }\n\n        tempNode = head;\n        while (tempNode != null)\n        {\n            if (tempNode.next != null)\n                _nodeDic[tempNode].next = _nodeDic[tempNode.next];\n            if (tempNode.random != null)\n                _nodeDic[tempNode].random = _nodeDic[tempNode.random];\n            tempNode = tempNode.next;\n        }\n\n        return _nodeDic[head];\n    }\n}\n```\n\n#### 拼接 + 拆分\n\n```csharp\n    public Node CopyRandomList(Node head)\n    {\n        if (head == null)\n            return null;\n\n        Node tempNode = head;\n        while (tempNode != null)\n        {\n            Node temp = new Node(tempNode.val);\n            temp.next = tempNode.next;\n            tempNode.next = temp;\n\n            tempNode = tempNode.next.next;\n        }\n\n        tempNode = head;\n        while (tempNode != null)\n        {\n            if (tempNode.random != null)\n                tempNode.next.random = tempNode.random.next;\n            tempNode = tempNode.next.next;\n        }\n\n        Node cur = head.next;\n        Node res = head.next;\n        tempNode = head;\n\n        while (cur.next != null)\n        {\n            tempNode.next = cur.next;\n            cur.next = cur.next.next;\n\n            cur = cur.next;\n            tempNode = tempNode.next;\n        }\n\n        tempNode.next = null;\n        return res;\n    }\n}\n```\n\n### 后记\n\n第一种解法偏常规，主要需要判空。\n\n第二种解法你会发现题目十分阴间，比如37行的`tempNode.next = null`，如果没有这一句话，该题目错误。因为你必须还原原链表，但是我明明只需要返回新链表啊！！你怎么能检测原链表啊！！！你是怎么做到的啊。**第二种解法还是需要多看看。**\n\n# 第三天\n\n## [剑指 Offer 05. 替换空格 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)\n\n### 硬写\n\n```csharp\npublic class Solution\n{\n    public string ReplaceSpace(string s)\n    {\n        StringBuilder sb = new StringBuilder();\n        foreach (char c in s)\n        {\n            if (c == ' ')\n                sb.Append(\"%20\");\n            else\n                sb.Append(c);\n        }\n\n        return sb.ToString();\n    }\n}\n```\n\n### 后记\n\n没什么东西，标准题解的语言中大部分没有可变字符串。我是懒鬼，我选择可变。\n\n## [剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n### 硬写\n\n```csharp\npublic class Solution\n{\n    public string ReverseLeftWords(string s, int n)\n    {\n        StringBuilder sb = new StringBuilder();\n        for (int i = n; i < n + s.Length; i++)\n        {\n            sb.Append(s[i % s.Length]);\n        }\n\n        return sb.ToString();\n    }\n}\n```\n\n### 后记\n\nsb yyds。\n\n# 第四天\n\n## [剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int FindRepeatNumber(int[] nums)\n    {\n        int i = 0;\n        while (i < nums.Length)\n        {\n            // 当前索引满足条件\n            if (nums[i] == i)\n            {\n                i++;\n                continue;\n            }\n\n            if (nums[nums[i]] == nums[i])\n                return nums[i];\n            (nums[nums[i]], nums[i]) = (nums[i], nums[nums[i]]);\n        }\n\n        return 0;\n    }\n}\n```\n\n### 后记\n\n想笑啊。排行最优的算法是桶排序。\n\n## [剑指 Offer 53 - I. 在排序数组中查找数字 I - 力扣（LeetCode）](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution {\n    public int Search(int[] nums, int target) {\n        int left = 0, right = nums.Length - 1;\n        while(left <= right)\n        {\n            int mid = right - (right - left) / 2;\n            if(nums[mid] <= target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n\n        int resRight = left;\n        if(right >= 0 && nums[right] != target)\n            return 0;\n        left = 0;\n        right = nums.Length - 1;\n        while(left <= right)\n        {\n            int mid = right - (right - left) / 2;\n            if(nums[mid] < target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n\n        int resLeft = right;\n        return resRight - resLeft - 1;\n    }\n}\n```\n\n### 后记\n\n二分好难啊。但是？这玩意在leetcode不如一句`return nums.Count(num => num == target);`，Linq太强啦呜呜呜。\n\n## [剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int MissingNumber(int[] nums)\n    {\n        int left = 0, right = nums.Length - 1;\n        while (left <= right)\n        {\n            int mid = right - (right - left) / 2;\n            if (nums[mid] == mid)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n\n        return left;\n    }\n}\n```\n\n### 后记\n\n最快的还是暴力，我想笑啊。\n\n# 第五天\n\n## [剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode）](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public bool FindNumberIn2DArray(int[][] matrix, int target)\n    {\n        if (matrix == null || matrix.Length == 0)\n            return false;\n\n        int x = 0;\n        int y = matrix[0].Length - 1;\n\n        while (x < matrix.Length && y >= 0)\n        {\n            if (matrix[x][y] == target)\n                return true;\n            else if (matrix[x][y] < target)\n                x++;\n            else\n                y--;\n        }\n\n        return false;\n    }\n}\n```\n\n### 后记\n\n我好烦判空啊！\n\n## [剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int MinArray(int[] numbers)\n    {\n        int left = 0;\n        int right = numbers.Length - 1;\n\n        while (left < right)\n        {\n            int mid = left - (left - right) / 2;\n\n            if (numbers[mid] < numbers[right])\n            {\n                right = mid;\n            }\n            else if (numbers[mid] > numbers[right])\n            {\n                left = mid + 1;\n            }\n            else\n            {\n                right--;\n            }\n        }\n\n        return numbers[left];\n    }\n}\n```\n\n### 后记\n\n呜呜呜，我真的不会二分。\n\n## [剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution {\n    public char FirstUniqChar(string s) {\n        if (s.Length != 0) {\n            Dictionary<char, bool> dic = new Dictionary<char, bool>();\n            foreach(char c in s) {\n                if (dic.ContainsKey(c)) \n                    dic[c] = false;\n                else \n                    dic.Add(c, true);\n            }\n            foreach (var d in dic)\n            {\n                if (d.Value) \n                    return d.Key;\n            }\n        }\n        return ' ';\n    }\n}\n```\n\n### 后记\n\n没什么，感觉不如原神。\n\n# 第六天\n\n## [剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public int[] LevelOrder(TreeNode root)\n    {\n        if (root == null)\n            return new int[0];\n\n        Queue<TreeNode> treeNodes = new Queue<TreeNode>();\n        List<int> res = new List<int>();\n        treeNodes.Enqueue(root);\n        while (treeNodes.Count > 0)\n        {\n            TreeNode now = treeNodes.Dequeue();\n            res.Add(now.val);\n            if (now.left != null)\n                treeNodes.Enqueue(now.left);\n            if (now.right != null)\n                treeNodes.Enqueue(now.right);\n        }\n\n        return res.ToArray();\n    }\n}\n```\n\n### 后记\n\n`treeNodes.Enqueue(root);` 添加元素\n\n`treeNodes.Dequeue();` 取出元素\n\n狠狠牢记API\n\n## [剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public IList<IList<int>> LevelOrder(TreeNode root)\n    {\n        var ans = new List<IList<int>>();\n        if (root == null) return ans;\n        var q = new Queue<TreeNode>();\n        q.Enqueue(root);\n        while (q.Count > 0)\n        {\n            var level = new List<int>();\n            for (int cnt = q.Count; cnt > 0; cnt--)\n            {\n                var cur = q.Dequeue();\n                level.Add(cur.val);\n                if (cur.left != null) q.Enqueue(cur.left);\n                if (cur.right != null) q.Enqueue(cur.right);\n            }\n\n            ans.Add(level);\n        }\n\n        return ans;\n    }\n}\n```\n\n### 后记\n\n这个BFS有点意思啊。\n\n## [剑指 Offer 32 - III. 从上到下打印二叉树 III - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)\n\n### 题解\n\n```csharp\npublic class Solution\n{\n    public IList<IList<int>> LevelOrder(TreeNode root)\n    {\n        List<IList<int>> list = new List<IList<int>>();\n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        if (root != null)\n        {\n            queue.Enqueue(root);\n        }\n\n        while (queue.Count > 0)\n        {\n            List<int> tempList = new List<int>();\n            int count = queue.Count;\n            for (int i = 0; i < count; i++)\n            {\n                TreeNode tree = queue.Dequeue();\n                if (list.Count % 2 == 0)\n                {\n                    tempList.Add(tree.val);\n                }\n                else\n                {\n                    tempList.Insert(0, tree.val);\n                }\n\n                if (tree.left != null)\n                {\n                    queue.Enqueue(tree.left);\n                }\n\n                if (tree.right != null)\n                {\n                    queue.Enqueue(tree.right);\n                }\n            }\n\n            list.Add(tempList);\n        }\n\n        return list;\n    }\n}\n```\n\n### 后记\n\n其实今天这几个题，都是BFS。。。\n","slug":"剑指Offer","published":1,"updated":"2022-07-16T16:33:32.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztqc000l2cup7y6o7bt7","content":"<h1 id=\"第一天\">第一天</h1>\n<h2 id=\"剑指-Offer-09-用两个栈实现队列\"><a href=\"https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\">剑指 Offer 09. 用两个栈实现队列</a></h2>\n<h3 id=\"题解\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * CQueue obj = new CQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.AppendTail(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.DeleteHead();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CQueue</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;<span class=\"built_in\">int</span>&gt; _a, _b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CQueue</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        _b = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AppendTail</span>(<span class=\"params\"><span class=\"built_in\">int</span> <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a.Push(<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">DeleteHead</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_b.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _b.Pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_a.Count == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (_a.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            _b.Push(_a.Pop());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _b.Pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记\">后记</h3>\n<p>没什么，经典双栈拼接队列。</p>\n<h2 id=\"剑指-Offer-30-包含min函数的栈-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/\">剑指 Offer 30. 包含min函数的栈 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-2\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MinStack</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;<span class=\"built_in\">int</span>&gt; _a, _minStack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        _minStack = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Push</span>(<span class=\"params\"><span class=\"built_in\">int</span> x</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a.Push(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_minStack.Count == <span class=\"number\">0</span> || _minStack.Peek() &gt;= x)</span><br><span class=\"line\">            _minStack.Push(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Pop</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_a.Pop() == _minStack.Peek())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _minStack.Pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Top</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _a.Peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Min</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _minStack.Peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-2\">后记</h3>\n<p>其实这个玩意 最好还是直接记录一下，但是感觉没必要。</p>\n<h1 id=\"第二天\">第二天</h1>\n<h2 id=\"剑指-Offer-06-从尾到头打印链表-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\">剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode）</a></h2>\n<h2 id=\"题解-3\">题解</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">int</span>&gt; _stack</span> = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">ReversePrint</span>(<span class=\"params\">ListNode head</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _stack.Push(head.val);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[_stack.Count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; res.Length; i++)</span><br><span class=\"line\">            res[i] = _stack.Pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记-3\">后记</h2>\n<p>最大的难点居然是有人<code>Length</code>拼了四次才拼对。</p>\n<h2 id=\"剑指-Offer-24-反转链表-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/\">剑指 Offer 24. 反转链表 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-4\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">ReverseList</span>(<span class=\"params\">ListNode head</span>)</span> &#123;</span><br><span class=\"line\">        ListNode pre = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode temp = cur.next;</span><br><span class=\"line\">            cur.next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-4\">后记</h3>\n<p>我是废物！</p>\n<h2 id=\"剑指-Offer-35-复杂链表的复制-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/\">剑指 Offer 35. 复杂链表的复制 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-5\">题解</h3>\n<h4 id=\"哈希表-迭代\">哈希表 + 迭代</h4>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">public class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    public int val;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node next;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node random;</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        next = null;</span></span><br><span class=\"line\"><span class=\"comment\">        random = null;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;Node, Node&gt; _nodeDic;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">CopyRandomList</span>(<span class=\"params\">Node head</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _nodeDic = <span class=\"keyword\">new</span> Dictionary&lt;Node, Node&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node tempNode = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _nodeDic.Add(tempNode, <span class=\"keyword\">new</span> Node(tempNode.val));</span><br><span class=\"line\">            tempNode = tempNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tempNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tempNode.next != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                _nodeDic[tempNode].next = _nodeDic[tempNode.next];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tempNode.random != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                _nodeDic[tempNode].random = _nodeDic[tempNode.random];</span><br><span class=\"line\">            tempNode = tempNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _nodeDic[head];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拼接-拆分\">拼接 + 拆分</h4>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">CopyRandomList</span>(<span class=\"params\">Node head</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node tempNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Node temp = <span class=\"keyword\">new</span> Node(tempNode.val);</span><br><span class=\"line\">            temp.next = tempNode.next;</span><br><span class=\"line\">            tempNode.next = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">            tempNode = tempNode.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tempNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tempNode.random != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                tempNode.next.random = tempNode.random.next;</span><br><span class=\"line\">            tempNode = tempNode.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node cur = head.next;</span><br><span class=\"line\">        Node res = head.next;</span><br><span class=\"line\">        tempNode = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.next != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempNode.next = cur.next;</span><br><span class=\"line\">            cur.next = cur.next.next;</span><br><span class=\"line\"></span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            tempNode = tempNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tempNode.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-5\">后记</h3>\n<p>第一种解法偏常规，主要需要判空。</p>\n<p>第二种解法你会发现题目十分阴间，比如37行的<code>tempNode.next = null</code>，如果没有这一句话，该题目错误。因为你必须还原原链表，但是我明明只需要返回新链表啊！！你怎么能检测原链表啊！！！你是怎么做到的啊。<strong>第二种解法还是需要多看看。</strong></p>\n<h1 id=\"第三天\">第三天</h1>\n<h2 id=\"剑指-Offer-05-替换空格-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></h2>\n<h3 id=\"硬写\">硬写</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReplaceSpace</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> s)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                sb.Append(<span class=\"string\">&quot;%20&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                sb.Append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-6\">后记</h3>\n<p>没什么东西，标准题解的语言中大部分没有可变字符串。我是懒鬼，我选择可变。</p>\n<h2 id=\"剑指-Offer-58-II-左旋转字符串-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></h2>\n<h3 id=\"硬写-2\">硬写</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReverseLeftWords</span>(<span class=\"params\"><span class=\"built_in\">string</span> s, <span class=\"built_in\">int</span> n</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = n; i &lt; n + s.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sb.Append(s[i % s.Length]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-7\">后记</h3>\n<p>sb yyds。</p>\n<h1 id=\"第四天\">第四天</h1>\n<h2 id=\"剑指-Offer-03-数组中重复的数字-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\">剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-6\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FindRepeatNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; nums.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前索引满足条件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[nums[i]] == nums[i])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">            (nums[nums[i]], nums[i]) = (nums[i], nums[nums[i]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-8\">后记</h3>\n<p>想笑啊。排行最优的算法是桶排序。</p>\n<h2 id=\"剑指-Offer-53-I-在排序数组中查找数字-I-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/\">剑指 Offer 53 - I. 在排序数组中查找数字 I - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-7\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Search</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums, <span class=\"built_in\">int</span> target</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>, right = nums.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = right - (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt;= target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> resRight = left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right &gt;= <span class=\"number\">0</span> &amp;&amp; nums[right] != target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        right = nums.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = right - (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> resLeft = right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resRight - resLeft - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-9\">后记</h3>\n<p>二分好难啊。但是？这玩意在leetcode不如一句<code>return nums.Count(num =&gt; num == target);</code>，Linq太强啦呜呜呜。</p>\n<h2 id=\"剑指-Offer-53-II-0～n-1中缺失的数字-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/\">剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-8\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MissingNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>, right = nums.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = right - (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == mid)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-10\">后记</h3>\n<p>最快的还是暴力，我想笑啊。</p>\n<h1 id=\"第五天\">第五天</h1>\n<h2 id=\"剑指-Offer-04-二维数组中的查找-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\">剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-9\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">FindNumberIn2DArray</span>(<span class=\"params\"><span class=\"built_in\">int</span>[][] matrix, <span class=\"built_in\">int</span> target</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"literal\">null</span> || matrix.Length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> y = matrix[<span class=\"number\">0</span>].Length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x &lt; matrix.Length &amp;&amp; y &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[x][y] == target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (matrix[x][y] &lt; target)</span><br><span class=\"line\">                x++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                y--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-11\">后记</h3>\n<p>我好烦判空啊！</p>\n<h2 id=\"剑指-Offer-11-旋转数组的最小数字-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\">剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-10\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MinArray</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] numbers</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> right = numbers.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = left - (left - right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (numbers[mid] &lt; numbers[right])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numbers[mid] &gt; numbers[right])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-12\">后记</h3>\n<p>呜呜呜，我真的不会二分。</p>\n<h2 id=\"剑指-Offer-50-第一个只出现一次的字符-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\">剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-11\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">char</span> <span class=\"title\">FirstUniqChar</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.Length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Dictionary&lt;<span class=\"built_in\">char</span>, <span class=\"built_in\">bool</span>&gt; dic = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">char</span>, <span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">foreach</span>(<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> s) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dic.ContainsKey(c)) </span><br><span class=\"line\">                    dic[c] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    dic.Add(c, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> d <span class=\"keyword\">in</span> dic)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (d.Value) </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> d.Key;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-13\">后记</h3>\n<p>没什么，感觉不如原神。</p>\n<h1 id=\"第六天\">第六天</h1>\n<h2 id=\"剑指-Offer-32-I-从上到下打印二叉树-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\">剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-12\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">LevelOrder</span>(<span class=\"params\">TreeNode root</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; treeNodes = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        List&lt;<span class=\"built_in\">int</span>&gt; res = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        treeNodes.Enqueue(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (treeNodes.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode now = treeNodes.Dequeue();</span><br><span class=\"line\">            res.Add(now.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                treeNodes.Enqueue(now.left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.right != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                treeNodes.Enqueue(now.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-14\">后记</h3>\n<p><code>treeNodes.Enqueue(root);</code> 添加元素</p>\n<p><code>treeNodes.Dequeue();</code> 取出元素</p>\n<p>狠狠牢记API</p>\n<h2 id=\"剑指-Offer-32-II-从上到下打印二叉树-II-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\">剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-13\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> IList&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt; LevelOrder(TreeNode root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ans = <span class=\"keyword\">new</span> List&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> q = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        q.Enqueue(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (q.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> level = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> cnt = q.Count; cnt &gt; <span class=\"number\">0</span>; cnt--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> cur = q.Dequeue();</span><br><span class=\"line\">                level.Add(cur.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.left != <span class=\"literal\">null</span>) q.Enqueue(cur.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.right != <span class=\"literal\">null</span>) q.Enqueue(cur.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ans.Add(level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-15\">后记</h3>\n<p>这个BFS有点意思啊。</p>\n<h2 id=\"剑指-Offer-32-III-从上到下打印二叉树-III-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\">剑指 Offer 32 - III. 从上到下打印二叉树 III - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-14\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> IList&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt; LevelOrder(TreeNode root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        List&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt; list = <span class=\"keyword\">new</span> List&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt;();</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            queue.Enqueue(root);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            List&lt;<span class=\"built_in\">int</span>&gt; tempList = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">            <span class=\"built_in\">int</span> count = queue.Count;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode tree = queue.Dequeue();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (list.Count % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    tempList.Add(tree.val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    tempList.Insert(<span class=\"number\">0</span>, tree.val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tree.left != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.Enqueue(tree.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tree.right != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.Enqueue(tree.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            list.Add(tempList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-16\">后记</h3>\n<p>其实今天这几个题，都是BFS。。。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/eHGML2aYUcPmnvK.jpg","excerpt":"","more":"<h1 id=\"第一天\">第一天</h1>\n<h2 id=\"剑指-Offer-09-用两个栈实现队列\"><a href=\"https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\">剑指 Offer 09. 用两个栈实现队列</a></h2>\n<h3 id=\"题解\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * CQueue obj = new CQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.AppendTail(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.DeleteHead();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CQueue</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;<span class=\"built_in\">int</span>&gt; _a, _b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CQueue</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        _b = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AppendTail</span>(<span class=\"params\"><span class=\"built_in\">int</span> <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a.Push(<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">DeleteHead</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_b.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> _b.Pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_a.Count == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (_a.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            _b.Push(_a.Pop());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _b.Pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记\">后记</h3>\n<p>没什么，经典双栈拼接队列。</p>\n<h2 id=\"剑指-Offer-30-包含min函数的栈-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/\">剑指 Offer 30. 包含min函数的栈 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-2\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MinStack</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;<span class=\"built_in\">int</span>&gt; _a, _minStack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        _minStack = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Push</span>(<span class=\"params\"><span class=\"built_in\">int</span> x</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _a.Push(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_minStack.Count == <span class=\"number\">0</span> || _minStack.Peek() &gt;= x)</span><br><span class=\"line\">            _minStack.Push(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Pop</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_a.Pop() == _minStack.Peek())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _minStack.Pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Top</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _a.Peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Min</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _minStack.Peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-2\">后记</h3>\n<p>其实这个玩意 最好还是直接记录一下，但是感觉没必要。</p>\n<h1 id=\"第二天\">第二天</h1>\n<h2 id=\"剑指-Offer-06-从尾到头打印链表-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\">剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode）</a></h2>\n<h2 id=\"题解-3\">题解</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">int</span>&gt; _stack</span> = <span class=\"keyword\">new</span> Stack&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">ReversePrint</span>(<span class=\"params\">ListNode head</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _stack.Push(head.val);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[_stack.Count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; res.Length; i++)</span><br><span class=\"line\">            res[i] = _stack.Pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记-3\">后记</h2>\n<p>最大的难点居然是有人<code>Length</code>拼了四次才拼对。</p>\n<h2 id=\"剑指-Offer-24-反转链表-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/\">剑指 Offer 24. 反转链表 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-4\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">ReverseList</span>(<span class=\"params\">ListNode head</span>)</span> &#123;</span><br><span class=\"line\">        ListNode pre = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode temp = cur.next;</span><br><span class=\"line\">            cur.next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-4\">后记</h3>\n<p>我是废物！</p>\n<h2 id=\"剑指-Offer-35-复杂链表的复制-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/\">剑指 Offer 35. 复杂链表的复制 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-5\">题解</h3>\n<h4 id=\"哈希表-迭代\">哈希表 + 迭代</h4>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">public class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    public int val;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node next;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node random;</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        next = null;</span></span><br><span class=\"line\"><span class=\"comment\">        random = null;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;Node, Node&gt; _nodeDic;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">CopyRandomList</span>(<span class=\"params\">Node head</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _nodeDic = <span class=\"keyword\">new</span> Dictionary&lt;Node, Node&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node tempNode = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _nodeDic.Add(tempNode, <span class=\"keyword\">new</span> Node(tempNode.val));</span><br><span class=\"line\">            tempNode = tempNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tempNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tempNode.next != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                _nodeDic[tempNode].next = _nodeDic[tempNode.next];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tempNode.random != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                _nodeDic[tempNode].random = _nodeDic[tempNode.random];</span><br><span class=\"line\">            tempNode = tempNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _nodeDic[head];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拼接-拆分\">拼接 + 拆分</h4>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">CopyRandomList</span>(<span class=\"params\">Node head</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node tempNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Node temp = <span class=\"keyword\">new</span> Node(tempNode.val);</span><br><span class=\"line\">            temp.next = tempNode.next;</span><br><span class=\"line\">            tempNode.next = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">            tempNode = tempNode.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tempNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tempNode != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tempNode.random != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                tempNode.next.random = tempNode.random.next;</span><br><span class=\"line\">            tempNode = tempNode.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node cur = head.next;</span><br><span class=\"line\">        Node res = head.next;</span><br><span class=\"line\">        tempNode = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.next != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempNode.next = cur.next;</span><br><span class=\"line\">            cur.next = cur.next.next;</span><br><span class=\"line\"></span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            tempNode = tempNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tempNode.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-5\">后记</h3>\n<p>第一种解法偏常规，主要需要判空。</p>\n<p>第二种解法你会发现题目十分阴间，比如37行的<code>tempNode.next = null</code>，如果没有这一句话，该题目错误。因为你必须还原原链表，但是我明明只需要返回新链表啊！！你怎么能检测原链表啊！！！你是怎么做到的啊。<strong>第二种解法还是需要多看看。</strong></p>\n<h1 id=\"第三天\">第三天</h1>\n<h2 id=\"剑指-Offer-05-替换空格-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></h2>\n<h3 id=\"硬写\">硬写</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReplaceSpace</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> s)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                sb.Append(<span class=\"string\">&quot;%20&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                sb.Append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-6\">后记</h3>\n<p>没什么东西，标准题解的语言中大部分没有可变字符串。我是懒鬼，我选择可变。</p>\n<h2 id=\"剑指-Offer-58-II-左旋转字符串-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></h2>\n<h3 id=\"硬写-2\">硬写</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReverseLeftWords</span>(<span class=\"params\"><span class=\"built_in\">string</span> s, <span class=\"built_in\">int</span> n</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = n; i &lt; n + s.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sb.Append(s[i % s.Length]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.ToString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-7\">后记</h3>\n<p>sb yyds。</p>\n<h1 id=\"第四天\">第四天</h1>\n<h2 id=\"剑指-Offer-03-数组中重复的数字-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\">剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-6\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FindRepeatNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; nums.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前索引满足条件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[nums[i]] == nums[i])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">            (nums[nums[i]], nums[i]) = (nums[i], nums[nums[i]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-8\">后记</h3>\n<p>想笑啊。排行最优的算法是桶排序。</p>\n<h2 id=\"剑指-Offer-53-I-在排序数组中查找数字-I-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/\">剑指 Offer 53 - I. 在排序数组中查找数字 I - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-7\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Search</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums, <span class=\"built_in\">int</span> target</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>, right = nums.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = right - (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt;= target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> resRight = left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right &gt;= <span class=\"number\">0</span> &amp;&amp; nums[right] != target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        right = nums.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = right - (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> resLeft = right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resRight - resLeft - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-9\">后记</h3>\n<p>二分好难啊。但是？这玩意在leetcode不如一句<code>return nums.Count(num =&gt; num == target);</code>，Linq太强啦呜呜呜。</p>\n<h2 id=\"剑指-Offer-53-II-0～n-1中缺失的数字-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/\">剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-8\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MissingNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>, right = nums.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = right - (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == mid)</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-10\">后记</h3>\n<p>最快的还是暴力，我想笑啊。</p>\n<h1 id=\"第五天\">第五天</h1>\n<h2 id=\"剑指-Offer-04-二维数组中的查找-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\">剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-9\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">FindNumberIn2DArray</span>(<span class=\"params\"><span class=\"built_in\">int</span>[][] matrix, <span class=\"built_in\">int</span> target</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"literal\">null</span> || matrix.Length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> y = matrix[<span class=\"number\">0</span>].Length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x &lt; matrix.Length &amp;&amp; y &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[x][y] == target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (matrix[x][y] &lt; target)</span><br><span class=\"line\">                x++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                y--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-11\">后记</h3>\n<p>我好烦判空啊！</p>\n<h2 id=\"剑指-Offer-11-旋转数组的最小数字-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\">剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-10\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MinArray</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] numbers</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> right = numbers.Length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = left - (left - right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (numbers[mid] &lt; numbers[right])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numbers[mid] &gt; numbers[right])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-12\">后记</h3>\n<p>呜呜呜，我真的不会二分。</p>\n<h2 id=\"剑指-Offer-50-第一个只出现一次的字符-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\">剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-11\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">char</span> <span class=\"title\">FirstUniqChar</span>(<span class=\"params\"><span class=\"built_in\">string</span> s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.Length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Dictionary&lt;<span class=\"built_in\">char</span>, <span class=\"built_in\">bool</span>&gt; dic = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">char</span>, <span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">foreach</span>(<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> s) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dic.ContainsKey(c)) </span><br><span class=\"line\">                    dic[c] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    dic.Add(c, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> d <span class=\"keyword\">in</span> dic)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (d.Value) </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> d.Key;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-13\">后记</h3>\n<p>没什么，感觉不如原神。</p>\n<h1 id=\"第六天\">第六天</h1>\n<h2 id=\"剑指-Offer-32-I-从上到下打印二叉树-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\">剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-12\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">LevelOrder</span>(<span class=\"params\">TreeNode root</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; treeNodes = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        List&lt;<span class=\"built_in\">int</span>&gt; res = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        treeNodes.Enqueue(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (treeNodes.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode now = treeNodes.Dequeue();</span><br><span class=\"line\">            res.Add(now.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                treeNodes.Enqueue(now.left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.right != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                treeNodes.Enqueue(now.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-14\">后记</h3>\n<p><code>treeNodes.Enqueue(root);</code> 添加元素</p>\n<p><code>treeNodes.Dequeue();</code> 取出元素</p>\n<p>狠狠牢记API</p>\n<h2 id=\"剑指-Offer-32-II-从上到下打印二叉树-II-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\">剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-13\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> IList&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt; LevelOrder(TreeNode root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ans = <span class=\"keyword\">new</span> List&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> q = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        q.Enqueue(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (q.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> level = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> cnt = q.Count; cnt &gt; <span class=\"number\">0</span>; cnt--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> cur = q.Dequeue();</span><br><span class=\"line\">                level.Add(cur.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.left != <span class=\"literal\">null</span>) q.Enqueue(cur.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.right != <span class=\"literal\">null</span>) q.Enqueue(cur.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ans.Add(level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-15\">后记</h3>\n<p>这个BFS有点意思啊。</p>\n<h2 id=\"剑指-Offer-32-III-从上到下打印二叉树-III-力扣（LeetCode）\"><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\">剑指 Offer 32 - III. 从上到下打印二叉树 III - 力扣（LeetCode）</a></h2>\n<h3 id=\"题解-14\">题解</h3>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> IList&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt; LevelOrder(TreeNode root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        List&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt; list = <span class=\"keyword\">new</span> List&lt;IList&lt;<span class=\"built_in\">int</span>&gt;&gt;();</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> Queue&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            queue.Enqueue(root);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            List&lt;<span class=\"built_in\">int</span>&gt; tempList = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">            <span class=\"built_in\">int</span> count = queue.Count;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode tree = queue.Dequeue();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (list.Count % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    tempList.Add(tree.val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    tempList.Insert(<span class=\"number\">0</span>, tree.val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tree.left != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.Enqueue(tree.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tree.right != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.Enqueue(tree.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            list.Add(tempList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记-16\">后记</h3>\n<p>其实今天这几个题，都是BFS。。。</p>\n"},{"title":"算法与数据结构","date":"2022-02-05T13:18:24.000Z","_content":"\n# 数据结构\n\n## 链表\n\n```csharp\npublic class Node<T>\n{\n    public T Value;\n    public Node<T> Next;\n\n    public Node(T value) : this(value, null) {}\n\n    public Node(T value, Node<T> next)\n    {\n        Value = value;\n        Next = next;\n    }\n}\n```\n\n## 二叉树\n\n```csharp\npublic class TreeNode<T>\n{\n    public T Value;\n    public TreeNode<T> Left;\n    public TreeNode<T> Right;\n\n    public TreeNode(T value)\n    {\n        Value = value;\n    }\n}\n```\n\n### 前序遍历\n\n递归版\n\n```csharp\npublic void PreorderTraversal(TreeNode<T> root)\n{\n    if (root == null)\n        return;\n    Console.WriteLine(root.Value);\n    PreorderTraversal(root.Left);\n    PreorderTraversal(root.Right);\n}\n```\n\n非递归\n\n```csharp\npublic void PreorderTraversal(TreeNode<T> root)\n{\n    Stack<TreeNode<T>> stack = new Stack<TreeNode<T>>();\n    var tempRoot = root;\n    while (tempRoot != null || stack.Count > 0)\n    {\n        if (tempRoot != null)\n        {\n            Console.WriteLine(tempRoot.Value);\n            stack.Push(tempRoot);\n            tempRoot = tempRoot.Left;\n        }\n        else\n        {\n            var node = stack.Pop();\n            tempRoot = node.Right;\n        }\n    }\n}\n```\n\n","source":"_posts/算法与数据结构.md","raw":"---\ntitle: 算法与数据结构\ndate: 2022-02-05 21:18:24\ntags: c#\ncategories: 语言基础\n---\n\n# 数据结构\n\n## 链表\n\n```csharp\npublic class Node<T>\n{\n    public T Value;\n    public Node<T> Next;\n\n    public Node(T value) : this(value, null) {}\n\n    public Node(T value, Node<T> next)\n    {\n        Value = value;\n        Next = next;\n    }\n}\n```\n\n## 二叉树\n\n```csharp\npublic class TreeNode<T>\n{\n    public T Value;\n    public TreeNode<T> Left;\n    public TreeNode<T> Right;\n\n    public TreeNode(T value)\n    {\n        Value = value;\n    }\n}\n```\n\n### 前序遍历\n\n递归版\n\n```csharp\npublic void PreorderTraversal(TreeNode<T> root)\n{\n    if (root == null)\n        return;\n    Console.WriteLine(root.Value);\n    PreorderTraversal(root.Left);\n    PreorderTraversal(root.Right);\n}\n```\n\n非递归\n\n```csharp\npublic void PreorderTraversal(TreeNode<T> root)\n{\n    Stack<TreeNode<T>> stack = new Stack<TreeNode<T>>();\n    var tempRoot = root;\n    while (tempRoot != null || stack.Count > 0)\n    {\n        if (tempRoot != null)\n        {\n            Console.WriteLine(tempRoot.Value);\n            stack.Push(tempRoot);\n            tempRoot = tempRoot.Left;\n        }\n        else\n        {\n            var node = stack.Pop();\n            tempRoot = node.Right;\n        }\n    }\n}\n```\n\n","slug":"算法与数据结构","published":1,"updated":"2022-05-02T12:50:46.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztqg00132cup82v407xi","content":"<h1 id=\"数据结构\">数据结构</h1>\n<h2 id=\"链表\">链表</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">T</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T Value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node&lt;T&gt; Next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span>(<span class=\"params\">T <span class=\"keyword\">value</span></span>) : <span class=\"title\">this</span>(<span class=\"params\"><span class=\"keyword\">value</span>, <span class=\"literal\">null</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span>(<span class=\"params\">T <span class=\"keyword\">value</span>, Node&lt;T&gt; next</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Value = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        Next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树\">二叉树</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">T</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T Value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode&lt;T&gt; Left;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode&lt;T&gt; Right;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeNode</span>(<span class=\"params\">T <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Value = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前序遍历\">前序遍历</h3>\n<p>递归版</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">PreorderTraversal</span>(<span class=\"params\">TreeNode&lt;T&gt; root</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Console.WriteLine(root.Value);</span><br><span class=\"line\">    PreorderTraversal(root.Left);</span><br><span class=\"line\">    PreorderTraversal(root.Right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非递归</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">PreorderTraversal</span>(<span class=\"params\">TreeNode&lt;T&gt; root</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Stack&lt;TreeNode&lt;T&gt;&gt; stack = <span class=\"keyword\">new</span> Stack&lt;TreeNode&lt;T&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempRoot = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tempRoot != <span class=\"literal\">null</span> || stack.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tempRoot != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(tempRoot.Value);</span><br><span class=\"line\">            stack.Push(tempRoot);</span><br><span class=\"line\">            tempRoot = tempRoot.Left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node = stack.Pop();</span><br><span class=\"line\">            tempRoot = node.Right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/V4nQ1lNbAJj92ZC.jpg","excerpt":"","more":"<h1 id=\"数据结构\">数据结构</h1>\n<h2 id=\"链表\">链表</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">T</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T Value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node&lt;T&gt; Next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span>(<span class=\"params\">T <span class=\"keyword\">value</span></span>) : <span class=\"title\">this</span>(<span class=\"params\"><span class=\"keyword\">value</span>, <span class=\"literal\">null</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span>(<span class=\"params\">T <span class=\"keyword\">value</span>, Node&lt;T&gt; next</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Value = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        Next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树\">二叉树</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">T</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T Value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode&lt;T&gt; Left;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode&lt;T&gt; Right;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeNode</span>(<span class=\"params\">T <span class=\"keyword\">value</span></span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Value = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前序遍历\">前序遍历</h3>\n<p>递归版</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">PreorderTraversal</span>(<span class=\"params\">TreeNode&lt;T&gt; root</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Console.WriteLine(root.Value);</span><br><span class=\"line\">    PreorderTraversal(root.Left);</span><br><span class=\"line\">    PreorderTraversal(root.Right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>非递归</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">PreorderTraversal</span>(<span class=\"params\">TreeNode&lt;T&gt; root</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Stack&lt;TreeNode&lt;T&gt;&gt; stack = <span class=\"keyword\">new</span> Stack&lt;TreeNode&lt;T&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempRoot = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tempRoot != <span class=\"literal\">null</span> || stack.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tempRoot != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(tempRoot.Value);</span><br><span class=\"line\">            stack.Push(tempRoot);</span><br><span class=\"line\">            tempRoot = tempRoot.Left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node = stack.Pop();</span><br><span class=\"line\">            tempRoot = node.Right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"面试经历","date":"2022-03-02T09:35:52.000Z","_content":"\n## 盛趣 一面 B.W.B实习项目\n\n## Unity\n\n### Unity有几种光源\n\n起手这个问题直接把我人都打麻了，瞬间开始紧张，后续问题基本都没答好。\n\n1. 方向光：Directional Light\n2. 点光源： Point Light\n3. 聚光灯：Spot Light\n4. 区域光：Area Light\n\n### `Start`和`Awake`有什么区别\n\n- **Awake** ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）\n- **Start** ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。\n\n[事件函数的执行顺序 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html)\n\n### 如果Animator连线太多如何处理\n\n回答了分层处理之后还问有什么解决方案提到了Unity内置的状态机。\n\n[UnityEngine.StateMachineBehaviour - Unity 脚本 API (unity3d.com)](https://docs.unity3d.com/cn/2020.3/ScriptReference/StateMachineBehaviour.html)\n\n### UGUI中锚点和中心点\n\n[基本布局 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/UIBasicLayout.html)\n\n### 万向节死锁\n\n[【Unity技巧】四元数（Quaternion）和旋转_candycat-CSDN博客_四元数](https://blog.csdn.net/candycat1992/article/details/41254799)\n\n### Mipmap\n\n建议看[GAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1X7411F744/)\n\n[Mipmap详解(有无Mipmap区别、原理、优点、缺点、优化)_爱吃的栗子‘s 博客-CSDN博客_mipmap](https://blog.csdn.net/qq_42428486/article/details/118856697)\n\n### 3D骨骼动画原理\n\n[浅谈骨骼动画技术原理（一）：基本介绍 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/431446337)\n\n## C#\n\n### `ArraryList`和`List`的区别\n\n[C#介绍ArrayList和List的区别（第一篇内容博客 ） - Hard_Song - 博客园 (cnblogs.com)](https://www.cnblogs.com/baosong/p/8435415.html)\n\n### `List`和`Dictionary`如何实现的，以及两者遍历效率\n\n[遍历Dictionary跟List<T>的性能问题-CSDN社区](https://bbs.csdn.net/topics/390406399)\n\n### `Struct`和`Class`的区别\n\n[C#中struct和class的使用区别是什么？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/428765055)\n\n## Lua\n\n### Lua中有那些数据类型\n\n[Lua 数据类型 | 菜鸟教程 (runoob.com)](https://www.runoob.com/lua/lua-data-types.html)\n\n### `ipair`和`pair`的区别\n\n[Lua pairs 和 ipairs 的区别 (runoob.com)](https://www.runoob.com/note/11315)\n\n## 总结\n\n说实话，第一次面试，这上面答得都很差。。寄！果然一到面试就什么都吹不出来了。\n","source":"_posts/面试经历.md","raw":"---\ntitle: 面试经历\ndate: 2022-03-02 17:35:52\ntags: Unity\ncategories: 面试\n---\n\n## 盛趣 一面 B.W.B实习项目\n\n## Unity\n\n### Unity有几种光源\n\n起手这个问题直接把我人都打麻了，瞬间开始紧张，后续问题基本都没答好。\n\n1. 方向光：Directional Light\n2. 点光源： Point Light\n3. 聚光灯：Spot Light\n4. 区域光：Area Light\n\n### `Start`和`Awake`有什么区别\n\n- **Awake** ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）\n- **Start** ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。\n\n[事件函数的执行顺序 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html)\n\n### 如果Animator连线太多如何处理\n\n回答了分层处理之后还问有什么解决方案提到了Unity内置的状态机。\n\n[UnityEngine.StateMachineBehaviour - Unity 脚本 API (unity3d.com)](https://docs.unity3d.com/cn/2020.3/ScriptReference/StateMachineBehaviour.html)\n\n### UGUI中锚点和中心点\n\n[基本布局 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2020.3/Manual/UIBasicLayout.html)\n\n### 万向节死锁\n\n[【Unity技巧】四元数（Quaternion）和旋转_candycat-CSDN博客_四元数](https://blog.csdn.net/candycat1992/article/details/41254799)\n\n### Mipmap\n\n建议看[GAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1X7411F744/)\n\n[Mipmap详解(有无Mipmap区别、原理、优点、缺点、优化)_爱吃的栗子‘s 博客-CSDN博客_mipmap](https://blog.csdn.net/qq_42428486/article/details/118856697)\n\n### 3D骨骼动画原理\n\n[浅谈骨骼动画技术原理（一）：基本介绍 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/431446337)\n\n## C#\n\n### `ArraryList`和`List`的区别\n\n[C#介绍ArrayList和List的区别（第一篇内容博客 ） - Hard_Song - 博客园 (cnblogs.com)](https://www.cnblogs.com/baosong/p/8435415.html)\n\n### `List`和`Dictionary`如何实现的，以及两者遍历效率\n\n[遍历Dictionary跟List<T>的性能问题-CSDN社区](https://bbs.csdn.net/topics/390406399)\n\n### `Struct`和`Class`的区别\n\n[C#中struct和class的使用区别是什么？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/428765055)\n\n## Lua\n\n### Lua中有那些数据类型\n\n[Lua 数据类型 | 菜鸟教程 (runoob.com)](https://www.runoob.com/lua/lua-data-types.html)\n\n### `ipair`和`pair`的区别\n\n[Lua pairs 和 ipairs 的区别 (runoob.com)](https://www.runoob.com/note/11315)\n\n## 总结\n\n说实话，第一次面试，这上面答得都很差。。寄！果然一到面试就什么都吹不出来了。\n","slug":"面试经历","published":1,"updated":"2022-03-09T08:58:31.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5o3ztqh00142cup1aed1973","content":"<h2 id=\"盛趣-一面-B-W-B实习项目\">盛趣 一面 B.W.B实习项目</h2>\n<h2 id=\"Unity\">Unity</h2>\n<h3 id=\"Unity有几种光源\">Unity有几种光源</h3>\n<p>起手这个问题直接把我人都打麻了，瞬间开始紧张，后续问题基本都没答好。</p>\n<ol>\n<li>方向光：Directional Light</li>\n<li>点光源： Point Light</li>\n<li>聚光灯：Spot Light</li>\n<li>区域光：Area Light</li>\n</ol>\n<h3 id=\"Start和Awake有什么区别\"><code>Start</code>和<code>Awake</code>有什么区别</h3>\n<ul>\n<li><strong>Awake</strong> ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）</li>\n<li><strong>Start</strong> ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。</li>\n</ul>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html\">事件函数的执行顺序 - Unity 手册 (unity3d.com)</a></p>\n<h3 id=\"如果Animator连线太多如何处理\">如果Animator连线太多如何处理</h3>\n<p>回答了分层处理之后还问有什么解决方案提到了Unity内置的状态机。</p>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/ScriptReference/StateMachineBehaviour.html\">UnityEngine.StateMachineBehaviour - Unity 脚本 API (unity3d.com)</a></p>\n<h3 id=\"UGUI中锚点和中心点\">UGUI中锚点和中心点</h3>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/UIBasicLayout.html\">基本布局 - Unity 手册 (unity3d.com)</a></p>\n<h3 id=\"万向节死锁\">万向节死锁</h3>\n<p><a href=\"https://blog.csdn.net/candycat1992/article/details/41254799\">【Unity技巧】四元数（Quaternion）和旋转_candycat-CSDN博客_四元数</a></p>\n<h3 id=\"Mipmap\">Mipmap</h3>\n<p>建议看<a href=\"https://www.bilibili.com/video/BV1X7411F744/\">GAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42428486/article/details/118856697\">Mipmap详解(有无Mipmap区别、原理、优点、缺点、优化)_爱吃的栗子‘s 博客-CSDN博客_mipmap</a></p>\n<h3 id=\"3D骨骼动画原理\">3D骨骼动画原理</h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/431446337\">浅谈骨骼动画技术原理（一）：基本介绍 - 知乎 (zhihu.com)</a></p>\n<h2 id=\"C\">C#</h2>\n<h3 id=\"ArraryList和List的区别\"><code>ArraryList</code>和<code>List</code>的区别</h3>\n<p><a href=\"https://www.cnblogs.com/baosong/p/8435415.html\">C#介绍ArrayList和List的区别（第一篇内容博客 ） - Hard_Song - 博客园 (cnblogs.com)</a></p>\n<h3 id=\"List和Dictionary如何实现的，以及两者遍历效率\"><code>List</code>和<code>Dictionary</code>如何实现的，以及两者遍历效率</h3>\n<p><a href=\"https://bbs.csdn.net/topics/390406399\">遍历Dictionary跟List<T>的性能问题-CSDN社区</a></p>\n<h3 id=\"Struct和Class的区别\"><code>Struct</code>和<code>Class</code>的区别</h3>\n<p><a href=\"https://www.zhihu.com/question/428765055\">C#中struct和class的使用区别是什么？ - 知乎 (zhihu.com)</a></p>\n<h2 id=\"Lua\">Lua</h2>\n<h3 id=\"Lua中有那些数据类型\">Lua中有那些数据类型</h3>\n<p><a href=\"https://www.runoob.com/lua/lua-data-types.html\">Lua 数据类型 | 菜鸟教程 (runoob.com)</a></p>\n<h3 id=\"ipair和pair的区别\"><code>ipair</code>和<code>pair</code>的区别</h3>\n<p><a href=\"https://www.runoob.com/note/11315\">Lua pairs 和 ipairs 的区别 (runoob.com)</a></p>\n<h2 id=\"总结\">总结</h2>\n<p>说实话，第一次面试，这上面答得都很差。。寄！果然一到面试就什么都吹不出来了。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://z3.ax1x.com/2021/11/20/Iq0ZTg.jpg","excerpt":"","more":"<h2 id=\"盛趣-一面-B-W-B实习项目\">盛趣 一面 B.W.B实习项目</h2>\n<h2 id=\"Unity\">Unity</h2>\n<h3 id=\"Unity有几种光源\">Unity有几种光源</h3>\n<p>起手这个问题直接把我人都打麻了，瞬间开始紧张，后续问题基本都没答好。</p>\n<ol>\n<li>方向光：Directional Light</li>\n<li>点光源： Point Light</li>\n<li>聚光灯：Spot Light</li>\n<li>区域光：Area Light</li>\n</ol>\n<h3 id=\"Start和Awake有什么区别\"><code>Start</code>和<code>Awake</code>有什么区别</h3>\n<ul>\n<li><strong>Awake</strong> ：始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）</li>\n<li><strong>Start</strong> ：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。</li>\n</ul>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html\">事件函数的执行顺序 - Unity 手册 (unity3d.com)</a></p>\n<h3 id=\"如果Animator连线太多如何处理\">如果Animator连线太多如何处理</h3>\n<p>回答了分层处理之后还问有什么解决方案提到了Unity内置的状态机。</p>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/ScriptReference/StateMachineBehaviour.html\">UnityEngine.StateMachineBehaviour - Unity 脚本 API (unity3d.com)</a></p>\n<h3 id=\"UGUI中锚点和中心点\">UGUI中锚点和中心点</h3>\n<p><a href=\"https://docs.unity3d.com/cn/2020.3/Manual/UIBasicLayout.html\">基本布局 - Unity 手册 (unity3d.com)</a></p>\n<h3 id=\"万向节死锁\">万向节死锁</h3>\n<p><a href=\"https://blog.csdn.net/candycat1992/article/details/41254799\">【Unity技巧】四元数（Quaternion）和旋转_candycat-CSDN博客_四元数</a></p>\n<h3 id=\"Mipmap\">Mipmap</h3>\n<p>建议看<a href=\"https://www.bilibili.com/video/BV1X7411F744/\">GAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42428486/article/details/118856697\">Mipmap详解(有无Mipmap区别、原理、优点、缺点、优化)_爱吃的栗子‘s 博客-CSDN博客_mipmap</a></p>\n<h3 id=\"3D骨骼动画原理\">3D骨骼动画原理</h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/431446337\">浅谈骨骼动画技术原理（一）：基本介绍 - 知乎 (zhihu.com)</a></p>\n<h2 id=\"C\">C#</h2>\n<h3 id=\"ArraryList和List的区别\"><code>ArraryList</code>和<code>List</code>的区别</h3>\n<p><a href=\"https://www.cnblogs.com/baosong/p/8435415.html\">C#介绍ArrayList和List的区别（第一篇内容博客 ） - Hard_Song - 博客园 (cnblogs.com)</a></p>\n<h3 id=\"List和Dictionary如何实现的，以及两者遍历效率\"><code>List</code>和<code>Dictionary</code>如何实现的，以及两者遍历效率</h3>\n<p><a href=\"https://bbs.csdn.net/topics/390406399\">遍历Dictionary跟List<T>的性能问题-CSDN社区</a></p>\n<h3 id=\"Struct和Class的区别\"><code>Struct</code>和<code>Class</code>的区别</h3>\n<p><a href=\"https://www.zhihu.com/question/428765055\">C#中struct和class的使用区别是什么？ - 知乎 (zhihu.com)</a></p>\n<h2 id=\"Lua\">Lua</h2>\n<h3 id=\"Lua中有那些数据类型\">Lua中有那些数据类型</h3>\n<p><a href=\"https://www.runoob.com/lua/lua-data-types.html\">Lua 数据类型 | 菜鸟教程 (runoob.com)</a></p>\n<h3 id=\"ipair和pair的区别\"><code>ipair</code>和<code>pair</code>的区别</h3>\n<p><a href=\"https://www.runoob.com/note/11315\">Lua pairs 和 ipairs 的区别 (runoob.com)</a></p>\n<h2 id=\"总结\">总结</h2>\n<p>说实话，第一次面试，这上面答得都很差。。寄！果然一到面试就什么都吹不出来了。</p>\n"},{"layout":"post","title":"计算机操作系统","date":"2021-10-24T11:50:07.000Z","_content":"\n# 进程管理\n\n## 进程(Process)\n\n### 进程的定义\n\n狭义定义：进程是正在运行的程序的实例。\n\n广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的**分配单元**，也是基本的**执行单元**(是系统进行**资源分配**和**调度**的一个独立单位)。\n\n> 描述进程的数据结构：**进程控制块（Process Control Block,PCB）**，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。\n>\n> PCB是进程存在的唯一标志。\n>\n> > PCB含有的信息\n> >\n> > 1. **进程标识信息**\n> >\n> >    如本进程的标识，本进程的产生者标识（父进程标识）；用户标示\n> >\n> > 2. **处理机状态信息**\n> >\n> >    保存进程的运行现场信息：\n> >\n> >    - **用户可见寄存器**，用户程序可以使用的数据，地址等寄存器\n> >    - **控制和状态寄存器**，如程序计数器(PC)，程序状态字(PSW)\n> >    - **栈指针**，过程调用/系统调用/中断处理和返回时需要用到它\n> >\n> > 3. **进程调度信息/进程控制信息**\n> >\n> >    - **调度和状态信息**，用于操作系统调度进程并占用处理机使用\n> >    - **进程间通信信息**，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中\n> >    - **存储管理信息**，包含有指向本进程映像存储空间的数据结构\n> >    - **进程所用资源**，说明由进程打开、使用的系统资源，如打开的文件等\n> >    - **有关数据结构连接信息**，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB\n> >\n> > \n>\n> > 使用PCB\n> >\n> > - 进程的创建：为该进程生成一个PCB\n> > - 进程的终止：回收他的PCB\n> >\n> > - 进程的组织管理：通过对PCB的组织管理来实现\n>\n> > PCB的组织方式\n> >\n> > - **线性表方式**：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。\n> > - **索引表方式**：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。\n> > - **链接表方式**：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。\n\n### 进程的组成\n\n一个计算机系统进程包括下列资料\n\n- 程序的代码\n- 程序处理的数据\n- 程序计数器中的值，指示下一条将运行的指令\n- 一组通用的寄存器的当前值、栈\n- 一组系统资源（如打开的文件）\n\n总之，进程包含了正在运行的一个程序所有状态信息。\n\n### 进程的特点\n\n- 动态性：可动态地创建、结束进程\n- 并发性：进程可以被独立调度并占用处理机运行\n- 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n- 异步性[^1]：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进\n\n> 并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的\n>\n> 并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)\n\n\n\n\n### 进程与程序的联系\n\n- 程序是产生进程的基础\n- 程序的每次运行构成不同的进程\n- 进程是程序功能的体现\n- 通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序\n\n### 进程与程序的区别\n\n- 进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。\n\n- 进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。\n\n- 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程\n\n  状态信息)\n\n  ![](./1.png)\n\n  \n\n## 进程状态(State)\n\n### 进程的生命期管理\n\n- **进程创建**\n\n  引起进程创建的3个主要事件：\n\n  - 系统初始化时\n  - 用户请求创建一个新进程\n  - 正在运行的进程执行了创建进程的系统调用\n\n- **进程运行**\n\n  内核选择一个就绪的进程，让它占用处理机并执行\n\n- **进程等待**\n\n  在以下情况下，进程等待（阻塞）\n\n  - 请求并等待系统服务，无法马上完成\n  - 启动某种操作，无法马上完成\n  - 需要的数据没有到达\n\n  进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生\n\n- **进程唤醒**\n\n  唤醒进程的原因：\n\n  - 被阻塞进程需要的资源可被满足\n  - 被阻塞进程等待的事件到达\n  - 将该进程的PCB插入到就绪队列\n\n  进程只能被别的进程或操作系统唤醒\n\n- **进程结束**\n\n  在以下情况，进程结束：\n\n  - 正常退出（自愿）\n  - 错误退出（自愿）\n  - 致命错误（强制）\n  - 被其他进程所杀（强制）\n\n### 进程状态变化模型\n\n进程的三种基本状态：\n\n- **运行状态(Running)**\n\n  当一个进程正在处理机上运行时\n\n- **就绪状态(Ready)**\n\n  一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行\n\n- **等待状态(又称阻塞状态Blocked)**\n\n  一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成\n\n  ![](./3.png)\n\n进程的其他基本状态\n\n- **创建状态(New)**\n\n  一个进程正在被创建，还没被转到就绪状态之前的状态\n\n- **结束状态(Exit)**\n\n  一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致\n\n  ![](./2.png)\n\n  > **时间片**（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。\n\n### 进程挂起\n\n进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。\n\n挂起状态：\n\n- **阻塞挂起状态**（Blocked-suspend）\n\n  进程在外存并等待某事件的出现\n\n- **就绪挂起状态**（Ready-suspend）\n\n  进程在外存，但只要进入内存，即可运行\n\n与挂起相关的状态转换：\n\n- 挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况\n\n  - **阻塞到阻塞挂起**\n\n    没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程\n\n  - **就绪到就绪挂起**\n\n    当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程\n\n  - **运行到就绪挂起**\n\n    对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态\n\n- 在外存时的状态转换\n\n  - **阻塞挂起到就绪挂起**\n\n    当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程\n\n- 解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况\n\n  - **就绪挂起到就绪**\n\n    没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换\n\n  - **阻塞挂起到阻塞**\n\n    当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程\n\n### 状态队列\n\n- 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态\n- 不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)\n- 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列\n\n![](./4.png)\n\n## 线程(Thread)\n\n### 线程的定义\n\n线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。\n\n### 线程的优缺点\n\n优点：\n\n- 一个进程中可以同时存在多个线程\n- 各个线程之间可以并发地执行\n- 各个线程之间可以共享地址空间和文件等资源\n\n缺点：\n\n- 一个线程崩溃，会导致其所属进程的所有线程崩溃\n\n### 线程与进程的比较\n\n- 进程是资源分配单元，线程是CPU调度单元\n- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈\n- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系\n- 线程能减少并发执行的时间和空间开销\n  - 线程的创建时间比进程短\n  - 线程的终止时间比进程短\n  - 同一进程内的线程切换时间比进程短\n  - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信 \n\n### 线程的实现\n\n- 用户线程：在用户空间实现\n  > **用户线程**:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。\n  >\n  > 缺点：\n  >\n  > - 阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待\n  > - 当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行\n  > - 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢\n  \n- 内核线程：在内核中实现\n\n  > **内核线程**：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理\n\n- 轻量级线程：在内核中实现，支持用户线程\n\n  > **轻量级进程**：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持\n\n\n\n用户线程与内核线程的对应关系\n\n- 多对一\n- 一对一\n- 多对多\n\n\n\n## 进程间通信(Inter-process communication)\n\n## 进程互斥与同步\n\n### 基础知识\n\n**临界区**\n\n**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域\n\n**互斥**\n\n当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源\n\n**死锁**\n\n两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去\n\n**饥饿**\n\n一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行\n\n### 实现临界区互斥的基本方法\n\n- 禁用中断(仅限于单处理器)\n\n  当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：**禁止一切中断发生，称之为屏蔽中断或关中断**。\n  因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。\n  **典型模式为：关中断、临界区、开中断**\n\n  **缺点**\n\n  这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。\n\n- **软件方法(复杂)**\n\n  **Peterson算法**\n\n  Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。\n\n  算法使用两个控制变量`flag`与`turn`. 其中`flag[n]`的值为真，表示ID号为`n`的进程希望进入该临界区. 变量`turn`保存有权访问共享资源的进程的ID号.\n\n  ```c++\n  // flag[]是bool数组，turn为int\n  flag[0] = false\n  flag[1] = false;\n  int turn;\n  \n  //P1\n  flag[0] = true;\n  turn = 1;\n  // flag[1] == true时说明另外一个也想运行，\n  while(flag[1] == true && trun == 1)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[0] = false;\n  \n  //同理P2为\n  flag[1] = true;\n  turn = 0;\n  while (flag[0] == true && turn == 0)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[1] = false;\n  ```\n\n  该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）\n\n  **缺点**\n\n  - 复杂：需要两个进程间的共享项\n  - 需要忙等待：浪费CPU时间\n  - 没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令\n\n- **原子操作指令(单处理器或多处理器均可)**\n\n  TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。\n\n  ```c++\n  bool TestAndSet(bool *lock)\n  {\n  \tbool rv = *lock;\n      *lock = true;\n      return rv;\n  }\n  \n  //共享变量lock,true表示正在被占用，false表示没被占用\n  bool lock = false;\n  \n  //进入\n  //如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true->锁的状态不被改变并且需要循环\n  //如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true->锁被设置为被占用状态，并且需要等待完成\n  while(TestAndSet(&lock));\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  Exchange(Swap)指令：交换两个变量的内容\n\n  ```c++\n  void Exchange(bool *a, bool *b)\n  {\n  \tbool temp = *a;\n  \t*a = *b;\n  \t*b = temp;\n  }\n  \n  //共享变量lock，初始化为false\n  bool lock = false;\n  \n  //进入\n  bool key;\n  key = true;\n  while(key == true)\n     Exchange(lock, key);\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  **优点**\n\n  - 适用于单处理器或者共享主存的多处理器中**任意数量的进程**\n  - 简单并且容易证明\n  - 可以用于支持多临界区\n\n  **缺点**\n\n  - 忙等待消耗处理器时间\n\n  - 当进程离开临界区并且多个进程在等待时候可能导致饥饿\n\n  - 死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区\n\n    ps : 优先级反转来解决\n\n## 死锁(Deadlock)\n\n![](/img/1.png)\n\n[^1]: 部分地方称为制约性\n","source":"_posts/操作系统/操作系统.md","raw":"---\nlayout: post\ntitle: 计算机操作系统\ndate: 2021-10-24 19:50:07\ntags: 操作系统\ncategories: 计算机基础知识\n---\n\n# 进程管理\n\n## 进程(Process)\n\n### 进程的定义\n\n狭义定义：进程是正在运行的程序的实例。\n\n广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的**分配单元**，也是基本的**执行单元**(是系统进行**资源分配**和**调度**的一个独立单位)。\n\n> 描述进程的数据结构：**进程控制块（Process Control Block,PCB）**，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。\n>\n> PCB是进程存在的唯一标志。\n>\n> > PCB含有的信息\n> >\n> > 1. **进程标识信息**\n> >\n> >    如本进程的标识，本进程的产生者标识（父进程标识）；用户标示\n> >\n> > 2. **处理机状态信息**\n> >\n> >    保存进程的运行现场信息：\n> >\n> >    - **用户可见寄存器**，用户程序可以使用的数据，地址等寄存器\n> >    - **控制和状态寄存器**，如程序计数器(PC)，程序状态字(PSW)\n> >    - **栈指针**，过程调用/系统调用/中断处理和返回时需要用到它\n> >\n> > 3. **进程调度信息/进程控制信息**\n> >\n> >    - **调度和状态信息**，用于操作系统调度进程并占用处理机使用\n> >    - **进程间通信信息**，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中\n> >    - **存储管理信息**，包含有指向本进程映像存储空间的数据结构\n> >    - **进程所用资源**，说明由进程打开、使用的系统资源，如打开的文件等\n> >    - **有关数据结构连接信息**，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB\n> >\n> > \n>\n> > 使用PCB\n> >\n> > - 进程的创建：为该进程生成一个PCB\n> > - 进程的终止：回收他的PCB\n> >\n> > - 进程的组织管理：通过对PCB的组织管理来实现\n>\n> > PCB的组织方式\n> >\n> > - **线性表方式**：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。\n> > - **索引表方式**：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。\n> > - **链接表方式**：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。\n\n### 进程的组成\n\n一个计算机系统进程包括下列资料\n\n- 程序的代码\n- 程序处理的数据\n- 程序计数器中的值，指示下一条将运行的指令\n- 一组通用的寄存器的当前值、栈\n- 一组系统资源（如打开的文件）\n\n总之，进程包含了正在运行的一个程序所有状态信息。\n\n### 进程的特点\n\n- 动态性：可动态地创建、结束进程\n- 并发性：进程可以被独立调度并占用处理机运行\n- 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n- 异步性[^1]：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进\n\n> 并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的\n>\n> 并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)\n\n\n\n\n### 进程与程序的联系\n\n- 程序是产生进程的基础\n- 程序的每次运行构成不同的进程\n- 进程是程序功能的体现\n- 通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序\n\n### 进程与程序的区别\n\n- 进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。\n\n- 进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。\n\n- 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程\n\n  状态信息)\n\n  ![](./1.png)\n\n  \n\n## 进程状态(State)\n\n### 进程的生命期管理\n\n- **进程创建**\n\n  引起进程创建的3个主要事件：\n\n  - 系统初始化时\n  - 用户请求创建一个新进程\n  - 正在运行的进程执行了创建进程的系统调用\n\n- **进程运行**\n\n  内核选择一个就绪的进程，让它占用处理机并执行\n\n- **进程等待**\n\n  在以下情况下，进程等待（阻塞）\n\n  - 请求并等待系统服务，无法马上完成\n  - 启动某种操作，无法马上完成\n  - 需要的数据没有到达\n\n  进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生\n\n- **进程唤醒**\n\n  唤醒进程的原因：\n\n  - 被阻塞进程需要的资源可被满足\n  - 被阻塞进程等待的事件到达\n  - 将该进程的PCB插入到就绪队列\n\n  进程只能被别的进程或操作系统唤醒\n\n- **进程结束**\n\n  在以下情况，进程结束：\n\n  - 正常退出（自愿）\n  - 错误退出（自愿）\n  - 致命错误（强制）\n  - 被其他进程所杀（强制）\n\n### 进程状态变化模型\n\n进程的三种基本状态：\n\n- **运行状态(Running)**\n\n  当一个进程正在处理机上运行时\n\n- **就绪状态(Ready)**\n\n  一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行\n\n- **等待状态(又称阻塞状态Blocked)**\n\n  一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成\n\n  ![](./3.png)\n\n进程的其他基本状态\n\n- **创建状态(New)**\n\n  一个进程正在被创建，还没被转到就绪状态之前的状态\n\n- **结束状态(Exit)**\n\n  一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致\n\n  ![](./2.png)\n\n  > **时间片**（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。\n\n### 进程挂起\n\n进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。\n\n挂起状态：\n\n- **阻塞挂起状态**（Blocked-suspend）\n\n  进程在外存并等待某事件的出现\n\n- **就绪挂起状态**（Ready-suspend）\n\n  进程在外存，但只要进入内存，即可运行\n\n与挂起相关的状态转换：\n\n- 挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况\n\n  - **阻塞到阻塞挂起**\n\n    没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程\n\n  - **就绪到就绪挂起**\n\n    当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程\n\n  - **运行到就绪挂起**\n\n    对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态\n\n- 在外存时的状态转换\n\n  - **阻塞挂起到就绪挂起**\n\n    当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程\n\n- 解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况\n\n  - **就绪挂起到就绪**\n\n    没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换\n\n  - **阻塞挂起到阻塞**\n\n    当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程\n\n### 状态队列\n\n- 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态\n- 不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)\n- 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列\n\n![](./4.png)\n\n## 线程(Thread)\n\n### 线程的定义\n\n线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。\n\n### 线程的优缺点\n\n优点：\n\n- 一个进程中可以同时存在多个线程\n- 各个线程之间可以并发地执行\n- 各个线程之间可以共享地址空间和文件等资源\n\n缺点：\n\n- 一个线程崩溃，会导致其所属进程的所有线程崩溃\n\n### 线程与进程的比较\n\n- 进程是资源分配单元，线程是CPU调度单元\n- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈\n- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系\n- 线程能减少并发执行的时间和空间开销\n  - 线程的创建时间比进程短\n  - 线程的终止时间比进程短\n  - 同一进程内的线程切换时间比进程短\n  - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信 \n\n### 线程的实现\n\n- 用户线程：在用户空间实现\n  > **用户线程**:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。\n  >\n  > 缺点：\n  >\n  > - 阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待\n  > - 当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行\n  > - 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢\n  \n- 内核线程：在内核中实现\n\n  > **内核线程**：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理\n\n- 轻量级线程：在内核中实现，支持用户线程\n\n  > **轻量级进程**：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持\n\n\n\n用户线程与内核线程的对应关系\n\n- 多对一\n- 一对一\n- 多对多\n\n\n\n## 进程间通信(Inter-process communication)\n\n## 进程互斥与同步\n\n### 基础知识\n\n**临界区**\n\n**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域\n\n**互斥**\n\n当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源\n\n**死锁**\n\n两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去\n\n**饥饿**\n\n一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行\n\n### 实现临界区互斥的基本方法\n\n- 禁用中断(仅限于单处理器)\n\n  当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：**禁止一切中断发生，称之为屏蔽中断或关中断**。\n  因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。\n  **典型模式为：关中断、临界区、开中断**\n\n  **缺点**\n\n  这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。\n\n- **软件方法(复杂)**\n\n  **Peterson算法**\n\n  Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。\n\n  算法使用两个控制变量`flag`与`turn`. 其中`flag[n]`的值为真，表示ID号为`n`的进程希望进入该临界区. 变量`turn`保存有权访问共享资源的进程的ID号.\n\n  ```c++\n  // flag[]是bool数组，turn为int\n  flag[0] = false\n  flag[1] = false;\n  int turn;\n  \n  //P1\n  flag[0] = true;\n  turn = 1;\n  // flag[1] == true时说明另外一个也想运行，\n  while(flag[1] == true && trun == 1)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[0] = false;\n  \n  //同理P2为\n  flag[1] = true;\n  turn = 0;\n  while (flag[0] == true && turn == 0)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[1] = false;\n  ```\n\n  该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）\n\n  **缺点**\n\n  - 复杂：需要两个进程间的共享项\n  - 需要忙等待：浪费CPU时间\n  - 没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令\n\n- **原子操作指令(单处理器或多处理器均可)**\n\n  TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。\n\n  ```c++\n  bool TestAndSet(bool *lock)\n  {\n  \tbool rv = *lock;\n      *lock = true;\n      return rv;\n  }\n  \n  //共享变量lock,true表示正在被占用，false表示没被占用\n  bool lock = false;\n  \n  //进入\n  //如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true->锁的状态不被改变并且需要循环\n  //如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true->锁被设置为被占用状态，并且需要等待完成\n  while(TestAndSet(&lock));\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  Exchange(Swap)指令：交换两个变量的内容\n\n  ```c++\n  void Exchange(bool *a, bool *b)\n  {\n  \tbool temp = *a;\n  \t*a = *b;\n  \t*b = temp;\n  }\n  \n  //共享变量lock，初始化为false\n  bool lock = false;\n  \n  //进入\n  bool key;\n  key = true;\n  while(key == true)\n     Exchange(lock, key);\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  **优点**\n\n  - 适用于单处理器或者共享主存的多处理器中**任意数量的进程**\n  - 简单并且容易证明\n  - 可以用于支持多临界区\n\n  **缺点**\n\n  - 忙等待消耗处理器时间\n\n  - 当进程离开临界区并且多个进程在等待时候可能导致饥饿\n\n  - 死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区\n\n    ps : 优先级反转来解决\n\n## 死锁(Deadlock)\n\n![](/img/1.png)\n\n[^1]: 部分地方称为制约性\n","slug":"操作系统/操作系统","published":1,"updated":"2021-12-24T09:05:52.570Z","comments":1,"photos":[],"link":"","_id":"cl5o3ztqi00162cuphl06eku4","content":"<h1 id=\"进程管理\">进程管理</h1>\n<h2 id=\"进程-Process\">进程(Process)</h2>\n<h3 id=\"进程的定义\">进程的定义</h3>\n<p>狭义定义：进程是正在运行的程序的实例。</p>\n<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的<strong>分配单元</strong>，也是基本的<strong>执行单元</strong>(是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位)。</p>\n<blockquote>\n<p>描述进程的数据结构：<strong>进程控制块（Process Control Block,PCB）</strong>，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。</p>\n<p>PCB是进程存在的唯一标志。</p>\n<blockquote>\n<p>PCB含有的信息</p>\n<ol>\n<li>\n<p><strong>进程标识信息</strong></p>\n<p>如本进程的标识，本进程的产生者标识（父进程标识）；用户标示</p>\n</li>\n<li>\n<p><strong>处理机状态信息</strong></p>\n<p>保存进程的运行现场信息：</p>\n<ul>\n<li><strong>用户可见寄存器</strong>，用户程序可以使用的数据，地址等寄存器</li>\n<li><strong>控制和状态寄存器</strong>，如程序计数器(PC)，程序状态字(PSW)</li>\n<li><strong>栈指针</strong>，过程调用/系统调用/中断处理和返回时需要用到它</li>\n</ul>\n</li>\n<li>\n<p><strong>进程调度信息/进程控制信息</strong></p>\n<ul>\n<li><strong>调度和状态信息</strong>，用于操作系统调度进程并占用处理机使用</li>\n<li><strong>进程间通信信息</strong>，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中</li>\n<li><strong>存储管理信息</strong>，包含有指向本进程映像存储空间的数据结构</li>\n<li><strong>进程所用资源</strong>，说明由进程打开、使用的系统资源，如打开的文件等</li>\n<li><strong>有关数据结构连接信息</strong>，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>使用PCB</p>\n<ul>\n<li>\n<p>进程的创建：为该进程生成一个PCB</p>\n</li>\n<li>\n<p>进程的终止：回收他的PCB</p>\n</li>\n<li>\n<p>进程的组织管理：通过对PCB的组织管理来实现</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>PCB的组织方式</p>\n<ul>\n<li><strong>线性表方式</strong>：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。</li>\n<li><strong>索引表方式</strong>：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。</li>\n<li><strong>链接表方式</strong>：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。</li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"进程的组成\">进程的组成</h3>\n<p>一个计算机系统进程包括下列资料</p>\n<ul>\n<li>程序的代码</li>\n<li>程序处理的数据</li>\n<li>程序计数器中的值，指示下一条将运行的指令</li>\n<li>一组通用的寄存器的当前值、栈</li>\n<li>一组系统资源（如打开的文件）</li>\n</ul>\n<p>总之，进程包含了正在运行的一个程序所有状态信息。</p>\n<h3 id=\"进程的特点\">进程的特点</h3>\n<ul>\n<li>动态性：可动态地创建、结束进程</li>\n<li>并发性：进程可以被独立调度并占用处理机运行</li>\n<li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位</li>\n<li>异步性<a href=\"%E9%83%A8%E5%88%86%E5%9C%B0%E6%96%B9%E7%A7%B0%E4%B8%BA%E5%88%B6%E7%BA%A6%E6%80%A7\">^1</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li>\n</ul>\n<blockquote>\n<p>并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的</p>\n<p>并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)</p>\n</blockquote>\n<h3 id=\"进程与程序的联系\">进程与程序的联系</h3>\n<ul>\n<li>程序是产生进程的基础</li>\n<li>程序的每次运行构成不同的进程</li>\n<li>进程是程序功能的体现</li>\n<li>通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序</li>\n</ul>\n<h3 id=\"进程与程序的区别\">进程与程序的区别</h3>\n<ul>\n<li>\n<p>进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。</p>\n</li>\n<li>\n<p>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。</p>\n</li>\n<li>\n<p>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程</p>\n<p>状态信息)</p>\n<p><img src=\"./1.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"进程状态-State\">进程状态(State)</h2>\n<h3 id=\"进程的生命期管理\">进程的生命期管理</h3>\n<ul>\n<li>\n<p><strong>进程创建</strong></p>\n<p>引起进程创建的3个主要事件：</p>\n<ul>\n<li>系统初始化时</li>\n<li>用户请求创建一个新进程</li>\n<li>正在运行的进程执行了创建进程的系统调用</li>\n</ul>\n</li>\n<li>\n<p><strong>进程运行</strong></p>\n<p>内核选择一个就绪的进程，让它占用处理机并执行</p>\n</li>\n<li>\n<p><strong>进程等待</strong></p>\n<p>在以下情况下，进程等待（阻塞）</p>\n<ul>\n<li>请求并等待系统服务，无法马上完成</li>\n<li>启动某种操作，无法马上完成</li>\n<li>需要的数据没有到达</li>\n</ul>\n<p>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生</p>\n</li>\n<li>\n<p><strong>进程唤醒</strong></p>\n<p>唤醒进程的原因：</p>\n<ul>\n<li>被阻塞进程需要的资源可被满足</li>\n<li>被阻塞进程等待的事件到达</li>\n<li>将该进程的PCB插入到就绪队列</li>\n</ul>\n<p>进程只能被别的进程或操作系统唤醒</p>\n</li>\n<li>\n<p><strong>进程结束</strong></p>\n<p>在以下情况，进程结束：</p>\n<ul>\n<li>正常退出（自愿）</li>\n<li>错误退出（自愿）</li>\n<li>致命错误（强制）</li>\n<li>被其他进程所杀（强制）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程状态变化模型\">进程状态变化模型</h3>\n<p>进程的三种基本状态：</p>\n<ul>\n<li>\n<p><strong>运行状态(Running)</strong></p>\n<p>当一个进程正在处理机上运行时</p>\n</li>\n<li>\n<p><strong>就绪状态(Ready)</strong></p>\n<p>一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行</p>\n</li>\n<li>\n<p><strong>等待状态(又称阻塞状态Blocked)</strong></p>\n<p>一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成</p>\n<p><img src=\"./3.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>进程的其他基本状态</p>\n<ul>\n<li>\n<p><strong>创建状态(New)</strong></p>\n<p>一个进程正在被创建，还没被转到就绪状态之前的状态</p>\n</li>\n<li>\n<p><strong>结束状态(Exit)</strong></p>\n<p>一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致</p>\n<p><img src=\"./2.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>时间片</strong>（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"进程挂起\">进程挂起</h3>\n<p>进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。</p>\n<p>挂起状态：</p>\n<ul>\n<li>\n<p><strong>阻塞挂起状态</strong>（Blocked-suspend）</p>\n<p>进程在外存并等待某事件的出现</p>\n</li>\n<li>\n<p><strong>就绪挂起状态</strong>（Ready-suspend）</p>\n<p>进程在外存，但只要进入内存，即可运行</p>\n</li>\n</ul>\n<p>与挂起相关的状态转换：</p>\n<ul>\n<li>\n<p>挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>阻塞到阻塞挂起</strong></p>\n<p>没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程</p>\n</li>\n<li>\n<p><strong>就绪到就绪挂起</strong></p>\n<p>当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程</p>\n</li>\n<li>\n<p><strong>运行到就绪挂起</strong></p>\n<p>对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态</p>\n</li>\n</ul>\n</li>\n<li>\n<p>在外存时的状态转换</p>\n<ul>\n<li>\n<p><strong>阻塞挂起到就绪挂起</strong></p>\n<p>当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程</p>\n</li>\n</ul>\n</li>\n<li>\n<p>解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>就绪挂起到就绪</strong></p>\n<p>没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换</p>\n</li>\n<li>\n<p><strong>阻塞挂起到阻塞</strong></p>\n<p>当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"状态队列\">状态队列</h3>\n<ul>\n<li>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态</li>\n<li>不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)</li>\n<li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列</li>\n</ul>\n<p><img src=\"./4.png\" alt=\"\"></p>\n<h2 id=\"线程-Thread\">线程(Thread)</h2>\n<h3 id=\"线程的定义\">线程的定义</h3>\n<p>线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。</p>\n<h3 id=\"线程的优缺点\">线程的优缺点</h3>\n<p>优点：</p>\n<ul>\n<li>一个进程中可以同时存在多个线程</li>\n<li>各个线程之间可以并发地执行</li>\n<li>各个线程之间可以共享地址空间和文件等资源</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>\n</ul>\n<h3 id=\"线程与进程的比较\">线程与进程的比较</h3>\n<ul>\n<li>进程是资源分配单元，线程是CPU调度单元</li>\n<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈</li>\n<li>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系</li>\n<li>线程能减少并发执行的时间和空间开销\n<ul>\n<li>线程的创建时间比进程短</li>\n<li>线程的终止时间比进程短</li>\n<li>同一进程内的线程切换时间比进程短</li>\n<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的实现\">线程的实现</h3>\n<ul>\n<li>\n<p>用户线程：在用户空间实现</p>\n<blockquote>\n<p><strong>用户线程</strong>:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。</p>\n<p>缺点：</p>\n<ul>\n<li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待</li>\n<li>当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行</li>\n<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>内核线程：在内核中实现</p>\n<blockquote>\n<p><strong>内核线程</strong>：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理</p>\n</blockquote>\n</li>\n<li>\n<p>轻量级线程：在内核中实现，支持用户线程</p>\n<blockquote>\n<p><strong>轻量级进程</strong>：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持</p>\n</blockquote>\n</li>\n</ul>\n<p>用户线程与内核线程的对应关系</p>\n<ul>\n<li>多对一</li>\n<li>一对一</li>\n<li>多对多</li>\n</ul>\n<h2 id=\"进程间通信-Inter-process-communication\">进程间通信(Inter-process communication)</h2>\n<h2 id=\"进程互斥与同步\">进程互斥与同步</h2>\n<h3 id=\"基础知识\">基础知识</h3>\n<p><strong>临界区</strong></p>\n<p>**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域</p>\n<p><strong>互斥</strong></p>\n<p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p>\n<p><strong>死锁</strong></p>\n<p>两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去</p>\n<p><strong>饥饿</strong></p>\n<p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p>\n<h3 id=\"实现临界区互斥的基本方法\">实现临界区互斥的基本方法</h3>\n<ul>\n<li>\n<p>禁用中断(仅限于单处理器)</p>\n<p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：<strong>禁止一切中断发生，称之为屏蔽中断或关中断</strong>。<br>\n因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。<br>\n<strong>典型模式为：关中断、临界区、开中断</strong></p>\n<p><strong>缺点</strong></p>\n<p>这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。</p>\n</li>\n<li>\n<p><strong>软件方法(复杂)</strong></p>\n<p><strong>Peterson算法</strong></p>\n<p>Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。</p>\n<p>算法使用两个控制变量<code>flag</code>与<code>turn</code>. 其中<code>flag[n]</code>的值为真，表示ID号为<code>n</code>的进程希望进入该临界区. 变量<code>turn</code>保存有权访问共享资源的进程的ID号.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flag[]是bool数组，turn为int</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//P1</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// flag[1] == true时说明另外一个也想运行，</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[<span class=\"number\">1</span>] == <span class=\"literal\">true</span> &amp;&amp; trun == <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同理P2为</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (flag[<span class=\"number\">0</span>] == <span class=\"literal\">true</span> &amp;&amp; turn == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>复杂：需要两个进程间的共享项</li>\n<li>需要忙等待：浪费CPU时间</li>\n<li>没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令</li>\n</ul>\n</li>\n<li>\n<p><strong>原子操作指令(单处理器或多处理器均可)</strong></p>\n<p>TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">TestAndSet</span><span class=\"params\">(<span class=\"keyword\">bool</span> *lock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> rv = *lock;</span><br><span class=\"line\">    *lock = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock,true表示正在被占用，false表示没被占用</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true-&gt;锁的状态不被改变并且需要循环</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true-&gt;锁被设置为被占用状态，并且需要等待完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">TestAndSet</span>(&amp;lock));</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>Exchange(Swap)指令：交换两个变量的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchange</span><span class=\"params\">(<span class=\"keyword\">bool</span> *a, <span class=\"keyword\">bool</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> temp = *a;</span><br><span class=\"line\">\t*a = *b;</span><br><span class=\"line\">\t*b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock，初始化为false</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> key;</span><br><span class=\"line\">key = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(key == <span class=\"literal\">true</span>)</span><br><span class=\"line\">   <span class=\"built_in\">Exchange</span>(lock, key);</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong></p>\n<ul>\n<li>适用于单处理器或者共享主存的多处理器中<strong>任意数量的进程</strong></li>\n<li>简单并且容易证明</li>\n<li>可以用于支持多临界区</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>\n<p>忙等待消耗处理器时间</p>\n</li>\n<li>\n<p>当进程离开临界区并且多个进程在等待时候可能导致饥饿</p>\n</li>\n<li>\n<p>死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区</p>\n<p>ps : 优先级反转来解决</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"死锁-Deadlock\">死锁(Deadlock)</h2>\n<p><img src=\"/img/1.png\" alt=\"\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"BearChild","link":"https://www.bearchild.top/","avatar":"https://s4.ax1x.com/2022/02/26/bVF80J.jpg","descr":"前路浩荡，未来可期！"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://i.loli.net/2021/11/22/wm8CdvX1aHoLPJY.jpg","excerpt":"","more":"<h1 id=\"进程管理\">进程管理</h1>\n<h2 id=\"进程-Process\">进程(Process)</h2>\n<h3 id=\"进程的定义\">进程的定义</h3>\n<p>狭义定义：进程是正在运行的程序的实例。</p>\n<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的<strong>分配单元</strong>，也是基本的<strong>执行单元</strong>(是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位)。</p>\n<blockquote>\n<p>描述进程的数据结构：<strong>进程控制块（Process Control Block,PCB）</strong>，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。</p>\n<p>PCB是进程存在的唯一标志。</p>\n<blockquote>\n<p>PCB含有的信息</p>\n<ol>\n<li>\n<p><strong>进程标识信息</strong></p>\n<p>如本进程的标识，本进程的产生者标识（父进程标识）；用户标示</p>\n</li>\n<li>\n<p><strong>处理机状态信息</strong></p>\n<p>保存进程的运行现场信息：</p>\n<ul>\n<li><strong>用户可见寄存器</strong>，用户程序可以使用的数据，地址等寄存器</li>\n<li><strong>控制和状态寄存器</strong>，如程序计数器(PC)，程序状态字(PSW)</li>\n<li><strong>栈指针</strong>，过程调用/系统调用/中断处理和返回时需要用到它</li>\n</ul>\n</li>\n<li>\n<p><strong>进程调度信息/进程控制信息</strong></p>\n<ul>\n<li><strong>调度和状态信息</strong>，用于操作系统调度进程并占用处理机使用</li>\n<li><strong>进程间通信信息</strong>，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中</li>\n<li><strong>存储管理信息</strong>，包含有指向本进程映像存储空间的数据结构</li>\n<li><strong>进程所用资源</strong>，说明由进程打开、使用的系统资源，如打开的文件等</li>\n<li><strong>有关数据结构连接信息</strong>，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>使用PCB</p>\n<ul>\n<li>\n<p>进程的创建：为该进程生成一个PCB</p>\n</li>\n<li>\n<p>进程的终止：回收他的PCB</p>\n</li>\n<li>\n<p>进程的组织管理：通过对PCB的组织管理来实现</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>PCB的组织方式</p>\n<ul>\n<li><strong>线性表方式</strong>：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。</li>\n<li><strong>索引表方式</strong>：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。</li>\n<li><strong>链接表方式</strong>：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。</li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"进程的组成\">进程的组成</h3>\n<p>一个计算机系统进程包括下列资料</p>\n<ul>\n<li>程序的代码</li>\n<li>程序处理的数据</li>\n<li>程序计数器中的值，指示下一条将运行的指令</li>\n<li>一组通用的寄存器的当前值、栈</li>\n<li>一组系统资源（如打开的文件）</li>\n</ul>\n<p>总之，进程包含了正在运行的一个程序所有状态信息。</p>\n<h3 id=\"进程的特点\">进程的特点</h3>\n<ul>\n<li>动态性：可动态地创建、结束进程</li>\n<li>并发性：进程可以被独立调度并占用处理机运行</li>\n<li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位</li>\n<li>异步性<a href=\"%E9%83%A8%E5%88%86%E5%9C%B0%E6%96%B9%E7%A7%B0%E4%B8%BA%E5%88%B6%E7%BA%A6%E6%80%A7\">^1</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li>\n</ul>\n<blockquote>\n<p>并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的</p>\n<p>并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)</p>\n</blockquote>\n<h3 id=\"进程与程序的联系\">进程与程序的联系</h3>\n<ul>\n<li>程序是产生进程的基础</li>\n<li>程序的每次运行构成不同的进程</li>\n<li>进程是程序功能的体现</li>\n<li>通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序</li>\n</ul>\n<h3 id=\"进程与程序的区别\">进程与程序的区别</h3>\n<ul>\n<li>\n<p>进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。</p>\n</li>\n<li>\n<p>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。</p>\n</li>\n<li>\n<p>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程</p>\n<p>状态信息)</p>\n<p><img src=\"./1.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"进程状态-State\">进程状态(State)</h2>\n<h3 id=\"进程的生命期管理\">进程的生命期管理</h3>\n<ul>\n<li>\n<p><strong>进程创建</strong></p>\n<p>引起进程创建的3个主要事件：</p>\n<ul>\n<li>系统初始化时</li>\n<li>用户请求创建一个新进程</li>\n<li>正在运行的进程执行了创建进程的系统调用</li>\n</ul>\n</li>\n<li>\n<p><strong>进程运行</strong></p>\n<p>内核选择一个就绪的进程，让它占用处理机并执行</p>\n</li>\n<li>\n<p><strong>进程等待</strong></p>\n<p>在以下情况下，进程等待（阻塞）</p>\n<ul>\n<li>请求并等待系统服务，无法马上完成</li>\n<li>启动某种操作，无法马上完成</li>\n<li>需要的数据没有到达</li>\n</ul>\n<p>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生</p>\n</li>\n<li>\n<p><strong>进程唤醒</strong></p>\n<p>唤醒进程的原因：</p>\n<ul>\n<li>被阻塞进程需要的资源可被满足</li>\n<li>被阻塞进程等待的事件到达</li>\n<li>将该进程的PCB插入到就绪队列</li>\n</ul>\n<p>进程只能被别的进程或操作系统唤醒</p>\n</li>\n<li>\n<p><strong>进程结束</strong></p>\n<p>在以下情况，进程结束：</p>\n<ul>\n<li>正常退出（自愿）</li>\n<li>错误退出（自愿）</li>\n<li>致命错误（强制）</li>\n<li>被其他进程所杀（强制）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程状态变化模型\">进程状态变化模型</h3>\n<p>进程的三种基本状态：</p>\n<ul>\n<li>\n<p><strong>运行状态(Running)</strong></p>\n<p>当一个进程正在处理机上运行时</p>\n</li>\n<li>\n<p><strong>就绪状态(Ready)</strong></p>\n<p>一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行</p>\n</li>\n<li>\n<p><strong>等待状态(又称阻塞状态Blocked)</strong></p>\n<p>一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成</p>\n<p><img src=\"./3.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>进程的其他基本状态</p>\n<ul>\n<li>\n<p><strong>创建状态(New)</strong></p>\n<p>一个进程正在被创建，还没被转到就绪状态之前的状态</p>\n</li>\n<li>\n<p><strong>结束状态(Exit)</strong></p>\n<p>一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致</p>\n<p><img src=\"./2.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>时间片</strong>（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"进程挂起\">进程挂起</h3>\n<p>进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。</p>\n<p>挂起状态：</p>\n<ul>\n<li>\n<p><strong>阻塞挂起状态</strong>（Blocked-suspend）</p>\n<p>进程在外存并等待某事件的出现</p>\n</li>\n<li>\n<p><strong>就绪挂起状态</strong>（Ready-suspend）</p>\n<p>进程在外存，但只要进入内存，即可运行</p>\n</li>\n</ul>\n<p>与挂起相关的状态转换：</p>\n<ul>\n<li>\n<p>挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>阻塞到阻塞挂起</strong></p>\n<p>没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程</p>\n</li>\n<li>\n<p><strong>就绪到就绪挂起</strong></p>\n<p>当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程</p>\n</li>\n<li>\n<p><strong>运行到就绪挂起</strong></p>\n<p>对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态</p>\n</li>\n</ul>\n</li>\n<li>\n<p>在外存时的状态转换</p>\n<ul>\n<li>\n<p><strong>阻塞挂起到就绪挂起</strong></p>\n<p>当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程</p>\n</li>\n</ul>\n</li>\n<li>\n<p>解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>就绪挂起到就绪</strong></p>\n<p>没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换</p>\n</li>\n<li>\n<p><strong>阻塞挂起到阻塞</strong></p>\n<p>当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"状态队列\">状态队列</h3>\n<ul>\n<li>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态</li>\n<li>不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)</li>\n<li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列</li>\n</ul>\n<p><img src=\"./4.png\" alt=\"\"></p>\n<h2 id=\"线程-Thread\">线程(Thread)</h2>\n<h3 id=\"线程的定义\">线程的定义</h3>\n<p>线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。</p>\n<h3 id=\"线程的优缺点\">线程的优缺点</h3>\n<p>优点：</p>\n<ul>\n<li>一个进程中可以同时存在多个线程</li>\n<li>各个线程之间可以并发地执行</li>\n<li>各个线程之间可以共享地址空间和文件等资源</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>\n</ul>\n<h3 id=\"线程与进程的比较\">线程与进程的比较</h3>\n<ul>\n<li>进程是资源分配单元，线程是CPU调度单元</li>\n<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈</li>\n<li>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系</li>\n<li>线程能减少并发执行的时间和空间开销\n<ul>\n<li>线程的创建时间比进程短</li>\n<li>线程的终止时间比进程短</li>\n<li>同一进程内的线程切换时间比进程短</li>\n<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的实现\">线程的实现</h3>\n<ul>\n<li>\n<p>用户线程：在用户空间实现</p>\n<blockquote>\n<p><strong>用户线程</strong>:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。</p>\n<p>缺点：</p>\n<ul>\n<li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待</li>\n<li>当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行</li>\n<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>内核线程：在内核中实现</p>\n<blockquote>\n<p><strong>内核线程</strong>：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理</p>\n</blockquote>\n</li>\n<li>\n<p>轻量级线程：在内核中实现，支持用户线程</p>\n<blockquote>\n<p><strong>轻量级进程</strong>：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持</p>\n</blockquote>\n</li>\n</ul>\n<p>用户线程与内核线程的对应关系</p>\n<ul>\n<li>多对一</li>\n<li>一对一</li>\n<li>多对多</li>\n</ul>\n<h2 id=\"进程间通信-Inter-process-communication\">进程间通信(Inter-process communication)</h2>\n<h2 id=\"进程互斥与同步\">进程互斥与同步</h2>\n<h3 id=\"基础知识\">基础知识</h3>\n<p><strong>临界区</strong></p>\n<p>**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域</p>\n<p><strong>互斥</strong></p>\n<p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p>\n<p><strong>死锁</strong></p>\n<p>两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去</p>\n<p><strong>饥饿</strong></p>\n<p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p>\n<h3 id=\"实现临界区互斥的基本方法\">实现临界区互斥的基本方法</h3>\n<ul>\n<li>\n<p>禁用中断(仅限于单处理器)</p>\n<p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：<strong>禁止一切中断发生，称之为屏蔽中断或关中断</strong>。<br>\n因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。<br>\n<strong>典型模式为：关中断、临界区、开中断</strong></p>\n<p><strong>缺点</strong></p>\n<p>这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。</p>\n</li>\n<li>\n<p><strong>软件方法(复杂)</strong></p>\n<p><strong>Peterson算法</strong></p>\n<p>Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。</p>\n<p>算法使用两个控制变量<code>flag</code>与<code>turn</code>. 其中<code>flag[n]</code>的值为真，表示ID号为<code>n</code>的进程希望进入该临界区. 变量<code>turn</code>保存有权访问共享资源的进程的ID号.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flag[]是bool数组，turn为int</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//P1</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// flag[1] == true时说明另外一个也想运行，</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[<span class=\"number\">1</span>] == <span class=\"literal\">true</span> &amp;&amp; trun == <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同理P2为</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (flag[<span class=\"number\">0</span>] == <span class=\"literal\">true</span> &amp;&amp; turn == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>复杂：需要两个进程间的共享项</li>\n<li>需要忙等待：浪费CPU时间</li>\n<li>没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令</li>\n</ul>\n</li>\n<li>\n<p><strong>原子操作指令(单处理器或多处理器均可)</strong></p>\n<p>TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">TestAndSet</span><span class=\"params\">(<span class=\"keyword\">bool</span> *lock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> rv = *lock;</span><br><span class=\"line\">    *lock = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock,true表示正在被占用，false表示没被占用</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true-&gt;锁的状态不被改变并且需要循环</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true-&gt;锁被设置为被占用状态，并且需要等待完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">TestAndSet</span>(&amp;lock));</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>Exchange(Swap)指令：交换两个变量的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchange</span><span class=\"params\">(<span class=\"keyword\">bool</span> *a, <span class=\"keyword\">bool</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> temp = *a;</span><br><span class=\"line\">\t*a = *b;</span><br><span class=\"line\">\t*b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock，初始化为false</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> key;</span><br><span class=\"line\">key = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(key == <span class=\"literal\">true</span>)</span><br><span class=\"line\">   <span class=\"built_in\">Exchange</span>(lock, key);</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong></p>\n<ul>\n<li>适用于单处理器或者共享主存的多处理器中<strong>任意数量的进程</strong></li>\n<li>简单并且容易证明</li>\n<li>可以用于支持多临界区</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>\n<p>忙等待消耗处理器时间</p>\n</li>\n<li>\n<p>当进程离开临界区并且多个进程在等待时候可能导致饥饿</p>\n</li>\n<li>\n<p>死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区</p>\n<p>ps : 优先级反转来解决</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"死锁-Deadlock\">死锁(Deadlock)</h2>\n<p><img src=\"/img/1.png\" alt=\"\"></p>\n"}],"PostAsset":[{"_id":"source/_posts/CS面试基础知识/RX_36I`V7SC3ZSYNM~EMC{T.png","post":"cl5o3ztpz00012cup7mco7jzn","slug":"RX_36I`V7SC3ZSYNM~EMC{T.png","modified":1,"renderable":1},{"_id":"source/_posts/Lua设计与实现读书笔记/1.png","post":"cl5o3ztq700092cupgmsa7yqm","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Lua设计与实现读书笔记/}179[UY3OP~C{R3)L0G%KZW.png","post":"cl5o3ztq700092cupgmsa7yqm","slug":"}179[UY3OP~C{R3)L0G%KZW.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cl5o3ztq700092cupgmsa7yqm","category_id":"cl5o3ztq300042cupeb2y1y0y","_id":"cl5o3ztqb000h2cupgo1ae5dq"},{"post_id":"cl5o3ztpz00012cup7mco7jzn","category_id":"cl5o3ztq300042cupeb2y1y0y","_id":"cl5o3ztqc000m2cupe5pycfm2"},{"post_id":"cl5o3ztq7000a2cup5o0hd4t9","category_id":"cl5o3ztq300042cupeb2y1y0y","_id":"cl5o3ztqc000o2cupghoh1nbn"},{"post_id":"cl5o3ztq9000e2cup8ogj8ceb","category_id":"cl5o3ztq300042cupeb2y1y0y","_id":"cl5o3ztqd000s2cup3vtkhbrh"},{"post_id":"cl5o3ztq200032cup00hn4zoo","category_id":"cl5o3ztq300042cupeb2y1y0y","_id":"cl5o3ztqd000u2cupf10dfoph"},{"post_id":"cl5o3ztqc000l2cup7y6o7bt7","category_id":"cl5o3ztqb000i2cup2ptpff25","_id":"cl5o3ztqd000w2cup02plg6vv"},{"post_id":"cl5o3ztq500072cup43h8cc4p","category_id":"cl5o3ztqb000i2cup2ptpff25","_id":"cl5o3ztqe000y2cupf9vh2zk7"},{"post_id":"cl5o3ztqa000g2cupa70nb55g","category_id":"cl5o3ztqc000p2cup4m088tsv","_id":"cl5o3ztqe00102cupen20g45k"},{"post_id":"cl5o3ztqg00132cup82v407xi","category_id":"cl5o3ztq300042cupeb2y1y0y","_id":"cl5o3ztqk00192cupe6kn3hkx"},{"post_id":"cl5o3ztqi00162cuphl06eku4","category_id":"cl5o3ztqb000i2cup2ptpff25","_id":"cl5o3ztql001b2cupcr5aau4z"},{"post_id":"cl5o3ztqh00142cup1aed1973","category_id":"cl5o3ztqi00172cup3t7q6m28","_id":"cl5o3ztql001d2cup9bx70i5i"}],"PostTag":[{"post_id":"cl5o3ztpz00012cup7mco7jzn","tag_id":"cl5o3ztq400052cup9wry8t6d","_id":"cl5o3ztq9000d2cupbku45av4"},{"post_id":"cl5o3ztq7000a2cup5o0hd4t9","tag_id":"cl5o3ztq400052cup9wry8t6d","_id":"cl5o3ztqa000f2cup2y706wzj"},{"post_id":"cl5o3ztq9000e2cup8ogj8ceb","tag_id":"cl5o3ztq400052cup9wry8t6d","_id":"cl5o3ztqb000k2cupgec7gusk"},{"post_id":"cl5o3ztq200032cup00hn4zoo","tag_id":"cl5o3ztq400052cup9wry8t6d","_id":"cl5o3ztqc000n2cupejqc9lya"},{"post_id":"cl5o3ztqc000l2cup7y6o7bt7","tag_id":"cl5o3ztqb000j2cup5ojn4mpn","_id":"cl5o3ztqd000r2cup8sztb9e9"},{"post_id":"cl5o3ztq500072cup43h8cc4p","tag_id":"cl5o3ztqb000j2cup5ojn4mpn","_id":"cl5o3ztqd000t2cupcjdk8xfr"},{"post_id":"cl5o3ztq700092cupgmsa7yqm","tag_id":"cl5o3ztqd000q2cupag66g13a","_id":"cl5o3ztqd000x2cupgora8fpk"},{"post_id":"cl5o3ztqa000g2cupa70nb55g","tag_id":"cl5o3ztqd000v2cup8jj9hhgm","_id":"cl5o3ztqe00112cuphc2v58uo"},{"post_id":"cl5o3ztqa000g2cupa70nb55g","tag_id":"cl5o3ztqd000q2cupag66g13a","_id":"cl5o3ztqe00122cup8k2i70n8"},{"post_id":"cl5o3ztqg00132cup82v407xi","tag_id":"cl5o3ztq400052cup9wry8t6d","_id":"cl5o3ztqi00152cup1ug9c9xl"},{"post_id":"cl5o3ztqh00142cup1aed1973","tag_id":"cl5o3ztqd000v2cup8jj9hhgm","_id":"cl5o3ztqk00182cup6xqyhcne"},{"post_id":"cl5o3ztqi00162cuphl06eku4","tag_id":"cl5o3ztqk001a2cup6umj2ua0","_id":"cl5o3ztql001c2cup96q64nnh"}],"Tag":[{"name":"c#","_id":"cl5o3ztq400052cup9wry8t6d"},{"name":"算法","_id":"cl5o3ztqb000j2cup5ojn4mpn"},{"name":"Lua","_id":"cl5o3ztqd000q2cupag66g13a"},{"name":"Unity","_id":"cl5o3ztqd000v2cup8jj9hhgm"},{"name":"操作系统","_id":"cl5o3ztqk001a2cup6umj2ua0"}]}}
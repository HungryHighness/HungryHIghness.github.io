{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/img/1.png","path":"img/1.png","modified":0,"renderable":0},{"_id":"source/img/background.png","path":"img/background.png","modified":0,"renderable":0},{"_id":"source/img/cover_1.png","path":"img/cover_1.png","modified":0,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/favicon.jpg","path":"img/favicon.jpg","modified":0,"renderable":0},{"_id":"source/img/background_2.jpg","path":"img/background_2.jpg","modified":0,"renderable":0},{"_id":"source/img/psc.jpg","path":"img/psc.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/leetcode.md","hash":"ca95ce086f7343b227fde07728f9cfc7de562f12","modified":1637345754056},{"_id":"source/tags/index.md","hash":"1b5b0d109bfac93bd57c487db63b17a31e16fd84","modified":1635070631425},{"_id":"source/link/index.md","hash":"29af8760406bf382fe0ffbe76e9bf4678dce72a8","modified":1635070670717},{"_id":"source/categories/index.md","hash":"ae340f099d6b6e7eff970e6520a9065732e33eed","modified":1635070601834},{"_id":"source/_data/link.yml","hash":"a6916d38cd25f9e4887fc5bfea1f6ed2ea72e97e","modified":1635070733870},{"_id":"source/_posts/操作系统/操作系统.md","hash":"97677d1057b5f74ac13ce3b35c51ef65113a0513","modified":1635825630238},{"_id":"themes/butterfly/_config.yml","hash":"d9593b423071020f7b970dd932128be03b9ad3e3","modified":1635829734360},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1635829734357},{"_id":"themes/butterfly/languages/default.yml","hash":"b9dbdb20bd1f1c7ca8a8f38635bdc4ed8bb1d44c","modified":1635829734360},{"_id":"themes/butterfly/languages/en.yml","hash":"fd1c1211c8f166d089a7697872185a81182d92e1","modified":1635829734361},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"46685048a05b419ed9c72cf31bd6e5efef7524f2","modified":1635829734361},{"_id":"themes/butterfly/package.json","hash":"6a5ddc166980502757c1413b5e04a3a8a91c0a48","modified":1635829734398},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"736bec8eeb3a29d0d43669d81f1fa686e02be18e","modified":1635829734362},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1635829734362},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1635829734397},{"_id":"themes/butterfly/layout/page.pug","hash":"cae76ce64c114fd192b5da5a7d14aa0240df2f06","modified":1635829734397},{"_id":"themes/butterfly/layout/post.pug","hash":"8f2f13c9ae099dd83827ce3dbac5abc8d7d5bde3","modified":1635829734398},{"_id":"themes/butterfly/layout/category.pug","hash":"5ac3cd8172088843cec03175c612a9c85f49cf2e","modified":1635829734362},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1635829734398},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1635829734358},{"_id":"themes/butterfly/README_CN.md","hash":"70ec43a8aa0776b5a0a2a6b6009dd253fa3679eb","modified":1635829734359},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1635829734356},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"3cdc5e32d0f1e5866bcf86f94a0d76aaf7142937","modified":1635829734363},{"_id":"themes/butterfly/README.md","hash":"0f0eaee9c30ef1e9aed588fbb3e8263401348b55","modified":1635829734358},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"a1ca58fdff74b890cade94479f8f0eb9ce7e5e73","modified":1635829734363},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1635829734364},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1635829734356},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"f4dcc0a596eb9801c4d3c033d018d0abb413c8e5","modified":1635829734364},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f2e1d8a05d2e409c4804f67a98f5f59f527d6627","modified":1635829734370},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1635829734373},{"_id":"themes/butterfly/scripts/events/init.js","hash":"5803aa55d9c21e51ea64c1ae50c9b602979aaee2","modified":1635829734399},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1635829734374},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9b5243385f7a90e0103c25c531a1e7f2f1884c15","modified":1635829734375},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1635829734399},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"98ef86305b8d2ad9dbab969715e1ac93b407f036","modified":1635829734400},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"bd29f20fad3d3fab600940e7a6dc9a803943cb33","modified":1635829734401},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1635829734401},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1635829734401},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"98ab13a60413d68bd9d02d54d121c66a6d4634d2","modified":1635829734402},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1635829734400},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1635829734402},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"26dd1900e68a3e10a5cf3f3484a93139a0f1340e","modified":1635829734403},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1635829734404},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1635829734403},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1635829734404},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1635829734404},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1635829734405},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1635829734405},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"8cb7ef368cc2ac7f4a13c2959908b1574e572acf","modified":1635829734403},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1635829734424},{"_id":"themes/butterfly/source/css/var.styl","hash":"31198af95fecc6819d3b2cb7ef03988ef67257da","modified":1635829734425},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1635829734426},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1635829734356},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1635829734405},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1635829734357},{"_id":"themes/butterfly/source/js/main.js","hash":"53c6df70de6e7949b102ab06fd0cd53b9b39b01c","modified":1635829734427},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1635829734425},{"_id":"themes/butterfly/source/js/utils.js","hash":"1b8bf1e6d50fa8ffe2aff7548b141cab72540ba0","modified":1635829734429},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1635829734365},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"3ca9d9cdfd6e61df1d5b07de40f34349cda7a7c7","modified":1635829734365},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"73c04d62055840545112dd12d73807835ca62347","modified":1635829734366},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1635829734366},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1635829734366},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"d6556d5396eb0e10ea0ec10158779c21dc78f738","modified":1635829734367},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"903d12250ce70713dd5b8ac7e1f7a20fe15eb815","modified":1635829734365},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1635829734367},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1635829734367},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"4d52000cae1fce333329c382dac6c9a21ad0b195","modified":1635829734368},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7677911bd3f43edaf8230eea02f60a248eee9934","modified":1635829734369},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1635829734369},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"419807903e5586b8804b1f8f17cea97bd05f0b17","modified":1635829734369},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"3a2797d2744607ba6cdb5a02853851957c0f7e29","modified":1635829734368},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1635829734371},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1635829734370},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"dcccb1425fabcf12a1bed955518b0e7b1054cab0","modified":1635829734371},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1635829734372},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1635829734371},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1635829734372},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"9aa743b1f6fb7fafabee38f9204ce9c8f1be7f9a","modified":1635829734372},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"c762732e200ff2627bc046af5f170b3269343341","modified":1635829734374},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1635829734376},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1635829734374},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1635829734373},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1635829734385},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"ad59dcce32e4e67066303a1ffd1dd95874d9953e","modified":1635829734389},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1635829734389},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1635829734389},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"4a2ea9fe59f1dc8cb4f4f6a28cf24a40fc300254","modified":1635829734393},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1635829734393},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"6c3449a44ae1a80f71dd4d9d6a85cec1781ceff1","modified":1635829734394},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1635829734394},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1635829734394},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1635829734393},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1635829734395},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"0f1a5c356c1ffd47ff49e153226e2d670dc61057","modified":1635829734395},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"0b5c165664f9f8691551fc5ff435b40e7f73c737","modified":1635829734395},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1635829734396},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1635829734396},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1635829734396},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"03164bca4546707543828cb2a41bc672b77bfa5a","modified":1635829734407},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"e4c39101d7087066a86f7743985a53d6a246470b","modified":1635829734397},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1635829734396},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f9de9db2a49ac4d5447660ab159171ac5c228e3c","modified":1635829734406},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"23ea60f8becc91f6e9f6cfb1cbfd25689c263b9c","modified":1635829734411},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2e8e391b211b2416d3c9430ab5361659c073f348","modified":1635829734408},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1635829734411},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"f25415a436100688248fef0ad90e3d4397627833","modified":1635829734410},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1635829734427},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1635829734411},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1635829734413},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"dd71e34edece4e06b59e941fb3cc5ad9a3ad09cf","modified":1635829734412},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1635829734426},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1635829734412},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"814729d1d71f4326623a4f34b621bf0421503103","modified":1635829734413},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"db7fe645662d87be4f8dfc08e55bbe1a3734bf93","modified":1635829734413},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"4ae98e703440b616d2a36da139bda844c94d425e","modified":1635829734414},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"8c4e08c8a63dacdfb2a733a0d0035fa97c7f5e9e","modified":1635829734414},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"191ce31ce0f2b1d22a64225801a88cee6054f574","modified":1635829734415},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a00ad74074513a1c7f6e02977b8fa778beaa2108","modified":1635829734414},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"943aa34c83c87d0225db65ae90621870472972fa","modified":1635829734415},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"8489722684aa9b4baa38386f4d4b39f4dbd60113","modified":1635829734416},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"87c576a3361f30eefafec27a872ad76e9fbb2765","modified":1635829734417},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1635829734417},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"89a6cb63a97cc08675319c403e4a89391f6ab401","modified":1635829734416},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1635829734417},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"48ad198d0ea97a25db4d2a3e587a16ef41617c0b","modified":1635829734418},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"0da09b1811a776106ca66c56be6e2a396dca5680","modified":1635829734418},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"c3369a14f4111c098d0177036ca57df6deb59d72","modified":1635829734421},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"5e5c1d6d104cc15314ae365d0da7cb07334a6457","modified":1635829734418},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1635829734419},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1635829734421},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"e65ed98056e6c91e622f94bad5283d00fdb22142","modified":1635829734420},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1635829734421},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1635829734422},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1635829734422},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"c91609b7f431cacecc3718ae2fb7403c55f8267a","modified":1635829734422},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1635829734423},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"fa2985afd08556b25f5f1a01bc1a7c76b294a962","modified":1635829734420},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1635829734424},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1635829734423},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"25ac939fc57346de07ba9e15a1a760b492baefd7","modified":1635829734419},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1635829734376},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1635829734377},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1635829734377},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1635829734377},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1635829734378},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1635829734378},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1635829734379},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1635829734380},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1635829734381},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1635829734380},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"50126b2e841b01584b8b65b2f834038e3997b694","modified":1635829734381},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0bf6a47e804fb793b40f82690a24816b902edd41","modified":1635829734381},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"d97403cdd58c759cfd1752dd85aa4a0f9b73dc46","modified":1635829734382},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0254203aae73e70b90dfce6ec4f9c9d3be9ac9f8","modified":1635829734382},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"e877c98949873a62659db7501d19eb3d66650b51","modified":1635829734382},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1635829734383},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1635829734383},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"afffc4ac8ce93d39dcc892bd518805cf33531244","modified":1635829734383},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"8290994cf1ee2faff60214ff245cf513fbbe94aa","modified":1635829734384},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0bf1c53b914443c66be5077ff09cfc218f111e11","modified":1635829734384},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1635829734386},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1635829734385},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1635829734386},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1635829734386},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"8890becd8220c57db2c7451409710942c103a7f4","modified":1635829734387},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0ad766ae491e6fcba2ef3d136a7af6158cd4153e","modified":1635829734387},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"767c38e3dfa0097b0dc1fdfd0df292c16f757d05","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"a3d43cc360666b5b9730e8bb9e5c8fd940ae5b3d","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"83103bad0db195bce095330c4a84e7529bbd40dd","modified":1635829734388},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1635829734390},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1635829734390},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1635829734391},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1635829734392},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1635829734391},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1635829734392},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1635829734392},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"b0916c8c7d15b67b55cb1618be8370870fedbf42","modified":1635829734408},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"b74c61f6e15b422e9d2df23133552bbd1b5fe513","modified":1635829734409},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"4d71aab9082c67d3ee52ad58dfc3c1c9b41f2ab1","modified":1635829734410},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1635829734429},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1635829734428},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1635829734409},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"54378d52d275e4ab84173bb02e17ea02ae46e55f","modified":1635829734428},{"_id":"source/img/1.png","hash":"c814776079d2b4c49df12703048d9791ffa4fbaa","modified":1635073565499},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1635829734410},{"_id":"source/img/background.png","hash":"f26a50f7ba402b4125b1ba9259e06762a1791428","modified":1634813687669},{"_id":"public/categories/index.html","hash":"5e0e8cc4520b236e4c6acdcff03dcf13dd7b6a78","modified":1637349538157},{"_id":"public/tags/index.html","hash":"bbf2772b16e13e330fd686f8bd9d34f06a84fae5","modified":1637349538157},{"_id":"public/archives/index.html","hash":"d730b5a96fc3436dd3c962ab9035488f3433a0af","modified":1637349538157},{"_id":"public/archives/2021/index.html","hash":"8220504c024ee36969d706ab182972e7a7b8316c","modified":1637349538157},{"_id":"public/archives/2021/10/index.html","hash":"50babe7d1572dc59dad84f41a6b6a8e3a385febc","modified":1637349538157},{"_id":"public/archives/2021/11/index.html","hash":"d99c1ebd6726720541ce21b88f038892b1ea70f1","modified":1637349538157},{"_id":"public/link/index.html","hash":"a5297ceb0ad84490a2b3adab26ba6c5a3e49d1ac","modified":1637349538157},{"_id":"public/2021/11/01/leetcode/index.html","hash":"9c9422d00d1addbcc04a8de6529108a8e833e343","modified":1637347726592},{"_id":"public/2021/10/24/操作系统/操作系统/index.html","hash":"3098959fbb0321170b34261774f074a01a6da9e3","modified":1637347726592},{"_id":"public/index.html","hash":"8e648707dfe19391b469745ff2e27656c3471791","modified":1637349538157},{"_id":"public/tags/计算机基础知识/index.html","hash":"0d8fdc899da34e67072631446dec75bc5904acfd","modified":1637349538157},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1635833612579},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1635833612579},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1635833612579},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1635833612579},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1635833612579},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1635833612579},{"_id":"public/js/search/local-search.js","hash":"b1429e9f80ef6b9a77434819ffb87d90bdad25e8","modified":1635833612579},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1635833612579},{"_id":"public/css/index.css","hash":"d5a995f810ca6adf42a3ba6894fd319e97848574","modified":1635833612579},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1635833612579},{"_id":"public/js/main.js","hash":"b244f28124a46d7f1e8ef76ba6e925289691f93b","modified":1635833612579},{"_id":"public/img/1.png","hash":"c814776079d2b4c49df12703048d9791ffa4fbaa","modified":1635833612579},{"_id":"public/img/background.png","hash":"f26a50f7ba402b4125b1ba9259e06762a1791428","modified":1635833612579},{"_id":"source/img/ArticleCover_1.jpg","hash":"0f0e26842fddc5cac701837d60f2791bab909873","modified":1637338203072},{"_id":"source/img/AricleCover_2.jpg","hash":"ca9c387a644a990f7663a5c21000138d87d14418","modified":1637338473069},{"_id":"source/img/cover_1.jpg","hash":"0f0e26842fddc5cac701837d60f2791bab909873","modified":1637338203072},{"_id":"source/img/cover_2.jpg","hash":"ca9c387a644a990f7663a5c21000138d87d14418","modified":1637338473069},{"_id":"source/img/cover_1.png","hash":"0f0e26842fddc5cac701837d60f2791bab909873","modified":1637338203072},{"_id":"source/img/cover_2.png","hash":"ca9c387a644a990f7663a5c21000138d87d14418","modified":1637338473069},{"_id":"source/img/avatar.jpg","hash":"ca9c387a644a990f7663a5c21000138d87d14418","modified":1637338473069},{"_id":"source/img/favicon.jpg","hash":"f909901855f432850a03f208b22cc07d4b13625c","modified":1637340698935},{"_id":"source/img/2.jpg","hash":"f909901855f432850a03f208b22cc07d4b13625c","modified":1637340698935},{"_id":"source/about/index.md","hash":"a4e6ef769433215ddb0c2f16597f1c36564b4ecc","modified":1637343485311},{"_id":"source/img/background_2.jpg","hash":"476f439546785a49f1f33cd93b4a9e8e9f61acec","modified":1637345958781},{"_id":"public/about/index.html","hash":"c21d0f5ec305072f48bc9013f2d462c0272ab776","modified":1637348242831},{"_id":"public/img/cover_1.png","hash":"0f0e26842fddc5cac701837d60f2791bab909873","modified":1637347726592},{"_id":"public/img/favicon.jpg","hash":"e63a56d59624f7d7cc8c307a7453873b7331f43d","modified":1637347726592},{"_id":"public/img/2.jpg","hash":"f909901855f432850a03f208b22cc07d4b13625c","modified":1637347726592},{"_id":"public/img/avatar.jpg","hash":"ca9c387a644a990f7663a5c21000138d87d14418","modified":1637347726592},{"_id":"public/img/background_2.jpg","hash":"476f439546785a49f1f33cd93b4a9e8e9f61acec","modified":1637347726592},{"_id":"source/img/psc.jpg","hash":"e63a56d59624f7d7cc8c307a7453873b7331f43d","modified":1637341839497},{"_id":"public/img/psc.jpg","hash":"e63a56d59624f7d7cc8c307a7453873b7331f43d","modified":1637349538157}],"Category":[],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"分类","date":"2021-10-24T10:16:21.000Z","type":"categories","_content":"\n","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-10-24 18:16:21\ntype: \"categories\"\n---\n\n","updated":"2021-10-24T10:16:41.834Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckvhp3k3200008wup7dsg9pjx","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/background.png","excerpt":"","more":""},{"title":"友链","date":"2021-10-24T10:17:24.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友链\ndate: 2021-10-24 18:17:24\ntype: \"link\"\n---\n","updated":"2021-10-24T10:17:50.717Z","path":"link/index.html","comments":1,"layout":"page","_id":"ckvhp3k3400018wup7bh308xk","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/background.png","excerpt":"","more":""},{"title":"标签","date":"2021-10-24T10:14:45.000Z","type":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-10-24 18:14:45\ntype : \"tags\"\n---\n\n","updated":"2021-10-24T10:17:11.425Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckvhp3k3600028wup3n2w7tjp","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/background.png","excerpt":"","more":""}],"Post":[{"title":"leetcode刷题记录","date":"2021-11-01T05:50:37.000Z","_content":"\n# [575. 分糖果](https://leetcode-cn.com/problems/distribute-candies/)\n\n---\n\n难度 `简单` | 标签 `数组` `哈希表` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果<strong>平均</strong>分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,2,3,3]\n<strong>输出:</strong> 3\n<strong>解析: </strong>一共有三种种类的糖果，每一种都有两个。\n     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。\n</pre>\n<p><strong>示例 2 :</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,3]\n<strong>输出:</strong> 2\n<strong>解析:</strong> 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>数组的长度为[2, 10,000]，并且确定为偶数。</li>\n\t<li>数组中数字的大小在范围[-100,000, 100,000]内。\n\t<ol>\n\t</ol>\n\t</li>\n</ol>\n</section>\n\n## My Solution\n\n假设糖果的数量为`n`，由于妹妹只能分到一半的苹果，所以答案不会超过`n/2`。\n\n假设糖果种类一共有`m`种，答案也不会超过`m`\n\n综上所述，答案为$min(m,\\cfrac{n}{2} )$\n\n\n\n\n```csharp\npublic class Solution {\n    public int DistributeCandies(int[] candyType)\n    {\n        ISet<int> set = new HashSet<int>();\n        foreach (var i in candyType)\n        {\n            set.Add(i);\n        }\n\n        return Math.Min(set.Count, candyType.Length / 2);\n    }\n}\n```\n\n\n\n# [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n\n---\n\n难度 `简单` | 标签 `链表` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点&nbsp;<code>head</code> ，只能直接访问 <strong>要被删除的节点</strong> 。</p>\n<p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 450px; height: 322px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 5\n<strong>输出：</strong>[4,1,9]\n<strong>解释：</strong>指定链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 450px; height: 354px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 1\n<strong>输出：</strong>[4,5,9]\n<strong>解释：</strong>指定链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>head = [1,2,3,4], node = 3\n<strong>输出：</strong>[1,2,4]\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>head = [0,1], node = 0\n<strong>输出：</strong>[1]\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>head = [-3,5,-99], node = -3\n<strong>输出：</strong>[5,-99]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>链表中节点的数目范围是 <code>[2, 1000]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>链表中每个节点的值都是唯一的</li>\n\t<li>需要删除的节点 <code>node</code> 是 <strong>链表中的一个有效节点</strong> ，且 <strong>不是末尾节点</strong></li>\n</ul>\n</section>\n\n## My Solution\n\n题目保证`node`是**优先节点**，且不是**末尾节点**，所以将当前节点的值改为下一个节点的值，再将当前节点指向下下节点即可完成覆盖。\n\n```csharp\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void DeleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n```\n\n# [407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)\n\n---\n\n难度 `困难` | 标签 `广度优先搜索` `数组` `矩阵` `堆（优先队列）` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。\n</pre>\n<p><strong>示例&nbsp;2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n<strong>输出:</strong> 10\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示:</strong></p>\n<ul>\n\t<li><code>m == heightMap.length</code></li>\n\t<li><code>n == heightMap[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n<p>&nbsp;</p>\n</section>\n\n## My Solution\n\n首先思考一下什么样的方块一定可以接住水：\n\n- 该方块不为最外层的方块\n- 该方块的自身高度比其上下左右四个相邻的方块接水\n\n我们假设初始时矩阵的每个格子都接满了水，且高度均为 $maxHeight$，其中 $maxHeight$ 为矩阵中高度最高的格子。我们知道方块接水后的高度为 $water[i][j]$，它的求解公式与方法一样。方块 $(i,j)$ 的接水后的高度为：\n$$\nwater[i][j]=max(heightMap[i],min(water[i-1][j],water[i+1][j],water[i][j-1],water[i][j+1]))\n$$\n\n\n我们知道方块 $(i,j)$ 实际接水的容量计算公式为$water[i][j]-heightMap[i][j]$ 。\n我们首先假设每个方块 $(i,j)$ 的接水后的高度均为 $water[i][j]=maxHeight$，首先我们知道最外层的方块的肯定不能接水，所有的多余的水都会从最外层的方块溢出，我们每次发现当前方块 $(i,j)$ 的接水高度$water[i][j]$小于与它相邻的4个模块的接水高度时，则我们将进行调整接水高度，我们将其相邻的四个方块的接水高度调整与$(i,j)$高度保持一致，我们不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。\n\n\n\n```csharp\npublic class Solution {\n    public int TrapRainWater(int[][] heightMap)\n    {\n        int m = heightMap.Length;\n        int n = heightMap[0].Length;\n        int[] dirs = { -1, 0, 1, 0, -1 };\n        int maxHeight = 0;\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                maxHeight = Math.Max(maxHeight, heightMap[i][j]);\n            }\n        }\n\n        int[,] water = new int[m, n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                water[i, j] = maxHeight;\n            }\n        }\n\n        Queue<int[]> queue = new Queue<int[]>();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (i != 0 && i != m - 1 && j != 0 && j != n - 1) continue;\n                if (water[i, j] <= heightMap[i][j]) continue;\n                water[i, j] = heightMap[i][j];\n                queue.Enqueue(new[]{i, j});\n            }\n        }\n\n        while (queue.Count > 0)\n        {\n            int[] curr = queue.Dequeue();\n            int x = curr[0];\n            int y = curr[1];\n            for (int i = 0; i < 4; i++)\n            {\n                int nx = x + dirs[i], ny = y + dirs[i + 1];\n                if (nx < 0 || nx > m - 1 || ny < 0 || ny > n - 1)\n                    continue;\n                if (water[x, y] < water[nx, ny] && water[nx, ny] > heightMap[nx][ny])\n                {\n                    water[nx, ny] = Math.Max(water[x, y], heightMap[nx][ny]);\n                    queue.Enqueue(new[] { nx, ny });\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                res += water[i, j] - heightMap[i][j];\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n# [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\n---\n\n难度 `简单` | 标签 `数学` `二分查找` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p><strong>进阶：不要</strong> 使用任何内置的库函数，如&nbsp; <code>sqrt</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>num = 16\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>num = 14\n<strong>输出：</strong>false\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2^31 - 1</code></li>\n</ul>\n</section>\n\n## My Solution\n\n二分搜索来优化遍历过程\n\n```csharp\npublic class Solution {\n    public bool IsPerfectSquare(int num) {\n        int left = 0, right = num;\n        while (left <= right) {\n            int mid = (right - left) / 2 + left;\n            long square = (long) mid * mid;\n            if (square < num) {\n                left = mid + 1;\n            } else if (square > num) {\n                right = mid - 1;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```\n\n# [1218. 最长定差子序列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)\n\n---\n\n难度 `中等` | 标签 `数组` `哈希表` `动态规划` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>difference</code>，请你找出并返回 <code>arr</code>&nbsp;中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>\n<p><strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>arr = [1,2,3,4], difference = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [1,2,3,4]。</pre>\n<p><strong>示例&nbsp;2：</strong></p>\n<pre><strong>输入：</strong>arr = [1,3,5,7], difference = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的等差子序列是任意单个元素。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>arr = [1,5,7,8,5,3,4,2,1], difference = -2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [7,5,3,1]。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= arr[i], difference &lt;= 10<sup>4</sup></code></li>\n</ul>\n</section>\n\n## My Solution\n\n$$\ndp[i] = \n\\begin{cases}\ndp[i - difference] + 1,& dp[i-difference] \\neq -1\\\\\n1& dp[i-difference] = -1\n\\end{cases}\n$$\n\n\n\n```csharp\npublic class Solution {\n   public int LongestSubsequence(int[] arr, int difference)\n    {\n        int res = 0;\n        Dictionary<int, int> dictionary = new Dictionary<int, int>();\n        foreach (var t in arr)\n        {\n            int number = dictionary.ContainsKey(t - difference) ? dictionary[t - difference] : 0;\n            if (dictionary.ContainsKey(t))\n            {\n                dictionary[t] = number + 1;\n            }\n            else\n            {\n                dictionary.Add(t, number + 1);\n            }\n\n            res = Math.Max(res, dictionary[t]);\n        }\n\n        return res;\n    }\n}\n```\n\n# [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n---\n\n难度 `简单` | 标签 `位运算` `数组` `哈希表` `数学` `排序` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个包含 <code>[0, n]</code>&nbsp;中&nbsp;<code>n</code>&nbsp;个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n<ul>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [3,0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n<b>解释：</b>n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>nums = [0]\n<strong>输出：</strong>1\n<b>解释：</b>n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int MissingNumber(int[] nums)\n    {\n        int res = nums.Length;\n        for (var i = 0; i < nums.Length; i++)\n        {\n            res += i;\n            res -= nums[i];\n        }\n\n        return res;\n    }\n}\n```\n\n# [598. 范围求和 II](https://leetcode-cn.com/problems/range-addition-ii/)\n\n---\n\n难度 `简单` | 标签 `数组` `数学` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个初始元素全部为&nbsp;<strong>0</strong>，大小为 m*n 的矩阵&nbsp;<strong>M&nbsp;</strong>以及在&nbsp;<strong>M&nbsp;</strong>上的一系列更新操作。</p>\n<p>操作用二维数组表示，其中的每个操作用一个含有两个<strong>正整数&nbsp;a</strong> 和 <strong>b</strong> 的数组表示，含义是将所有符合&nbsp;<strong>0 &lt;= i &lt; a</strong> 以及 <strong>0 &lt;= j &lt; b</strong> 的元素&nbsp;<strong>M[i][j]&nbsp;</strong>的值都<strong>增加 1</strong>。</p>\n<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> \nm = 3, n = 3\noperations = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n初始状态, M = \n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n执行完操作 [2,2] 后, M = \n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n执行完操作 [3,3] 后, M = \n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\nM 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>m 和 n 的范围是&nbsp;[1,40000]。</li>\n\t<li>a 的范围是 [1,m]，b 的范围是 [1,n]。</li>\n\t<li>操作数目不超过 10000。</li>\n</ol>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int MaxCount(int m, int n, int[][] ops) {\n        int mina = m, minb = n;\n        foreach (int[] op in ops) {\n            mina = Math.Min(mina, op[0]);\n            minb = Math.Min(minb, op[1]);\n        }\n        return mina * minb;\n    }\n}\n```\n\n# [299. 猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/)\n\n---\n\n难度 `中等` | 标签 `哈希表` `字符串` `计数` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>你在和朋友一起玩 <a href=\"https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin\">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>\n<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>\n<ul>\n\t<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\", 公牛），</li>\n\t<li>有多少位属于数字猜对了但是位置不对（称为 \"Cows\", 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>\n</ul>\n<p>给你一个秘密数字&nbsp;<code>secret</code> 和朋友猜测的数字&nbsp;<code>guess</code> ，请你返回对朋友这次猜测的提示。</p>\n<p>提示的格式为 <code>\"xAyB\"</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code>&nbsp;表示奶牛。</p>\n<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> secret = \"1807\", guess = \"7810\"\n<strong>输出:</strong> \"1A3B\"\n<strong>解释:</strong> 数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1807\"\n  |\n\"<em><strong>7</strong></em>8<em><strong>10</strong></em>\"</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> secret = \"1123\", guess = \"0111\"\n<strong>输出:</strong> \"1A1B\"\n<strong>解释: </strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1123\"        \"1123\"\n  |      or     |\n\"01<em><strong>1</strong></em>1\"        \"011<em><strong>1</strong></em>\"\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"0\"\n<strong>输出：</strong>\"0A0B\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"1\"\n<strong>输出：</strong>\"1A0B\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public string GetHint(string secret, string guess) {\n        int bulls = 0;\n        int[] cntS = new int[10];\n        int[] cntG = new int[10];\n        for (int i = 0; i < secret.Length; ++i) {\n            if (secret[i] == guess[i]) {\n                ++bulls;\n            } else {\n                ++cntS[secret[i] - '0'];\n                ++cntG[guess[i] - '0'];\n            }\n        }\n        int cows = 0;\n        for (int i = 0; i < 10; ++i) {\n            cows += Math.Min(cntS[i], cntG[i]);\n        }\n        return bulls.ToString() + \"A\" + cows.ToString() + \"B\";\n    }\n}\n```\n\n# [495. 提莫攻击](https://leetcode-cn.com/problems/teemo-attacking/)\n\n---\n\n难度 `简单` | 标签 `数组` `模拟` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p>\n<p>当提莫攻击艾希，艾希的中毒状态正好持续&nbsp;<code>duration</code> 秒。</p>\n<p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p>\n<p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p>\n<p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,4], duration = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,2], duration = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int FindPoisonedDuration(int[] timeSeries, int duration) {\n        int ans = 0;\n        int expired = 0;\n        for (int i = 0; i < timeSeries.Length; ++i) {\n            if (timeSeries[i] >= expired) {\n                ans += duration;\n            } else {\n                ans += timeSeries[i] + duration - expired;\n            }\n            expired = timeSeries[i] + duration;\n        }\n        return ans;\n    }\n}\n```\n\n# [629. K个逆序对数组](https://leetcode-cn.com/problems/k-inverse-pairs-array/)\n\n---\n\n难度 `困难` | 标签 `动态规划` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，找出所有包含从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的数字，且恰好拥有&nbsp;<code>k</code>&nbsp;个逆序对的不同的数组的个数。</p>\n<p>逆序对的定义如下：对于数组的第<code>i</code>个和第&nbsp;<code>j</code>个元素，如果满<code>i</code>&nbsp;&lt;&nbsp;<code>j</code>且&nbsp;<code>a[i]</code>&nbsp;&gt;&nbsp;<code>a[j]</code>，则其为一个逆序对；否则不是。</p>\n<p>由于答案可能很大，只需要返回 答案 mod 10<sup>9</sup>&nbsp;+ 7 的值。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 0\n<strong>输出:</strong> 1\n<strong>解释:</strong> \n只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 1\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n</pre>\n<p><strong>说明:</strong></p>\n<ol>\n\t<li>&nbsp;<code>n</code>&nbsp;的范围是 [1, 1000] 并且 <code>k</code> 的范围是 [0, 1000]。</li>\n</ol>\n</section>\n\n## My Solution\n\n\n\n```csharp\npublic class Solution {\n    public int KInversePairs(int n, int k) {\n        const int MOD = 1000000007;\n        int[,] f = new int[2, k + 1];\n        f[0, 0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int cur = i & 1, prev = cur ^ 1;\n                f[cur, j] = (j - 1 >= 0 ? f[cur, j - 1] : 0) - (j - i >= 0 ? f[prev, j - i] : 0) + f[prev, j];\n                if (f[cur, j] >= MOD) {\n                    f[cur, j] -= MOD;\n                } else if (f[cur, j] < 0) {\n                    f[cur, j] += MOD;\n                }\n            }\n        }\n        return f[n & 1, k];\n    }\n}\n\n```\n\n# [391. 完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/)\n\n---\n\n难度 `困难` | 标签 `数组` `扫描线` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，右上顶点是 <code>(a<sub>i</sub>, b<sub>i</sub>)</code> 。</p>\n<p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>5 个矩形一起可以精确地覆盖一个矩形区域。 \n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>两个矩形之间有间隔，无法覆盖成一个矩形。</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec3-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>图形顶端留有空缺，无法覆盖成一个矩形。</pre>\n<p><strong>示例 4：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == 4</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic bool IsRectangleCover(int[][] rectangles)\n{\n    int n = rectangles.Length;\n    int[][] rs = new int[2 * n][];\n    for (int i = 0, idx = 0; i < n; i++)\n    {\n        int[] re = rectangles[i];\n        rs[idx++] = new int[] { re[0], re[1], re[3], 1 };\n        rs[idx++] = new int[] { re[2], re[1], re[3], -1 };\n    }\n\n    Array.Sort(rs, ((a, b) =>\n    {\n        if (a[0] != b[0])\n        {\n            return a[0] - b[0];\n        }\n\n        return a[1] - b[1];\n    }));\n    n *= 2;\n    List<int[]> l1 = new List<int[]>(), l2 = new List<int[]>();\n    for (int l = 0; l < n;)\n    {\n        int r = l;\n        l1.Clear();\n        l2.Clear();\n        while (r < n && rs[r][0] == rs[l][0])\n            r++;\n        for (int i = l; i < r; i++)\n        {\n            int[] cur = new[] { rs[i][1], rs[i][2] };\n            List<int[]> list = rs[i][3] == 1 ? l1 : l2;\n            if (list.Count <= 0)\n            {\n                list.Add(cur);\n            }\n            else\n            {\n                int[] prev = list[^1];\n                if (cur[0] < prev[1])\n                {\n                    return false;\n                }\n                else if (cur[0] == prev[1])\n                {\n                    prev[1] = cur[1];\n                }\n                else\n                {\n                    list.Add(cur);\n                }\n            }\n        }\n\n        if (l > 0 && r < n)\n        {\n            if (l1.Count != l2.Count)\n            {\n                return false;\n            }\n\n            for (int i = 0; i < l1.Count; i++)\n            {\n                if (l1[i][0] == l2[i][0] && l1[i][1] == l2[i][1])\n                {\n                    continue;\n                }\n\n                return false;\n            }\n        }\n        else\n        {\n            if (l1.Count + l2.Count != 1)\n            {\n                return false;\n            }\n        }\n\n        l = r;\n    }\n\n    return true;\n}\n```\n\n# [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)\n\n---\n\n难度 `中等` | 标签 `位运算` `数组` `字符串` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个字符串数组&nbsp;<code>words</code>，找到&nbsp;<code>length(word[i]) * length(word[j])</code>&nbsp;的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>\n<p>&nbsp;</p>\n<p><strong>示例&nbsp;1:</strong></p>\n<pre><strong>输入:</strong> <code>[\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]</code>\n<strong>输出: </strong><code>16 \n<strong>解释:</strong> 这两个单词为<strong> </strong></code><code>\"abcw\", \"xtfn\"</code>。</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]</code>\n<strong>输出: </strong><code>4 \n<strong>解释: </strong></code>这两个单词为 <code>\"ab\", \"cd\"</code>。</pre>\n<p><strong>示例 3:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"aa\",\"aaa\",\"aaaa\"]</code>\n<strong>输出: </strong><code>0 \n<strong>解释: </strong>不存在这样的两个单词。</code>\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int MaxProduct(string[] words) {\n        int res = 0;\n        int[] masks = new int[words.Length];\n        for(int i = 0; i < words.Length; i++)\n        {\n            for(int j = 0; j < words[i].Length; j++)\n            {\n                masks[i] |= 1 << (words[i][j] - 'a');\n            }\n        }\n        for(int i = 0; i < words.Length; i++)\n        {\n            for(int j = i; j < words.Length; j++)\n            {\n                if((masks[i] & masks[j]) == 0)\n                    res = Math.Max(res, words[i].Length * words[j].Length);\n            }\n        }\n        return res;\n    }\n}\n```\n\n# [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)\n\n---\n\n难度 `简单` | 标签 `树` `深度优先搜索` `二叉树` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个二叉树，计算 <strong>整个树 </strong>的坡度 。</p>\n<p>一个树的<strong> 节点的坡度 </strong>定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值 </strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 712px; height: 182px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 800px; height: 203px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [4,2,9,3,5,null,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 800px; height: 293px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [21,7,14,1,1,2,2,3,3]\n<strong>输出：</strong>9\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数目的范围在 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n</section>\n\n## My Solution\n\n实现思路如下：\n\n- 从根节点开始遍历，设当前节点为`node`\n- 遍历`node`的左右节点`left`和`right`，将两者节点之和的差的绝对值累加到结果`res`\n- 返回`node`作为根节点的树的节点之和`left + right + node.val`\n\n```csharp\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int res = 0;\n    public int FindTilt(TreeNode root) {\n        DFS(root);\n        return res;\n    }\n    public int DFS(TreeNode node)\n    {\n        if(node == null)\n            return 0;\n        int left = DFS(node.left);\n        int right = DFS(node.right);\n        res += Math.Abs(left - right);\n        return left + right + node.val;\n    }\n}\n```\n\n# [397. 整数替换](https://leetcode-cn.com/problems/integer-replacement/)\n\n---\n\n难度 `中等` | 标签 `贪心` `位运算` `记忆化搜索` `动态规划` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个正整数&nbsp;<code>n</code> ，你可以做如下操作：</p>\n<ol>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是偶数，则用&nbsp;<code>n / 2</code>替换&nbsp;<code>n</code><em> </em>。</li>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是奇数，则可以用&nbsp;<code>n + 1</code>或<code>n - 1</code>替换&nbsp;<code>n</code> 。</li>\n</ol>\n<p><code>n</code><em>&nbsp;</em>变为 <code>1</code> 所需的最小替换次数是多少？</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\n或 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n</section>\n\n\n## My Solution\n\n**方法一**\n\n- 当$n$为偶数时，我们只有唯一的办法将$n$替换为$\\dfrac{n}{2}$\n- 当n为奇数时，我们可以选择将$n$增加1或减少1。由于这两种方法都会将$n$变为偶数，那么下一步一定是除2，因此这里可以堪称使用两次操作，将$n$变为$\\frac{n+1}{2}$或$\\frac{n-1}{2}$\n\n这里需要注意$n = 2^{31}-1$时，计算$n+1$会溢出，所以用$\\lfloor \\frac{n}{2} \\rfloor + 1$和$\\lfloor \\frac{n}{2} \\rfloor$分别计算$\\frac{n+1}{2}$或$\\frac{n-1}{2}$。\n\n```csharp\npublic class Solution {\n    Dictionary<int, int> memo = new Dictionary<int, int>();\n\n    public int IntegerReplacement(int n) {\n        if (n == 1) {\n            return 0;\n        }\n        if (!memo.ContainsKey(n)) {\n            if (n % 2 == 0) {\n                memo.Add(n, 1 + IntegerReplacement(n / 2));\n            } else {\n                memo.Add(n, 2 + Math.Min(IntegerReplacement(n / 2), IntegerReplacement(n / 2 + 1)));\n            }\n        }\n        return memo[n];\n    }\n}\n\n```\n\n**方法二**\n\n上述两种做法，我们不可避免地在每个回合枚举了所有我们可以做的决策：主要体现在对$x$为奇数时的处理，我们总是处理$x + 1$和$x - 1$两种情况。\n\n可以从二进制的角度进行分析：**给定起始值$n$，求解将其变为$(000...0001)_2$的最小步数**\n\n- 对于偶数（二进制最低位为0）而言，我们只能进行一种操作，其作用是将当前值$x$进行一个单位的右移\n- 对于奇数（二进制最低位为1）而言，我们能进行 **+1**和 **-1**操作，分析两种操作对$x$产生的影响\n  - 对于 **+1**操作而言：最低位必然为1，此时如果次低位为0的话，**+1**相当于将最低位和次低位交换；如果次低位为1的话， **+1操作将将从最低位开始，连续一段的1进行消除（置零）**，并在连续一段的最高一位添加一个1\n  - 对于 **-1**操作而言：最低位必然为1，其作用是将最低位的1进行消除\n\n因此，对于$x$为奇数所能执行的两种操作， **+1**能够消除连续一段的1，只要次低位为1（存在连续端），应当优先使用  **+1**操作，但需要注意边界$x=1$的情况（此时选择 **-1**操作）\n\n此方法个人觉得不如官方题解给的方案，这里给附上网址自行查阅[整数替换 - 整数替换 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/integer-replacement/solution/zheng-shu-ti-huan-by-leetcode-solution-swef/)\n\n```csharp\npublic class Solution {\n    public int IntegerReplacement(int n) {\n        int ans = 0;\n        long tempN = n;\n        while(tempN != 1)\n        {\n            if(tempN % 2 == 0)\n                tempN >>= 1;\n            else\n            {\n                if(tempN != 3 && (tempN >> 1 & 1) == 1)\n                    tempN++;\n                else\n                    tempN--;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}\n```\n","source":"_posts/leetcode.md","raw":"---\ntitle: leetcode刷题记录\ndate: 2021-11-01 13:50:37\ntags:\n---\n\n# [575. 分糖果](https://leetcode-cn.com/problems/distribute-candies/)\n\n---\n\n难度 `简单` | 标签 `数组` `哈希表` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果<strong>平均</strong>分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,2,3,3]\n<strong>输出:</strong> 3\n<strong>解析: </strong>一共有三种种类的糖果，每一种都有两个。\n     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。\n</pre>\n<p><strong>示例 2 :</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,3]\n<strong>输出:</strong> 2\n<strong>解析:</strong> 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>数组的长度为[2, 10,000]，并且确定为偶数。</li>\n\t<li>数组中数字的大小在范围[-100,000, 100,000]内。\n\t<ol>\n\t</ol>\n\t</li>\n</ol>\n</section>\n\n## My Solution\n\n假设糖果的数量为`n`，由于妹妹只能分到一半的苹果，所以答案不会超过`n/2`。\n\n假设糖果种类一共有`m`种，答案也不会超过`m`\n\n综上所述，答案为$min(m,\\cfrac{n}{2} )$\n\n\n\n\n```csharp\npublic class Solution {\n    public int DistributeCandies(int[] candyType)\n    {\n        ISet<int> set = new HashSet<int>();\n        foreach (var i in candyType)\n        {\n            set.Add(i);\n        }\n\n        return Math.Min(set.Count, candyType.Length / 2);\n    }\n}\n```\n\n\n\n# [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n\n---\n\n难度 `简单` | 标签 `链表` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点&nbsp;<code>head</code> ，只能直接访问 <strong>要被删除的节点</strong> 。</p>\n<p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 450px; height: 322px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 5\n<strong>输出：</strong>[4,1,9]\n<strong>解释：</strong>指定链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 450px; height: 354px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 1\n<strong>输出：</strong>[4,5,9]\n<strong>解释：</strong>指定链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>head = [1,2,3,4], node = 3\n<strong>输出：</strong>[1,2,4]\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>head = [0,1], node = 0\n<strong>输出：</strong>[1]\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>head = [-3,5,-99], node = -3\n<strong>输出：</strong>[5,-99]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>链表中节点的数目范围是 <code>[2, 1000]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>链表中每个节点的值都是唯一的</li>\n\t<li>需要删除的节点 <code>node</code> 是 <strong>链表中的一个有效节点</strong> ，且 <strong>不是末尾节点</strong></li>\n</ul>\n</section>\n\n## My Solution\n\n题目保证`node`是**优先节点**，且不是**末尾节点**，所以将当前节点的值改为下一个节点的值，再将当前节点指向下下节点即可完成覆盖。\n\n```csharp\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void DeleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n```\n\n# [407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)\n\n---\n\n难度 `困难` | 标签 `广度优先搜索` `数组` `矩阵` `堆（优先队列）` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。\n</pre>\n<p><strong>示例&nbsp;2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n<strong>输出:</strong> 10\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示:</strong></p>\n<ul>\n\t<li><code>m == heightMap.length</code></li>\n\t<li><code>n == heightMap[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n<p>&nbsp;</p>\n</section>\n\n## My Solution\n\n首先思考一下什么样的方块一定可以接住水：\n\n- 该方块不为最外层的方块\n- 该方块的自身高度比其上下左右四个相邻的方块接水\n\n我们假设初始时矩阵的每个格子都接满了水，且高度均为 $maxHeight$，其中 $maxHeight$ 为矩阵中高度最高的格子。我们知道方块接水后的高度为 $water[i][j]$，它的求解公式与方法一样。方块 $(i,j)$ 的接水后的高度为：\n$$\nwater[i][j]=max(heightMap[i],min(water[i-1][j],water[i+1][j],water[i][j-1],water[i][j+1]))\n$$\n\n\n我们知道方块 $(i,j)$ 实际接水的容量计算公式为$water[i][j]-heightMap[i][j]$ 。\n我们首先假设每个方块 $(i,j)$ 的接水后的高度均为 $water[i][j]=maxHeight$，首先我们知道最外层的方块的肯定不能接水，所有的多余的水都会从最外层的方块溢出，我们每次发现当前方块 $(i,j)$ 的接水高度$water[i][j]$小于与它相邻的4个模块的接水高度时，则我们将进行调整接水高度，我们将其相邻的四个方块的接水高度调整与$(i,j)$高度保持一致，我们不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。\n\n\n\n```csharp\npublic class Solution {\n    public int TrapRainWater(int[][] heightMap)\n    {\n        int m = heightMap.Length;\n        int n = heightMap[0].Length;\n        int[] dirs = { -1, 0, 1, 0, -1 };\n        int maxHeight = 0;\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                maxHeight = Math.Max(maxHeight, heightMap[i][j]);\n            }\n        }\n\n        int[,] water = new int[m, n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                water[i, j] = maxHeight;\n            }\n        }\n\n        Queue<int[]> queue = new Queue<int[]>();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (i != 0 && i != m - 1 && j != 0 && j != n - 1) continue;\n                if (water[i, j] <= heightMap[i][j]) continue;\n                water[i, j] = heightMap[i][j];\n                queue.Enqueue(new[]{i, j});\n            }\n        }\n\n        while (queue.Count > 0)\n        {\n            int[] curr = queue.Dequeue();\n            int x = curr[0];\n            int y = curr[1];\n            for (int i = 0; i < 4; i++)\n            {\n                int nx = x + dirs[i], ny = y + dirs[i + 1];\n                if (nx < 0 || nx > m - 1 || ny < 0 || ny > n - 1)\n                    continue;\n                if (water[x, y] < water[nx, ny] && water[nx, ny] > heightMap[nx][ny])\n                {\n                    water[nx, ny] = Math.Max(water[x, y], heightMap[nx][ny]);\n                    queue.Enqueue(new[] { nx, ny });\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                res += water[i, j] - heightMap[i][j];\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n# [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\n---\n\n难度 `简单` | 标签 `数学` `二分查找` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p><strong>进阶：不要</strong> 使用任何内置的库函数，如&nbsp; <code>sqrt</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>num = 16\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>num = 14\n<strong>输出：</strong>false\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2^31 - 1</code></li>\n</ul>\n</section>\n\n## My Solution\n\n二分搜索来优化遍历过程\n\n```csharp\npublic class Solution {\n    public bool IsPerfectSquare(int num) {\n        int left = 0, right = num;\n        while (left <= right) {\n            int mid = (right - left) / 2 + left;\n            long square = (long) mid * mid;\n            if (square < num) {\n                left = mid + 1;\n            } else if (square > num) {\n                right = mid - 1;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```\n\n# [1218. 最长定差子序列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)\n\n---\n\n难度 `中等` | 标签 `数组` `哈希表` `动态规划` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>difference</code>，请你找出并返回 <code>arr</code>&nbsp;中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>\n<p><strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>arr = [1,2,3,4], difference = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [1,2,3,4]。</pre>\n<p><strong>示例&nbsp;2：</strong></p>\n<pre><strong>输入：</strong>arr = [1,3,5,7], difference = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的等差子序列是任意单个元素。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>arr = [1,5,7,8,5,3,4,2,1], difference = -2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [7,5,3,1]。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= arr[i], difference &lt;= 10<sup>4</sup></code></li>\n</ul>\n</section>\n\n## My Solution\n\n$$\ndp[i] = \n\\begin{cases}\ndp[i - difference] + 1,& dp[i-difference] \\neq -1\\\\\n1& dp[i-difference] = -1\n\\end{cases}\n$$\n\n\n\n```csharp\npublic class Solution {\n   public int LongestSubsequence(int[] arr, int difference)\n    {\n        int res = 0;\n        Dictionary<int, int> dictionary = new Dictionary<int, int>();\n        foreach (var t in arr)\n        {\n            int number = dictionary.ContainsKey(t - difference) ? dictionary[t - difference] : 0;\n            if (dictionary.ContainsKey(t))\n            {\n                dictionary[t] = number + 1;\n            }\n            else\n            {\n                dictionary.Add(t, number + 1);\n            }\n\n            res = Math.Max(res, dictionary[t]);\n        }\n\n        return res;\n    }\n}\n```\n\n# [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n---\n\n难度 `简单` | 标签 `位运算` `数组` `哈希表` `数学` `排序` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个包含 <code>[0, n]</code>&nbsp;中&nbsp;<code>n</code>&nbsp;个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n<ul>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [3,0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n<b>解释：</b>n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>nums = [0]\n<strong>输出：</strong>1\n<b>解释：</b>n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int MissingNumber(int[] nums)\n    {\n        int res = nums.Length;\n        for (var i = 0; i < nums.Length; i++)\n        {\n            res += i;\n            res -= nums[i];\n        }\n\n        return res;\n    }\n}\n```\n\n# [598. 范围求和 II](https://leetcode-cn.com/problems/range-addition-ii/)\n\n---\n\n难度 `简单` | 标签 `数组` `数学` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个初始元素全部为&nbsp;<strong>0</strong>，大小为 m*n 的矩阵&nbsp;<strong>M&nbsp;</strong>以及在&nbsp;<strong>M&nbsp;</strong>上的一系列更新操作。</p>\n<p>操作用二维数组表示，其中的每个操作用一个含有两个<strong>正整数&nbsp;a</strong> 和 <strong>b</strong> 的数组表示，含义是将所有符合&nbsp;<strong>0 &lt;= i &lt; a</strong> 以及 <strong>0 &lt;= j &lt; b</strong> 的元素&nbsp;<strong>M[i][j]&nbsp;</strong>的值都<strong>增加 1</strong>。</p>\n<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> \nm = 3, n = 3\noperations = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n初始状态, M = \n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n执行完操作 [2,2] 后, M = \n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n执行完操作 [3,3] 后, M = \n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\nM 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>m 和 n 的范围是&nbsp;[1,40000]。</li>\n\t<li>a 的范围是 [1,m]，b 的范围是 [1,n]。</li>\n\t<li>操作数目不超过 10000。</li>\n</ol>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int MaxCount(int m, int n, int[][] ops) {\n        int mina = m, minb = n;\n        foreach (int[] op in ops) {\n            mina = Math.Min(mina, op[0]);\n            minb = Math.Min(minb, op[1]);\n        }\n        return mina * minb;\n    }\n}\n```\n\n# [299. 猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/)\n\n---\n\n难度 `中等` | 标签 `哈希表` `字符串` `计数` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>你在和朋友一起玩 <a href=\"https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin\">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>\n<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>\n<ul>\n\t<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\", 公牛），</li>\n\t<li>有多少位属于数字猜对了但是位置不对（称为 \"Cows\", 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>\n</ul>\n<p>给你一个秘密数字&nbsp;<code>secret</code> 和朋友猜测的数字&nbsp;<code>guess</code> ，请你返回对朋友这次猜测的提示。</p>\n<p>提示的格式为 <code>\"xAyB\"</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code>&nbsp;表示奶牛。</p>\n<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> secret = \"1807\", guess = \"7810\"\n<strong>输出:</strong> \"1A3B\"\n<strong>解释:</strong> 数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1807\"\n  |\n\"<em><strong>7</strong></em>8<em><strong>10</strong></em>\"</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> secret = \"1123\", guess = \"0111\"\n<strong>输出:</strong> \"1A1B\"\n<strong>解释: </strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1123\"        \"1123\"\n  |      or     |\n\"01<em><strong>1</strong></em>1\"        \"011<em><strong>1</strong></em>\"\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"0\"\n<strong>输出：</strong>\"0A0B\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"1\"\n<strong>输出：</strong>\"1A0B\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public string GetHint(string secret, string guess) {\n        int bulls = 0;\n        int[] cntS = new int[10];\n        int[] cntG = new int[10];\n        for (int i = 0; i < secret.Length; ++i) {\n            if (secret[i] == guess[i]) {\n                ++bulls;\n            } else {\n                ++cntS[secret[i] - '0'];\n                ++cntG[guess[i] - '0'];\n            }\n        }\n        int cows = 0;\n        for (int i = 0; i < 10; ++i) {\n            cows += Math.Min(cntS[i], cntG[i]);\n        }\n        return bulls.ToString() + \"A\" + cows.ToString() + \"B\";\n    }\n}\n```\n\n# [495. 提莫攻击](https://leetcode-cn.com/problems/teemo-attacking/)\n\n---\n\n难度 `简单` | 标签 `数组` `模拟` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p>\n<p>当提莫攻击艾希，艾希的中毒状态正好持续&nbsp;<code>duration</code> 秒。</p>\n<p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p>\n<p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p>\n<p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,4], duration = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,2], duration = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int FindPoisonedDuration(int[] timeSeries, int duration) {\n        int ans = 0;\n        int expired = 0;\n        for (int i = 0; i < timeSeries.Length; ++i) {\n            if (timeSeries[i] >= expired) {\n                ans += duration;\n            } else {\n                ans += timeSeries[i] + duration - expired;\n            }\n            expired = timeSeries[i] + duration;\n        }\n        return ans;\n    }\n}\n```\n\n# [629. K个逆序对数组](https://leetcode-cn.com/problems/k-inverse-pairs-array/)\n\n---\n\n难度 `困难` | 标签 `动态规划` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，找出所有包含从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的数字，且恰好拥有&nbsp;<code>k</code>&nbsp;个逆序对的不同的数组的个数。</p>\n<p>逆序对的定义如下：对于数组的第<code>i</code>个和第&nbsp;<code>j</code>个元素，如果满<code>i</code>&nbsp;&lt;&nbsp;<code>j</code>且&nbsp;<code>a[i]</code>&nbsp;&gt;&nbsp;<code>a[j]</code>，则其为一个逆序对；否则不是。</p>\n<p>由于答案可能很大，只需要返回 答案 mod 10<sup>9</sup>&nbsp;+ 7 的值。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 0\n<strong>输出:</strong> 1\n<strong>解释:</strong> \n只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 1\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n</pre>\n<p><strong>说明:</strong></p>\n<ol>\n\t<li>&nbsp;<code>n</code>&nbsp;的范围是 [1, 1000] 并且 <code>k</code> 的范围是 [0, 1000]。</li>\n</ol>\n</section>\n\n## My Solution\n\n\n\n```csharp\npublic class Solution {\n    public int KInversePairs(int n, int k) {\n        const int MOD = 1000000007;\n        int[,] f = new int[2, k + 1];\n        f[0, 0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= k; ++j) {\n                int cur = i & 1, prev = cur ^ 1;\n                f[cur, j] = (j - 1 >= 0 ? f[cur, j - 1] : 0) - (j - i >= 0 ? f[prev, j - i] : 0) + f[prev, j];\n                if (f[cur, j] >= MOD) {\n                    f[cur, j] -= MOD;\n                } else if (f[cur, j] < 0) {\n                    f[cur, j] += MOD;\n                }\n            }\n        }\n        return f[n & 1, k];\n    }\n}\n\n```\n\n# [391. 完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/)\n\n---\n\n难度 `困难` | 标签 `数组` `扫描线` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，右上顶点是 <code>(a<sub>i</sub>, b<sub>i</sub>)</code> 。</p>\n<p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>5 个矩形一起可以精确地覆盖一个矩形区域。 \n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>两个矩形之间有间隔，无法覆盖成一个矩形。</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec3-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>图形顶端留有空缺，无法覆盖成一个矩形。</pre>\n<p><strong>示例 4：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == 4</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic bool IsRectangleCover(int[][] rectangles)\n{\n    int n = rectangles.Length;\n    int[][] rs = new int[2 * n][];\n    for (int i = 0, idx = 0; i < n; i++)\n    {\n        int[] re = rectangles[i];\n        rs[idx++] = new int[] { re[0], re[1], re[3], 1 };\n        rs[idx++] = new int[] { re[2], re[1], re[3], -1 };\n    }\n\n    Array.Sort(rs, ((a, b) =>\n    {\n        if (a[0] != b[0])\n        {\n            return a[0] - b[0];\n        }\n\n        return a[1] - b[1];\n    }));\n    n *= 2;\n    List<int[]> l1 = new List<int[]>(), l2 = new List<int[]>();\n    for (int l = 0; l < n;)\n    {\n        int r = l;\n        l1.Clear();\n        l2.Clear();\n        while (r < n && rs[r][0] == rs[l][0])\n            r++;\n        for (int i = l; i < r; i++)\n        {\n            int[] cur = new[] { rs[i][1], rs[i][2] };\n            List<int[]> list = rs[i][3] == 1 ? l1 : l2;\n            if (list.Count <= 0)\n            {\n                list.Add(cur);\n            }\n            else\n            {\n                int[] prev = list[^1];\n                if (cur[0] < prev[1])\n                {\n                    return false;\n                }\n                else if (cur[0] == prev[1])\n                {\n                    prev[1] = cur[1];\n                }\n                else\n                {\n                    list.Add(cur);\n                }\n            }\n        }\n\n        if (l > 0 && r < n)\n        {\n            if (l1.Count != l2.Count)\n            {\n                return false;\n            }\n\n            for (int i = 0; i < l1.Count; i++)\n            {\n                if (l1[i][0] == l2[i][0] && l1[i][1] == l2[i][1])\n                {\n                    continue;\n                }\n\n                return false;\n            }\n        }\n        else\n        {\n            if (l1.Count + l2.Count != 1)\n            {\n                return false;\n            }\n        }\n\n        l = r;\n    }\n\n    return true;\n}\n```\n\n# [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)\n\n---\n\n难度 `中等` | 标签 `位运算` `数组` `字符串` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个字符串数组&nbsp;<code>words</code>，找到&nbsp;<code>length(word[i]) * length(word[j])</code>&nbsp;的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>\n<p>&nbsp;</p>\n<p><strong>示例&nbsp;1:</strong></p>\n<pre><strong>输入:</strong> <code>[\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]</code>\n<strong>输出: </strong><code>16 \n<strong>解释:</strong> 这两个单词为<strong> </strong></code><code>\"abcw\", \"xtfn\"</code>。</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]</code>\n<strong>输出: </strong><code>4 \n<strong>解释: </strong></code>这两个单词为 <code>\"ab\", \"cd\"</code>。</pre>\n<p><strong>示例 3:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"aa\",\"aaa\",\"aaaa\"]</code>\n<strong>输出: </strong><code>0 \n<strong>解释: </strong>不存在这样的两个单词。</code>\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n</section>\n\n## My Solution\n\n```csharp\npublic class Solution {\n    public int MaxProduct(string[] words) {\n        int res = 0;\n        int[] masks = new int[words.Length];\n        for(int i = 0; i < words.Length; i++)\n        {\n            for(int j = 0; j < words[i].Length; j++)\n            {\n                masks[i] |= 1 << (words[i][j] - 'a');\n            }\n        }\n        for(int i = 0; i < words.Length; i++)\n        {\n            for(int j = i; j < words.Length; j++)\n            {\n                if((masks[i] & masks[j]) == 0)\n                    res = Math.Max(res, words[i].Length * words[j].Length);\n            }\n        }\n        return res;\n    }\n}\n```\n\n# [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)\n\n---\n\n难度 `简单` | 标签 `树` `深度优先搜索` `二叉树` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个二叉树，计算 <strong>整个树 </strong>的坡度 。</p>\n<p>一个树的<strong> 节点的坡度 </strong>定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值 </strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 712px; height: 182px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 800px; height: 203px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [4,2,9,3,5,null,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 800px; height: 293px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [21,7,14,1,1,2,2,3,3]\n<strong>输出：</strong>9\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数目的范围在 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n</section>\n\n## My Solution\n\n实现思路如下：\n\n- 从根节点开始遍历，设当前节点为`node`\n- 遍历`node`的左右节点`left`和`right`，将两者节点之和的差的绝对值累加到结果`res`\n- 返回`node`作为根节点的树的节点之和`left + right + node.val`\n\n```csharp\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int res = 0;\n    public int FindTilt(TreeNode root) {\n        DFS(root);\n        return res;\n    }\n    public int DFS(TreeNode node)\n    {\n        if(node == null)\n            return 0;\n        int left = DFS(node.left);\n        int right = DFS(node.right);\n        res += Math.Abs(left - right);\n        return left + right + node.val;\n    }\n}\n```\n\n# [397. 整数替换](https://leetcode-cn.com/problems/integer-replacement/)\n\n---\n\n难度 `中等` | 标签 `贪心` `位运算` `记忆化搜索` `动态规划` \n\n---\n\n## Description\n\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个正整数&nbsp;<code>n</code> ，你可以做如下操作：</p>\n<ol>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是偶数，则用&nbsp;<code>n / 2</code>替换&nbsp;<code>n</code><em> </em>。</li>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是奇数，则可以用&nbsp;<code>n + 1</code>或<code>n - 1</code>替换&nbsp;<code>n</code> 。</li>\n</ol>\n<p><code>n</code><em>&nbsp;</em>变为 <code>1</code> 所需的最小替换次数是多少？</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\n或 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n</section>\n\n\n## My Solution\n\n**方法一**\n\n- 当$n$为偶数时，我们只有唯一的办法将$n$替换为$\\dfrac{n}{2}$\n- 当n为奇数时，我们可以选择将$n$增加1或减少1。由于这两种方法都会将$n$变为偶数，那么下一步一定是除2，因此这里可以堪称使用两次操作，将$n$变为$\\frac{n+1}{2}$或$\\frac{n-1}{2}$\n\n这里需要注意$n = 2^{31}-1$时，计算$n+1$会溢出，所以用$\\lfloor \\frac{n}{2} \\rfloor + 1$和$\\lfloor \\frac{n}{2} \\rfloor$分别计算$\\frac{n+1}{2}$或$\\frac{n-1}{2}$。\n\n```csharp\npublic class Solution {\n    Dictionary<int, int> memo = new Dictionary<int, int>();\n\n    public int IntegerReplacement(int n) {\n        if (n == 1) {\n            return 0;\n        }\n        if (!memo.ContainsKey(n)) {\n            if (n % 2 == 0) {\n                memo.Add(n, 1 + IntegerReplacement(n / 2));\n            } else {\n                memo.Add(n, 2 + Math.Min(IntegerReplacement(n / 2), IntegerReplacement(n / 2 + 1)));\n            }\n        }\n        return memo[n];\n    }\n}\n\n```\n\n**方法二**\n\n上述两种做法，我们不可避免地在每个回合枚举了所有我们可以做的决策：主要体现在对$x$为奇数时的处理，我们总是处理$x + 1$和$x - 1$两种情况。\n\n可以从二进制的角度进行分析：**给定起始值$n$，求解将其变为$(000...0001)_2$的最小步数**\n\n- 对于偶数（二进制最低位为0）而言，我们只能进行一种操作，其作用是将当前值$x$进行一个单位的右移\n- 对于奇数（二进制最低位为1）而言，我们能进行 **+1**和 **-1**操作，分析两种操作对$x$产生的影响\n  - 对于 **+1**操作而言：最低位必然为1，此时如果次低位为0的话，**+1**相当于将最低位和次低位交换；如果次低位为1的话， **+1操作将将从最低位开始，连续一段的1进行消除（置零）**，并在连续一段的最高一位添加一个1\n  - 对于 **-1**操作而言：最低位必然为1，其作用是将最低位的1进行消除\n\n因此，对于$x$为奇数所能执行的两种操作， **+1**能够消除连续一段的1，只要次低位为1（存在连续端），应当优先使用  **+1**操作，但需要注意边界$x=1$的情况（此时选择 **-1**操作）\n\n此方法个人觉得不如官方题解给的方案，这里给附上网址自行查阅[整数替换 - 整数替换 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/integer-replacement/solution/zheng-shu-ti-huan-by-leetcode-solution-swef/)\n\n```csharp\npublic class Solution {\n    public int IntegerReplacement(int n) {\n        int ans = 0;\n        long tempN = n;\n        while(tempN != 1)\n        {\n            if(tempN % 2 == 0)\n                tempN >>= 1;\n            else\n            {\n                if(tempN != 3 && (tempN >> 1 & 1) == 1)\n                    tempN++;\n                else\n                    tempN--;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}\n```\n","slug":"leetcode","published":1,"updated":"2021-11-19T18:15:54.056Z","_id":"ckvhp3k3600038wupf9m6adcz","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><a href=\"https://leetcode-cn.com/problems/distribute-candies/\">575. 分糖果</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>哈希表</code></p>\n<hr>\n<h2 id=\"Description\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果<strong>平均</strong>分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,2,3,3]\n<strong>输出:</strong> 3\n<strong>解析: </strong>一共有三种种类的糖果，每一种都有两个。\n     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。\n</pre>\n<p><strong>示例 2 :</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,3]\n<strong>输出:</strong> 2\n<strong>解析:</strong> 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>数组的长度为[2, 10,000]，并且确定为偶数。</li>\n\t<li>数组中数字的大小在范围[-100,000, 100,000]内。\n\t<ol>\n\t</ol>\n\t</li>\n</ol>\n</section>\n<h2 id=\"My-Solution\">My Solution</h2>\n<p>假设糖果的数量为<code>n</code>，由于妹妹只能分到一半的苹果，所以答案不会超过<code>n/2</code>。</p>\n<p>假设糖果种类一共有<code>m</code>种，答案也不会超过<code>m</code></p>\n<p>综上所述，答案为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mstyle displaystyle=\"true\" scriptlevel=\"0\"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">min(m,\\cfrac{n}{2} )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.276em;vertical-align:-0.686em;\"></span><span class=\"mord mathnormal\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.59em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.74em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">DistributeCandies</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] candyType</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ISet&lt;<span class=\"built_in\">int</span>&gt; <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> HashSet&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> candyType)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">set</span>.Add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.Min(<span class=\"keyword\">set</span>.Count, candyType.Length / <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\">237. 删除链表中的节点</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>链表</code></p>\n<hr>\n<h2 id=\"Description-2\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点&nbsp;<code>head</code> ，只能直接访问 <strong>要被删除的节点</strong> 。</p>\n<p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 450px; height: 322px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 5\n<strong>输出：</strong>[4,1,9]\n<strong>解释：</strong>指定链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 450px; height: 354px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 1\n<strong>输出：</strong>[4,5,9]\n<strong>解释：</strong>指定链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>head = [1,2,3,4], node = 3\n<strong>输出：</strong>[1,2,4]\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>head = [0,1], node = 0\n<strong>输出：</strong>[1]\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>head = [-3,5,-99], node = -3\n<strong>输出：</strong>[5,-99]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>链表中节点的数目范围是 <code>[2, 1000]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>链表中每个节点的值都是唯一的</li>\n\t<li>需要删除的节点 <code>node</code> 是 <strong>链表中的一个有效节点</strong> ，且 <strong>不是末尾节点</strong></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-2\">My Solution</h2>\n<p>题目保证<code>node</code>是<strong>优先节点</strong>，且不是<strong>末尾节点</strong>，所以将当前节点的值改为下一个节点的值，再将当前节点指向下下节点即可完成覆盖。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DeleteNode</span>(<span class=\"params\">ListNode node</span>)</span> &#123;</span><br><span class=\"line\">        node.val = node.next.val;</span><br><span class=\"line\">        node.next = node.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/trapping-rain-water-ii/\">407. 接雨水 II</a></h1>\n<hr>\n<p>难度 <code>困难</code> | 标签 <code>广度优先搜索</code> <code>数组</code> <code>矩阵</code> <code>堆（优先队列）</code></p>\n<hr>\n<h2 id=\"Description-3\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。\n</pre>\n<p><strong>示例&nbsp;2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n<strong>输出:</strong> 10\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示:</strong></p>\n<ul>\n\t<li><code>m == heightMap.length</code></li>\n\t<li><code>n == heightMap[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n<p>&nbsp;</p>\n</section>\n<h2 id=\"My-Solution-3\">My Solution</h2>\n<p>首先思考一下什么样的方块一定可以接住水：</p>\n<ul>\n<li>该方块不为最外层的方块</li>\n<li>该方块的自身高度比其上下左右四个相邻的方块接水</li>\n</ul>\n<p>我们假设初始时矩阵的每个格子都接满了水，且高度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">maxHeight</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">He</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">maxHeight</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">He</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span></span></span></span> 为矩阵中高度最高的格子。我们知道方块接水后的高度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>，它的求解公式与方法一样。方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的接水后的高度为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]=max(heightMap[i],min(water[i-1][j],water[i+1][j],water[i][j-1],water[i][j+1]))\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">tM</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]))</span></span></span></span></span></p>\n<p>我们知道方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 实际接水的容量计算公式为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>−</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]-heightMap[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">tM</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 。<br>\n我们首先假设每个方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的接水后的高度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">water[i][j]=maxHeight</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">He</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span></span></span></span>，首先我们知道最外层的方块的肯定不能接水，所有的多余的水都会从最外层的方块溢出，我们每次发现当前方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的接水高度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>小于与它相邻的4个模块的接水高度时，则我们将进行调整接水高度，我们将其相邻的四个方块的接水高度调整与<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>高度保持一致，我们不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">TrapRainWater</span>(<span class=\"params\"><span class=\"built_in\">int</span>[][] heightMap</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> m = heightMap.Length;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = heightMap[<span class=\"number\">0</span>].Length;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] dirs = &#123; <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span> &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> maxHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                maxHeight = Math.Max(maxHeight, heightMap[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span>[,] water = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[m, n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                water[i, j] = maxHeight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;<span class=\"built_in\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> Queue&lt;<span class=\"built_in\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; i != m - <span class=\"number\">1</span> &amp;&amp; j != <span class=\"number\">0</span> &amp;&amp; j != n - <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (water[i, j] &lt;= heightMap[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                water[i, j] = heightMap[i][j];</span><br><span class=\"line\">                queue.Enqueue(<span class=\"keyword\">new</span>[]&#123;i, j&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span>[] curr = queue.Dequeue();</span><br><span class=\"line\">            <span class=\"built_in\">int</span> x = curr[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"built_in\">int</span> y = curr[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span> nx = x + dirs[i], ny = y + dirs[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nx &lt; <span class=\"number\">0</span> || nx &gt; m - <span class=\"number\">1</span> || ny &lt; <span class=\"number\">0</span> || ny &gt; n - <span class=\"number\">1</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (water[x, y] &lt; water[nx, ny] &amp;&amp; water[nx, ny] &gt; heightMap[nx][ny])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    water[nx, ny] = Math.Max(water[x, y], heightMap[nx][ny]);</span><br><span class=\"line\">                    queue.Enqueue(<span class=\"keyword\">new</span>[] &#123; nx, ny &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                res += water[i, j] - heightMap[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/valid-perfect-square/\">367. 有效的完全平方数</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数学</code> <code>二分查找</code></p>\n<hr>\n<h2 id=\"Description-4\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p><strong>进阶：不要</strong> 使用任何内置的库函数，如&nbsp; <code>sqrt</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>num = 16\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>num = 14\n<strong>输出：</strong>false\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2^31 - 1</code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-4\">My Solution</h2>\n<p>二分搜索来优化遍历过程</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsPerfectSquare</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>, right = num;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = (right - left) / <span class=\"number\">2</span> + left;</span><br><span class=\"line\">            <span class=\"built_in\">long</span> square = (<span class=\"built_in\">long</span>) mid * mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (square &lt; num) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (square &gt; num) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/\">1218. 最长定差子序列</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>数组</code> <code>哈希表</code> <code>动态规划</code></p>\n<hr>\n<h2 id=\"Description-5\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>difference</code>，请你找出并返回 <code>arr</code>&nbsp;中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>\n<p><strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>arr = [1,2,3,4], difference = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [1,2,3,4]。</pre>\n<p><strong>示例&nbsp;2：</strong></p>\n<pre><strong>输入：</strong>arr = [1,3,5,7], difference = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的等差子序列是任意单个元素。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>arr = [1,5,7,8,5,3,4,2,1], difference = -2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [7,5,3,1]。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= arr[i], difference &lt;= 10<sup>4</sup></code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-5\">My Solution</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy=\"false\">]</mo><mo mathvariant=\"normal\">≠</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">dp[i] = \n\\begin{cases}\ndp[i - difference] + 1,&amp; dp[i-difference] \\neq -1\\\\\n1&amp; dp[i-difference] = -1\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">LongestSubsequence</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] arr, <span class=\"built_in\">int</span> difference</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; dictionary = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> t <span class=\"keyword\">in</span> arr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> number = dictionary.ContainsKey(t - difference) ? dictionary[t - difference] : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dictionary.ContainsKey(t))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dictionary[t] = number + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dictionary.Add(t, number + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            res = Math.Max(res, dictionary[t]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/missing-number/\">268. 丢失的数字</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>位运算</code> <code>数组</code> <code>哈希表</code> <code>数学</code> <code>排序</code></p>\n<hr>\n<h2 id=\"Description-6\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个包含 <code>[0, n]</code>&nbsp;中&nbsp;<code>n</code>&nbsp;个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n<ul>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [3,0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n<b>解释：</b>n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>nums = [0]\n<strong>输出：</strong>1\n<b>解释：</b>n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>\n</section>\n<h2 id=\"My-Solution-6\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MissingNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = nums.Length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res += i;</span><br><span class=\"line\">            res -= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/range-addition-ii/\">598. 范围求和 II</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>数学</code></p>\n<hr>\n<h2 id=\"Description-7\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个初始元素全部为&nbsp;<strong>0</strong>，大小为 m*n 的矩阵&nbsp;<strong>M&nbsp;</strong>以及在&nbsp;<strong>M&nbsp;</strong>上的一系列更新操作。</p>\n<p>操作用二维数组表示，其中的每个操作用一个含有两个<strong>正整数&nbsp;a</strong> 和 <strong>b</strong> 的数组表示，含义是将所有符合&nbsp;<strong>0 &lt;= i &lt; a</strong> 以及 <strong>0 &lt;= j &lt; b</strong> 的元素&nbsp;<strong>M[i][j]&nbsp;</strong>的值都<strong>增加 1</strong>。</p>\n<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> \nm = 3, n = 3\noperations = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n初始状态, M = \n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n执行完操作 [2,2] 后, M = \n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n执行完操作 [3,3] 后, M = \n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\nM 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>m 和 n 的范围是&nbsp;[1,40000]。</li>\n\t<li>a 的范围是 [1,m]，b 的范围是 [1,n]。</li>\n\t<li>操作数目不超过 10000。</li>\n</ol>\n</section>\n<h2 id=\"My-Solution-7\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MaxCount</span>(<span class=\"params\"><span class=\"built_in\">int</span> m, <span class=\"built_in\">int</span> n, <span class=\"built_in\">int</span>[][] ops</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> mina = m, minb = n;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"built_in\">int</span>[] op <span class=\"keyword\">in</span> ops) &#123;</span><br><span class=\"line\">            mina = Math.Min(mina, op[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            minb = Math.Min(minb, op[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mina * minb;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/bulls-and-cows/\">299. 猜数字游戏</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>哈希表</code> <code>字符串</code> <code>计数</code></p>\n<hr>\n<h2 id=\"Description-8\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>你在和朋友一起玩 <a href=\"https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin\">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>\n<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>\n<ul>\n\t<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\", 公牛），</li>\n\t<li>有多少位属于数字猜对了但是位置不对（称为 \"Cows\", 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>\n</ul>\n<p>给你一个秘密数字&nbsp;<code>secret</code> 和朋友猜测的数字&nbsp;<code>guess</code> ，请你返回对朋友这次猜测的提示。</p>\n<p>提示的格式为 <code>\"xAyB\"</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code>&nbsp;表示奶牛。</p>\n<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> secret = \"1807\", guess = \"7810\"\n<strong>输出:</strong> \"1A3B\"\n<strong>解释:</strong> 数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1807\"\n  |\n\"<em><strong>7</strong></em>8<em><strong>10</strong></em>\"</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> secret = \"1123\", guess = \"0111\"\n<strong>输出:</strong> \"1A1B\"\n<strong>解释: </strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1123\"        \"1123\"\n  |      or     |\n\"01<em><strong>1</strong></em>1\"        \"011<em><strong>1</strong></em>\"\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"0\"\n<strong>输出：</strong>\"0A0B\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"1\"\n<strong>输出：</strong>\"1A0B\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>\n</ul>\n</section>\n<h2 id=\"My-Solution-8\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">GetHint</span>(<span class=\"params\"><span class=\"built_in\">string</span> secret, <span class=\"built_in\">string</span> guess</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> bulls = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] cntS = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] cntG = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; secret.Length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (secret[i] == guess[i]) &#123;</span><br><span class=\"line\">                ++bulls;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++cntS[secret[i] - <span class=\"string\">&#x27;0&#x27;</span>];</span><br><span class=\"line\">                ++cntG[guess[i] - <span class=\"string\">&#x27;0&#x27;</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> cows = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">            cows += Math.Min(cntS[i], cntG[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bulls.ToString() + <span class=\"string\">&quot;A&quot;</span> + cows.ToString() + <span class=\"string\">&quot;B&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/teemo-attacking/\">495. 提莫攻击</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>模拟</code></p>\n<hr>\n<h2 id=\"Description-9\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p>\n<p>当提莫攻击艾希，艾希的中毒状态正好持续&nbsp;<code>duration</code> 秒。</p>\n<p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p>\n<p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p>\n<p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,4], duration = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,2], duration = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li>\n</ul>\n</section>\n<h2 id=\"My-Solution-9\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FindPoisonedDuration</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] timeSeries, <span class=\"built_in\">int</span> duration</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> expired = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; timeSeries.Length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeSeries[i] &gt;= expired) &#123;</span><br><span class=\"line\">                ans += duration;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += timeSeries[i] + duration - expired;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            expired = timeSeries[i] + duration;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/k-inverse-pairs-array/\">629. K个逆序对数组</a></h1>\n<hr>\n<p>难度 <code>困难</code> | 标签 <code>动态规划</code></p>\n<hr>\n<h2 id=\"Description-10\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，找出所有包含从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的数字，且恰好拥有&nbsp;<code>k</code>&nbsp;个逆序对的不同的数组的个数。</p>\n<p>逆序对的定义如下：对于数组的第<code>i</code>个和第&nbsp;<code>j</code>个元素，如果满<code>i</code>&nbsp;&lt;&nbsp;<code>j</code>且&nbsp;<code>a[i]</code>&nbsp;&gt;&nbsp;<code>a[j]</code>，则其为一个逆序对；否则不是。</p>\n<p>由于答案可能很大，只需要返回 答案 mod 10<sup>9</sup>&nbsp;+ 7 的值。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 0\n<strong>输出:</strong> 1\n<strong>解释:</strong> \n只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 1\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n</pre>\n<p><strong>说明:</strong></p>\n<ol>\n\t<li>&nbsp;<code>n</code>&nbsp;的范围是 [1, 1000] 并且 <code>k</code> 的范围是 [0, 1000]。</li>\n</ol>\n</section>\n<h2 id=\"My-Solution-10\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">KInversePairs</span>(<span class=\"params\"><span class=\"built_in\">int</span> n, <span class=\"built_in\">int</span> k</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> MOD = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[,] f = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">2</span>, k + <span class=\"number\">1</span>];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>, <span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt;= k; ++j) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span> cur = i &amp; <span class=\"number\">1</span>, prev = cur ^ <span class=\"number\">1</span>;</span><br><span class=\"line\">                f[cur, j] = (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> ? f[cur, j - <span class=\"number\">1</span>] : <span class=\"number\">0</span>) - (j - i &gt;= <span class=\"number\">0</span> ? f[prev, j - i] : <span class=\"number\">0</span>) + f[prev, j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[cur, j] &gt;= MOD) &#123;</span><br><span class=\"line\">                    f[cur, j] -= MOD;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f[cur, j] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    f[cur, j] += MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[n &amp; <span class=\"number\">1</span>, k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/perfect-rectangle/\">391. 完美矩形</a></h1>\n<hr>\n<p>难度 <code>困难</code> | 标签 <code>数组</code> <code>扫描线</code></p>\n<hr>\n<h2 id=\"Description-11\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，右上顶点是 <code>(a<sub>i</sub>, b<sub>i</sub>)</code> 。</p>\n<p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>5 个矩形一起可以精确地覆盖一个矩形区域。 \n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>两个矩形之间有间隔，无法覆盖成一个矩形。</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec3-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>图形顶端留有空缺，无法覆盖成一个矩形。</pre>\n<p><strong>示例 4：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == 4</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-11\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsRectangleCover</span>(<span class=\"params\"><span class=\"built_in\">int</span>[][] rectangles</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n = rectangles.Length;</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[][] rs = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">2</span> * n][];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>, idx = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] re = rectangles[i];</span><br><span class=\"line\">        rs[idx++] = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[] &#123; re[<span class=\"number\">0</span>], re[<span class=\"number\">1</span>], re[<span class=\"number\">3</span>], <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">        rs[idx++] = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[] &#123; re[<span class=\"number\">2</span>], re[<span class=\"number\">1</span>], re[<span class=\"number\">3</span>], <span class=\"number\">-1</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Array.Sort(rs, ((a, b) =&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[<span class=\"number\">0</span>] != b[<span class=\"number\">0</span>])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">    n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    List&lt;<span class=\"built_in\">int</span>[]&gt; l1 = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>[]&gt;(), l2 = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>[]&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> l = <span class=\"number\">0</span>; l &lt; n;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> r = l;</span><br><span class=\"line\">        l1.Clear();</span><br><span class=\"line\">        l2.Clear();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &lt; n &amp;&amp; rs[r][<span class=\"number\">0</span>] == rs[l][<span class=\"number\">0</span>])</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = l; i &lt; r; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span>[] cur = <span class=\"keyword\">new</span>[] &#123; rs[i][<span class=\"number\">1</span>], rs[i][<span class=\"number\">2</span>] &#125;;</span><br><span class=\"line\">            List&lt;<span class=\"built_in\">int</span>[]&gt; list = rs[i][<span class=\"number\">3</span>] == <span class=\"number\">1</span> ? l1 : l2;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list.Count &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                list.Add(cur);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span>[] prev = list[^<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur[<span class=\"number\">0</span>] &lt; prev[<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur[<span class=\"number\">0</span>] == prev[<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    prev[<span class=\"number\">1</span>] = cur[<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    list.Add(cur);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; <span class=\"number\">0</span> &amp;&amp; r &lt; n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1.Count != l2.Count)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; l1.Count; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (l1[i][<span class=\"number\">0</span>] == l2[i][<span class=\"number\">0</span>] &amp;&amp; l1[i][<span class=\"number\">1</span>] == l2[i][<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1.Count + l2.Count != <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        l = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\">318. 最大单词长度乘积</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>位运算</code> <code>数组</code> <code>字符串</code></p>\n<hr>\n<h2 id=\"Description-12\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个字符串数组&nbsp;<code>words</code>，找到&nbsp;<code>length(word[i]) * length(word[j])</code>&nbsp;的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>\n<p>&nbsp;</p>\n<p><strong>示例&nbsp;1:</strong></p>\n<pre><strong>输入:</strong> <code>[\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]</code>\n<strong>输出: </strong><code>16 \n<strong>解释:</strong> 这两个单词为<strong> </strong></code><code>\"abcw\", \"xtfn\"</code>。</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]</code>\n<strong>输出: </strong><code>4 \n<strong>解释: </strong></code>这两个单词为 <code>\"ab\", \"cd\"</code>。</pre>\n<p><strong>示例 3:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"aa\",\"aaa\",\"aaaa\"]</code>\n<strong>输出: </strong><code>0 \n<strong>解释: </strong>不存在这样的两个单词。</code>\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n</section>\n<h2 id=\"My-Solution-12\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MaxProduct</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] words</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] masks = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[words.Length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; words.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; words[i].Length; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                masks[i] |= <span class=\"number\">1</span> &lt;&lt; (words[i][j] - <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; words.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> j = i; j &lt; words.Length; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((masks[i] &amp; masks[j]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    res = Math.Max(res, words[i].Length * words[j].Length);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/binary-tree-tilt/\">563. 二叉树的坡度</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>树</code> <code>深度优先搜索</code> <code>二叉树</code></p>\n<hr>\n<h2 id=\"Description-13\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个二叉树，计算 <strong>整个树 </strong>的坡度 。</p>\n<p>一个树的<strong> 节点的坡度 </strong>定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值 </strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 712px; height: 182px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 800px; height: 203px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [4,2,9,3,5,null,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 800px; height: 293px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [21,7,14,1,1,2,2,3,3]\n<strong>输出：</strong>9\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数目的范围在 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-13\">My Solution</h2>\n<p>实现思路如下：</p>\n<ul>\n<li>从根节点开始遍历，设当前节点为<code>node</code></li>\n<li>遍历<code>node</code>的左右节点<code>left</code>和<code>right</code>，将两者节点之和的差的绝对值累加到结果<code>res</code></li>\n<li>返回<code>node</code>作为根节点的树的节点之和<code>left + right + node.val</code></li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FindTilt</span>(<span class=\"params\">TreeNode root</span>)</span> &#123;</span><br><span class=\"line\">        DFS(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">DFS</span>(<span class=\"params\">TreeNode node</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = DFS(node.left);</span><br><span class=\"line\">        <span class=\"built_in\">int</span> right = DFS(node.right);</span><br><span class=\"line\">        res += Math.Abs(left - right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right + node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/integer-replacement/\">397. 整数替换</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>贪心</code> <code>位运算</code> <code>记忆化搜索</code> <code>动态规划</code></p>\n<hr>\n<h2 id=\"Description-14\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个正整数&nbsp;<code>n</code> ，你可以做如下操作：</p>\n<ol>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是偶数，则用&nbsp;<code>n / 2</code>替换&nbsp;<code>n</code><em> </em>。</li>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是奇数，则可以用&nbsp;<code>n + 1</code>或<code>n - 1</code>替换&nbsp;<code>n</code> 。</li>\n</ol>\n<p><code>n</code><em>&nbsp;</em>变为 <code>1</code> 所需的最小替换次数是多少？</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\n或 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-14\">My Solution</h2>\n<p><strong>方法一</strong></p>\n<ul>\n<li>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>为偶数时，我们只有唯一的办法将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>替换为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle displaystyle=\"true\" scriptlevel=\"0\"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mrow><annotation encoding=\"application/x-tex\">\\dfrac{n}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.7936em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>当n为奇数时，我们可以选择将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>增加1或减少1。由于这两种方法都会将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>变为偶数，那么下一步一定是除2，因此这里可以堪称使用两次操作，将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>变为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n-1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n</ul>\n<p>这里需要注意<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n = 2^{31}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">31</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>时，计算<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>会溢出，所以用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac{n}{2} \\rfloor + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac{n}{2} \\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span>分别计算<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n-1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; memo = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">IntegerReplacement</span>(<span class=\"params\"><span class=\"built_in\">int</span> n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!memo.ContainsKey(n)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                memo.Add(n, <span class=\"number\">1</span> + IntegerReplacement(n / <span class=\"number\">2</span>));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                memo.Add(n, <span class=\"number\">2</span> + Math.Min(IntegerReplacement(n / <span class=\"number\">2</span>), IntegerReplacement(n / <span class=\"number\">2</span> + <span class=\"number\">1</span>)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>方法二</strong></p>\n<p>上述两种做法，我们不可避免地在每个回合枚举了所有我们可以做的决策：主要体现在对<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>为奇数时的处理，我们总是处理<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>两种情况。</p>\n<p>可以从二进制的角度进行分析：<strong>给定起始值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，求解将其变为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>000...0001</mn><msub><mo stretchy=\"false\">)</mo><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">(000...0001)_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">000...0001</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的最小步数</strong></p>\n<ul>\n<li>对于偶数（二进制最低位为0）而言，我们只能进行一种操作，其作用是将当前值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>进行一个单位的右移</li>\n<li>对于奇数（二进制最低位为1）而言，我们能进行 <strong>+1</strong>和 <strong>-1</strong>操作，分析两种操作对<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>产生的影响\n<ul>\n<li>对于 <strong>+1</strong>操作而言：最低位必然为1，此时如果次低位为0的话，<strong>+1</strong>相当于将最低位和次低位交换；如果次低位为1的话， <strong>+1操作将将从最低位开始，连续一段的1进行消除（置零）</strong>，并在连续一段的最高一位添加一个1</li>\n<li>对于 <strong>-1</strong>操作而言：最低位必然为1，其作用是将最低位的1进行消除</li>\n</ul>\n</li>\n</ul>\n<p>因此，对于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>为奇数所能执行的两种操作， <strong>+1</strong>能够消除连续一段的1，只要次低位为1（存在连续端），应当优先使用  <strong>+1</strong>操作，但需要注意边界<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>的情况（此时选择 <strong>-1</strong>操作）</p>\n<p>此方法个人觉得不如官方题解给的方案，这里给附上网址自行查阅<a href=\"https://leetcode-cn.com/problems/integer-replacement/solution/zheng-shu-ti-huan-by-leetcode-solution-swef/\">整数替换 - 整数替换 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">IntegerReplacement</span>(<span class=\"params\"><span class=\"built_in\">int</span> n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">long</span> tempN = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(tempN != <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tempN % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                tempN &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tempN != <span class=\"number\">3</span> &amp;&amp; (tempN &gt;&gt; <span class=\"number\">1</span> &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>)</span><br><span class=\"line\">                    tempN++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    tempN--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://z3.ax1x.com/2021/11/20/Iq0ZTg.jpg","excerpt":"","more":"<h1><a href=\"https://leetcode-cn.com/problems/distribute-candies/\">575. 分糖果</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>哈希表</code></p>\n<hr>\n<h2 id=\"Description\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果<strong>平均</strong>分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,2,3,3]\n<strong>输出:</strong> 3\n<strong>解析: </strong>一共有三种种类的糖果，每一种都有两个。\n     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。\n</pre>\n<p><strong>示例 2 :</strong></p>\n<pre><strong>输入:</strong> candies = [1,1,2,3]\n<strong>输出:</strong> 2\n<strong>解析:</strong> 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>数组的长度为[2, 10,000]，并且确定为偶数。</li>\n\t<li>数组中数字的大小在范围[-100,000, 100,000]内。\n\t<ol>\n\t</ol>\n\t</li>\n</ol>\n</section>\n<h2 id=\"My-Solution\">My Solution</h2>\n<p>假设糖果的数量为<code>n</code>，由于妹妹只能分到一半的苹果，所以答案不会超过<code>n/2</code>。</p>\n<p>假设糖果种类一共有<code>m</code>种，答案也不会超过<code>m</code></p>\n<p>综上所述，答案为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mstyle displaystyle=\"true\" scriptlevel=\"0\"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">min(m,\\cfrac{n}{2} )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.276em;vertical-align:-0.686em;\"></span><span class=\"mord mathnormal\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.59em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.74em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">DistributeCandies</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] candyType</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ISet&lt;<span class=\"built_in\">int</span>&gt; <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> HashSet&lt;<span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> candyType)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">set</span>.Add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.Min(<span class=\"keyword\">set</span>.Count, candyType.Length / <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\">237. 删除链表中的节点</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>链表</code></p>\n<hr>\n<h2 id=\"Description-2\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点&nbsp;<code>head</code> ，只能直接访问 <strong>要被删除的节点</strong> 。</p>\n<p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 450px; height: 322px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 5\n<strong>输出：</strong>[4,1,9]\n<strong>解释：</strong>指定链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 450px; height: 354px;\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>head = [4,5,1,9], node = 1\n<strong>输出：</strong>[4,5,9]\n<strong>解释：</strong>指定链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>head = [1,2,3,4], node = 3\n<strong>输出：</strong>[1,2,4]\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>head = [0,1], node = 0\n<strong>输出：</strong>[1]\n</pre>\n<p><strong>示例 5：</strong></p>\n<pre><strong>输入：</strong>head = [-3,5,-99], node = -3\n<strong>输出：</strong>[5,-99]\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>链表中节点的数目范围是 <code>[2, 1000]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>链表中每个节点的值都是唯一的</li>\n\t<li>需要删除的节点 <code>node</code> 是 <strong>链表中的一个有效节点</strong> ，且 <strong>不是末尾节点</strong></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-2\">My Solution</h2>\n<p>题目保证<code>node</code>是<strong>优先节点</strong>，且不是<strong>末尾节点</strong>，所以将当前节点的值改为下一个节点的值，再将当前节点指向下下节点即可完成覆盖。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DeleteNode</span>(<span class=\"params\">ListNode node</span>)</span> &#123;</span><br><span class=\"line\">        node.val = node.next.val;</span><br><span class=\"line\">        node.next = node.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/trapping-rain-water-ii/\">407. 接雨水 II</a></h1>\n<hr>\n<p>难度 <code>困难</code> | 标签 <code>广度优先搜索</code> <code>数组</code> <code>矩阵</code> <code>堆（优先队列）</code></p>\n<hr>\n<h2 id=\"Description-3\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。\n</pre>\n<p><strong>示例&nbsp;2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg\" alt=\"\"></p>\n<pre><strong>输入:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n<strong>输出:</strong> 10\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示:</strong></p>\n<ul>\n\t<li><code>m == heightMap.length</code></li>\n\t<li><code>n == heightMap[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n<p>&nbsp;</p>\n</section>\n<h2 id=\"My-Solution-3\">My Solution</h2>\n<p>首先思考一下什么样的方块一定可以接住水：</p>\n<ul>\n<li>该方块不为最外层的方块</li>\n<li>该方块的自身高度比其上下左右四个相邻的方块接水</li>\n</ul>\n<p>我们假设初始时矩阵的每个格子都接满了水，且高度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">maxHeight</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">He</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span></span></span></span>，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">maxHeight</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">He</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span></span></span></span> 为矩阵中高度最高的格子。我们知道方块接水后的高度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>，它的求解公式与方法一样。方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的接水后的高度为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]=max(heightMap[i],min(water[i-1][j],water[i+1][j],water[i][j-1],water[i][j+1]))\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">tM</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]))</span></span></span></span></span></p>\n<p>我们知道方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 实际接水的容量计算公式为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>−</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]-heightMap[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">tM</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 。<br>\n我们首先假设每个方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的接水后的高度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>H</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">water[i][j]=maxHeight</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">He</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span></span></span></span>，首先我们知道最外层的方块的肯定不能接水，所有的多余的水都会从最外层的方块溢出，我们每次发现当前方块 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span> 的接水高度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">water[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>小于与它相邻的4个模块的接水高度时，则我们将进行调整接水高度，我们将其相邻的四个方块的接水高度调整与<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>高度保持一致，我们不断重复的进行调整，直到所有的方块的接水高度不再有调整时即为满足要求。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">TrapRainWater</span>(<span class=\"params\"><span class=\"built_in\">int</span>[][] heightMap</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> m = heightMap.Length;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = heightMap[<span class=\"number\">0</span>].Length;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] dirs = &#123; <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span> &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> maxHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                maxHeight = Math.Max(maxHeight, heightMap[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span>[,] water = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[m, n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                water[i, j] = maxHeight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;<span class=\"built_in\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> Queue&lt;<span class=\"built_in\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; i != m - <span class=\"number\">1</span> &amp;&amp; j != <span class=\"number\">0</span> &amp;&amp; j != n - <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (water[i, j] &lt;= heightMap[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                water[i, j] = heightMap[i][j];</span><br><span class=\"line\">                queue.Enqueue(<span class=\"keyword\">new</span>[]&#123;i, j&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span>[] curr = queue.Dequeue();</span><br><span class=\"line\">            <span class=\"built_in\">int</span> x = curr[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"built_in\">int</span> y = curr[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span> nx = x + dirs[i], ny = y + dirs[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nx &lt; <span class=\"number\">0</span> || nx &gt; m - <span class=\"number\">1</span> || ny &lt; <span class=\"number\">0</span> || ny &gt; n - <span class=\"number\">1</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (water[x, y] &lt; water[nx, ny] &amp;&amp; water[nx, ny] &gt; heightMap[nx][ny])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    water[nx, ny] = Math.Max(water[x, y], heightMap[nx][ny]);</span><br><span class=\"line\">                    queue.Enqueue(<span class=\"keyword\">new</span>[] &#123; nx, ny &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                res += water[i, j] - heightMap[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/valid-perfect-square/\">367. 有效的完全平方数</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数学</code> <code>二分查找</code></p>\n<hr>\n<h2 id=\"Description-4\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p><strong>进阶：不要</strong> 使用任何内置的库函数，如&nbsp; <code>sqrt</code> 。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>num = 16\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>num = 14\n<strong>输出：</strong>false\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2^31 - 1</code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-4\">My Solution</h2>\n<p>二分搜索来优化遍历过程</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsPerfectSquare</span>(<span class=\"params\"><span class=\"built_in\">int</span> num</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = <span class=\"number\">0</span>, right = num;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> mid = (right - left) / <span class=\"number\">2</span> + left;</span><br><span class=\"line\">            <span class=\"built_in\">long</span> square = (<span class=\"built_in\">long</span>) mid * mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (square &lt; num) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (square &gt; num) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/\">1218. 最长定差子序列</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>数组</code> <code>哈希表</code> <code>动态规划</code></p>\n<hr>\n<h2 id=\"Description-5\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>difference</code>，请你找出并返回 <code>arr</code>&nbsp;中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>\n<p><strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>arr = [1,2,3,4], difference = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [1,2,3,4]。</pre>\n<p><strong>示例&nbsp;2：</strong></p>\n<pre><strong>输入：</strong>arr = [1,3,5,7], difference = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的等差子序列是任意单个元素。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>arr = [1,5,7,8,5,3,4,2,1], difference = -2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [7,5,3,1]。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= arr[i], difference &lt;= 10<sup>4</sup></code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-5\">My Solution</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.36em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy=\"false\">]</mo><mo mathvariant=\"normal\">≠</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">dp[i] = \n\\begin{cases}\ndp[i - difference] + 1,&amp; dp[i-difference] \\neq -1\\\\\n1&amp; dp[i-difference] = -1\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">LongestSubsequence</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] arr, <span class=\"built_in\">int</span> difference</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; dictionary = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> t <span class=\"keyword\">in</span> arr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> number = dictionary.ContainsKey(t - difference) ? dictionary[t - difference] : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dictionary.ContainsKey(t))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dictionary[t] = number + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dictionary.Add(t, number + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            res = Math.Max(res, dictionary[t]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/missing-number/\">268. 丢失的数字</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>位运算</code> <code>数组</code> <code>哈希表</code> <code>数学</code> <code>排序</code></p>\n<hr>\n<h2 id=\"Description-6\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个包含 <code>[0, n]</code>&nbsp;中&nbsp;<code>n</code>&nbsp;个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n<ul>\n</ul>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [3,0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n<b>解释：</b>n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>nums = [0]\n<strong>输出：</strong>1\n<b>解释：</b>n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>\n</section>\n<h2 id=\"My-Solution-6\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MissingNumber</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] nums</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = nums.Length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; nums.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res += i;</span><br><span class=\"line\">            res -= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/range-addition-ii/\">598. 范围求和 II</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>数学</code></p>\n<hr>\n<h2 id=\"Description-7\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个初始元素全部为&nbsp;<strong>0</strong>，大小为 m*n 的矩阵&nbsp;<strong>M&nbsp;</strong>以及在&nbsp;<strong>M&nbsp;</strong>上的一系列更新操作。</p>\n<p>操作用二维数组表示，其中的每个操作用一个含有两个<strong>正整数&nbsp;a</strong> 和 <strong>b</strong> 的数组表示，含义是将所有符合&nbsp;<strong>0 &lt;= i &lt; a</strong> 以及 <strong>0 &lt;= j &lt; b</strong> 的元素&nbsp;<strong>M[i][j]&nbsp;</strong>的值都<strong>增加 1</strong>。</p>\n<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> \nm = 3, n = 3\noperations = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n初始状态, M = \n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n执行完操作 [2,2] 后, M = \n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n执行完操作 [3,3] 后, M = \n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\nM 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n<p><strong>注意:</strong></p>\n<ol>\n\t<li>m 和 n 的范围是&nbsp;[1,40000]。</li>\n\t<li>a 的范围是 [1,m]，b 的范围是 [1,n]。</li>\n\t<li>操作数目不超过 10000。</li>\n</ol>\n</section>\n<h2 id=\"My-Solution-7\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MaxCount</span>(<span class=\"params\"><span class=\"built_in\">int</span> m, <span class=\"built_in\">int</span> n, <span class=\"built_in\">int</span>[][] ops</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> mina = m, minb = n;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"built_in\">int</span>[] op <span class=\"keyword\">in</span> ops) &#123;</span><br><span class=\"line\">            mina = Math.Min(mina, op[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            minb = Math.Min(minb, op[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mina * minb;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/bulls-and-cows/\">299. 猜数字游戏</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>哈希表</code> <code>字符串</code> <code>计数</code></p>\n<hr>\n<h2 id=\"Description-8\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>你在和朋友一起玩 <a href=\"https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin\">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>\n<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>\n<ul>\n\t<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\", 公牛），</li>\n\t<li>有多少位属于数字猜对了但是位置不对（称为 \"Cows\", 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>\n</ul>\n<p>给你一个秘密数字&nbsp;<code>secret</code> 和朋友猜测的数字&nbsp;<code>guess</code> ，请你返回对朋友这次猜测的提示。</p>\n<p>提示的格式为 <code>\"xAyB\"</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code>&nbsp;表示奶牛。</p>\n<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> secret = \"1807\", guess = \"7810\"\n<strong>输出:</strong> \"1A3B\"\n<strong>解释:</strong> 数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1807\"\n  |\n\"<em><strong>7</strong></em>8<em><strong>10</strong></em>\"</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> secret = \"1123\", guess = \"0111\"\n<strong>输出:</strong> \"1A1B\"\n<strong>解释: </strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1123\"        \"1123\"\n  |      or     |\n\"01<em><strong>1</strong></em>1\"        \"011<em><strong>1</strong></em>\"\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"0\"\n<strong>输出：</strong>\"0A0B\"\n</pre>\n<p><strong>示例 4：</strong></p>\n<pre><strong>输入：</strong>secret = \"1\", guess = \"1\"\n<strong>输出：</strong>\"1A0B\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>\n</ul>\n</section>\n<h2 id=\"My-Solution-8\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">GetHint</span>(<span class=\"params\"><span class=\"built_in\">string</span> secret, <span class=\"built_in\">string</span> guess</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> bulls = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] cntS = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] cntG = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; secret.Length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (secret[i] == guess[i]) &#123;</span><br><span class=\"line\">                ++bulls;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++cntS[secret[i] - <span class=\"string\">&#x27;0&#x27;</span>];</span><br><span class=\"line\">                ++cntG[guess[i] - <span class=\"string\">&#x27;0&#x27;</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> cows = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">            cows += Math.Min(cntS[i], cntG[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bulls.ToString() + <span class=\"string\">&quot;A&quot;</span> + cows.ToString() + <span class=\"string\">&quot;B&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/teemo-attacking/\">495. 提莫攻击</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>数组</code> <code>模拟</code></p>\n<hr>\n<h2 id=\"Description-9\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p>\n<p>当提莫攻击艾希，艾希的中毒状态正好持续&nbsp;<code>duration</code> 秒。</p>\n<p>正式地讲，提莫在 <code>t</code> 发起发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p>\n<p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p>\n<p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,4], duration = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>timeSeries = [1,2], duration = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li>\n</ul>\n</section>\n<h2 id=\"My-Solution-9\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FindPoisonedDuration</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] timeSeries, <span class=\"built_in\">int</span> duration</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> expired = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; timeSeries.Length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeSeries[i] &gt;= expired) &#123;</span><br><span class=\"line\">                ans += duration;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += timeSeries[i] + duration - expired;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            expired = timeSeries[i] + duration;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/k-inverse-pairs-array/\">629. K个逆序对数组</a></h1>\n<hr>\n<p>难度 <code>困难</code> | 标签 <code>动态规划</code></p>\n<hr>\n<h2 id=\"Description-10\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给出两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，找出所有包含从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的数字，且恰好拥有&nbsp;<code>k</code>&nbsp;个逆序对的不同的数组的个数。</p>\n<p>逆序对的定义如下：对于数组的第<code>i</code>个和第&nbsp;<code>j</code>个元素，如果满<code>i</code>&nbsp;&lt;&nbsp;<code>j</code>且&nbsp;<code>a[i]</code>&nbsp;&gt;&nbsp;<code>a[j]</code>，则其为一个逆序对；否则不是。</p>\n<p>由于答案可能很大，只需要返回 答案 mod 10<sup>9</sup>&nbsp;+ 7 的值。</p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 0\n<strong>输出:</strong> 1\n<strong>解释:</strong> \n只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> n = 3, k = 1\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n</pre>\n<p><strong>说明:</strong></p>\n<ol>\n\t<li>&nbsp;<code>n</code>&nbsp;的范围是 [1, 1000] 并且 <code>k</code> 的范围是 [0, 1000]。</li>\n</ol>\n</section>\n<h2 id=\"My-Solution-10\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">KInversePairs</span>(<span class=\"params\"><span class=\"built_in\">int</span> n, <span class=\"built_in\">int</span> k</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> MOD = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[,] f = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">2</span>, k + <span class=\"number\">1</span>];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>, <span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt;= k; ++j) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span> cur = i &amp; <span class=\"number\">1</span>, prev = cur ^ <span class=\"number\">1</span>;</span><br><span class=\"line\">                f[cur, j] = (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> ? f[cur, j - <span class=\"number\">1</span>] : <span class=\"number\">0</span>) - (j - i &gt;= <span class=\"number\">0</span> ? f[prev, j - i] : <span class=\"number\">0</span>) + f[prev, j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f[cur, j] &gt;= MOD) &#123;</span><br><span class=\"line\">                    f[cur, j] -= MOD;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f[cur, j] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    f[cur, j] += MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[n &amp; <span class=\"number\">1</span>, k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/perfect-rectangle/\">391. 完美矩形</a></h1>\n<hr>\n<p>难度 <code>困难</code> | 标签 <code>数组</code> <code>扫描线</code></p>\n<hr>\n<h2 id=\"Description-11\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，右上顶点是 <code>(a<sub>i</sub>, b<sub>i</sub>)</code> 。</p>\n<p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n&nbsp;\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>5 个矩形一起可以精确地覆盖一个矩形区域。 \n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>两个矩形之间有间隔，无法覆盖成一个矩形。</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec3-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>图形顶端留有空缺，无法覆盖成一个矩形。</pre>\n<p><strong>示例 4：</strong></p>\n<img style=\"width: 300px; height: 294px;\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg\" alt=\"\">\n<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == 4</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-11\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsRectangleCover</span>(<span class=\"params\"><span class=\"built_in\">int</span>[][] rectangles</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n = rectangles.Length;</span><br><span class=\"line\">    <span class=\"built_in\">int</span>[][] rs = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">2</span> * n][];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>, idx = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] re = rectangles[i];</span><br><span class=\"line\">        rs[idx++] = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[] &#123; re[<span class=\"number\">0</span>], re[<span class=\"number\">1</span>], re[<span class=\"number\">3</span>], <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">        rs[idx++] = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[] &#123; re[<span class=\"number\">2</span>], re[<span class=\"number\">1</span>], re[<span class=\"number\">3</span>], <span class=\"number\">-1</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Array.Sort(rs, ((a, b) =&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[<span class=\"number\">0</span>] != b[<span class=\"number\">0</span>])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">    n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    List&lt;<span class=\"built_in\">int</span>[]&gt; l1 = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>[]&gt;(), l2 = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">int</span>[]&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> l = <span class=\"number\">0</span>; l &lt; n;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> r = l;</span><br><span class=\"line\">        l1.Clear();</span><br><span class=\"line\">        l2.Clear();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &lt; n &amp;&amp; rs[r][<span class=\"number\">0</span>] == rs[l][<span class=\"number\">0</span>])</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = l; i &lt; r; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span>[] cur = <span class=\"keyword\">new</span>[] &#123; rs[i][<span class=\"number\">1</span>], rs[i][<span class=\"number\">2</span>] &#125;;</span><br><span class=\"line\">            List&lt;<span class=\"built_in\">int</span>[]&gt; list = rs[i][<span class=\"number\">3</span>] == <span class=\"number\">1</span> ? l1 : l2;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list.Count &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                list.Add(cur);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">int</span>[] prev = list[^<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur[<span class=\"number\">0</span>] &lt; prev[<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur[<span class=\"number\">0</span>] == prev[<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    prev[<span class=\"number\">1</span>] = cur[<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    list.Add(cur);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; <span class=\"number\">0</span> &amp;&amp; r &lt; n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1.Count != l2.Count)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; l1.Count; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (l1[i][<span class=\"number\">0</span>] == l2[i][<span class=\"number\">0</span>] &amp;&amp; l1[i][<span class=\"number\">1</span>] == l2[i][<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1.Count + l2.Count != <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        l = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\">318. 最大单词长度乘积</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>位运算</code> <code>数组</code> <code>字符串</code></p>\n<hr>\n<h2 id=\"Description-12\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个字符串数组&nbsp;<code>words</code>，找到&nbsp;<code>length(word[i]) * length(word[j])</code>&nbsp;的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>\n<p>&nbsp;</p>\n<p><strong>示例&nbsp;1:</strong></p>\n<pre><strong>输入:</strong> <code>[\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]</code>\n<strong>输出: </strong><code>16 \n<strong>解释:</strong> 这两个单词为<strong> </strong></code><code>\"abcw\", \"xtfn\"</code>。</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]</code>\n<strong>输出: </strong><code>4 \n<strong>解释: </strong></code>这两个单词为 <code>\"ab\", \"cd\"</code>。</pre>\n<p><strong>示例 3:</strong></p>\n<pre><strong>输入:</strong> <code>[\"a\",\"aa\",\"aaa\",\"aaaa\"]</code>\n<strong>输出: </strong><code>0 \n<strong>解释: </strong>不存在这样的两个单词。</code>\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n</section>\n<h2 id=\"My-Solution-12\">My Solution</h2>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">MaxProduct</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] words</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] masks = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[words.Length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; words.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> j = <span class=\"number\">0</span>; j &lt; words[i].Length; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                masks[i] |= <span class=\"number\">1</span> &lt;&lt; (words[i][j] - <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; words.Length; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> j = i; j &lt; words.Length; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((masks[i] &amp; masks[j]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    res = Math.Max(res, words[i].Length * words[j].Length);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/binary-tree-tilt/\">563. 二叉树的坡度</a></h1>\n<hr>\n<p>难度 <code>简单</code> | 标签 <code>树</code> <code>深度优先搜索</code> <code>二叉树</code></p>\n<hr>\n<h2 id=\"Description-13\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个二叉树，计算 <strong>整个树 </strong>的坡度 。</p>\n<p>一个树的<strong> 节点的坡度 </strong>定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值 </strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<img style=\"width: 712px; height: 182px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<img style=\"width: 800px; height: 203px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [4,2,9,3,5,null,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n<p><strong>示例 3：</strong></p>\n<img style=\"width: 800px; height: 293px;\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" alt=\"\">\n<pre><strong>输入：</strong>root = [21,7,14,1,1,2,2,3,3]\n<strong>输出：</strong>9\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li>树中节点数目的范围在 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-13\">My Solution</h2>\n<p>实现思路如下：</p>\n<ul>\n<li>从根节点开始遍历，设当前节点为<code>node</code></li>\n<li>遍历<code>node</code>的左右节点<code>left</code>和<code>right</code>，将两者节点之和的差的绝对值累加到结果<code>res</code></li>\n<li>返回<code>node</code>作为根节点的树的节点之和<code>left + right + node.val</code></li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FindTilt</span>(<span class=\"params\">TreeNode root</span>)</span> &#123;</span><br><span class=\"line\">        DFS(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">DFS</span>(<span class=\"params\">TreeNode node</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> left = DFS(node.left);</span><br><span class=\"line\">        <span class=\"built_in\">int</span> right = DFS(node.right);</span><br><span class=\"line\">        res += Math.Abs(left - right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right + node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><a href=\"https://leetcode-cn.com/problems/integer-replacement/\">397. 整数替换</a></h1>\n<hr>\n<p>难度 <code>中等</code> | 标签 <code>贪心</code> <code>位运算</code> <code>记忆化搜索</code> <code>动态规划</code></p>\n<hr>\n<h2 id=\"Description-14\">Description</h2>\n<style>\nsection pre{\n    background-color: #eee;\n    border: 1px solid #ddd;\n    padding:10px;\n    border-radius: 5px;\n}\n</style>\n<section>\n<p>给定一个正整数&nbsp;<code>n</code> ，你可以做如下操作：</p>\n<ol>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是偶数，则用&nbsp;<code>n / 2</code>替换&nbsp;<code>n</code><em> </em>。</li>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是奇数，则可以用&nbsp;<code>n + 1</code>或<code>n - 1</code>替换&nbsp;<code>n</code> 。</li>\n</ol>\n<p><code>n</code><em>&nbsp;</em>变为 <code>1</code> 所需的最小替换次数是多少？</p>\n<p>&nbsp;</p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\n或 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n</pre>\n<p>&nbsp;</p>\n<p><strong>提示：</strong></p>\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n</section>\n<h2 id=\"My-Solution-14\">My Solution</h2>\n<p><strong>方法一</strong></p>\n<ul>\n<li>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>为偶数时，我们只有唯一的办法将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>替换为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle displaystyle=\"true\" scriptlevel=\"0\"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle></mrow><annotation encoding=\"application/x-tex\">\\dfrac{n}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.7936em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n<li>当n为奇数时，我们可以选择将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>增加1或减少1。由于这两种方法都会将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>变为偶数，那么下一步一定是除2，因此这里可以堪称使用两次操作，将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>变为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n-1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></li>\n</ul>\n<p>这里需要注意<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n = 2^{31}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">31</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>时，计算<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>会溢出，所以用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac{n}{2} \\rfloor + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac{n}{2} \\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span>分别计算<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n+1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n-1}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; memo = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">IntegerReplacement</span>(<span class=\"params\"><span class=\"built_in\">int</span> n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!memo.ContainsKey(n)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                memo.Add(n, <span class=\"number\">1</span> + IntegerReplacement(n / <span class=\"number\">2</span>));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                memo.Add(n, <span class=\"number\">2</span> + Math.Min(IntegerReplacement(n / <span class=\"number\">2</span>), IntegerReplacement(n / <span class=\"number\">2</span> + <span class=\"number\">1</span>)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>方法二</strong></p>\n<p>上述两种做法，我们不可避免地在每个回合枚举了所有我们可以做的决策：主要体现在对<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>为奇数时的处理，我们总是处理<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>两种情况。</p>\n<p>可以从二进制的角度进行分析：<strong>给定起始值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，求解将其变为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>000...0001</mn><msub><mo stretchy=\"false\">)</mo><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">(000...0001)_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">000...0001</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>的最小步数</strong></p>\n<ul>\n<li>对于偶数（二进制最低位为0）而言，我们只能进行一种操作，其作用是将当前值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>进行一个单位的右移</li>\n<li>对于奇数（二进制最低位为1）而言，我们能进行 <strong>+1</strong>和 <strong>-1</strong>操作，分析两种操作对<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>产生的影响\n<ul>\n<li>对于 <strong>+1</strong>操作而言：最低位必然为1，此时如果次低位为0的话，<strong>+1</strong>相当于将最低位和次低位交换；如果次低位为1的话， <strong>+1操作将将从最低位开始，连续一段的1进行消除（置零）</strong>，并在连续一段的最高一位添加一个1</li>\n<li>对于 <strong>-1</strong>操作而言：最低位必然为1，其作用是将最低位的1进行消除</li>\n</ul>\n</li>\n</ul>\n<p>因此，对于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>为奇数所能执行的两种操作， <strong>+1</strong>能够消除连续一段的1，只要次低位为1（存在连续端），应当优先使用  <strong>+1</strong>操作，但需要注意边界<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>的情况（此时选择 <strong>-1</strong>操作）</p>\n<p>此方法个人觉得不如官方题解给的方案，这里给附上网址自行查阅<a href=\"https://leetcode-cn.com/problems/integer-replacement/solution/zheng-shu-ti-huan-by-leetcode-solution-swef/\">整数替换 - 整数替换 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">IntegerReplacement</span>(<span class=\"params\"><span class=\"built_in\">int</span> n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">long</span> tempN = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(tempN != <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tempN % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                tempN &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tempN != <span class=\"number\">3</span> &amp;&amp; (tempN &gt;&gt; <span class=\"number\">1</span> &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>)</span><br><span class=\"line\">                    tempN++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    tempN--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"计算机操作系统","date":"2021-10-24T11:50:07.000Z","_content":"\n# 进程管理\n\n## 进程(Process)\n\n### 进程的定义\n\n狭义定义：进程是正在运行的程序的实例。\n\n广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的**分配单元**，也是基本的**执行单元**(是系统进行**资源分配**和**调度**的一个独立单位)。\n\n> 描述进程的数据结构：**进程控制块（Process Control Block,PCB）**，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。\n>\n> PCB是进程存在的唯一标志。\n>\n> > PCB含有的信息\n> >\n> > 1. **进程标识信息**\n> >\n> >    如本进程的标识，本进程的产生者标识（父进程标识）；用户标示\n> >\n> > 2. **处理机状态信息**\n> >\n> >    保存进程的运行现场信息：\n> >\n> >    - **用户可见寄存器**，用户程序可以使用的数据，地址等寄存器\n> >    - **控制和状态寄存器**，如程序计数器(PC)，程序状态字(PSW)\n> >    - **栈指针**，过程调用/系统调用/中断处理和返回时需要用到它\n> >\n> > 3. **进程调度信息/进程控制信息**\n> >\n> >    - **调度和状态信息**，用于操作系统调度进程并占用处理机使用\n> >    - **进程间通信信息**，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中\n> >    - **存储管理信息**，包含有指向本进程映像存储空间的数据结构\n> >    - **进程所用资源**，说明由进程打开、使用的系统资源，如打开的文件等\n> >    - **有关数据结构连接信息**，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB\n> >\n> > \n>\n> > 使用PCB\n> >\n> > - 进程的创建：为该进程生成一个PCB\n> > - 进程的终止：回收他的PCB\n> >\n> > - 进程的组织管理：通过对PCB的组织管理来实现\n>\n> > PCB的组织方式\n> >\n> > - **线性表方式**：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。\n> > - **索引表方式**：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。\n> > - **链接表方式**：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。\n\n### 进程的组成\n\n一个计算机系统进程包括下列资料\n\n- 程序的代码\n- 程序处理的数据\n- 程序计数器中的值，指示下一条将运行的指令\n- 一组通用的寄存器的当前值、栈\n- 一组系统资源（如打开的文件）\n\n总之，进程包含了正在运行的一个程序所有状态信息。\n\n### 进程的特点\n\n- 动态性：可动态地创建、结束进程\n- 并发性：进程可以被独立调度并占用处理机运行\n- 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n- 异步性[^1]：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进\n\n> 并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的\n>\n> 并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)\n\n\n\n\n### 进程与程序的联系\n\n- 程序是产生进程的基础\n- 程序的每次运行构成不同的进程\n- 进程是程序功能的体现\n- 通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序\n\n### 进程与程序的区别\n\n- 进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。\n\n- 进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。\n\n- 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程\n\n  状态信息)\n\n  ![](./1.png)\n\n  \n\n## 进程状态(State)\n\n### 进程的生命期管理\n\n- **进程创建**\n\n  引起进程创建的3个主要事件：\n\n  - 系统初始化时\n  - 用户请求创建一个新进程\n  - 正在运行的进程执行了创建进程的系统调用\n\n- **进程运行**\n\n  内核选择一个就绪的进程，让它占用处理机并执行\n\n- **进程等待**\n\n  在以下情况下，进程等待（阻塞）\n\n  - 请求并等待系统服务，无法马上完成\n  - 启动某种操作，无法马上完成\n  - 需要的数据没有到达\n\n  进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生\n\n- **进程唤醒**\n\n  唤醒进程的原因：\n\n  - 被阻塞进程需要的资源可被满足\n  - 被阻塞进程等待的事件到达\n  - 将该进程的PCB插入到就绪队列\n\n  进程只能被别的进程或操作系统唤醒\n\n- **进程结束**\n\n  在以下情况，进程结束：\n\n  - 正常退出（自愿）\n  - 错误退出（自愿）\n  - 致命错误（强制）\n  - 被其他进程所杀（强制）\n\n### 进程状态变化模型\n\n进程的三种基本状态：\n\n- **运行状态(Running)**\n\n  当一个进程正在处理机上运行时\n\n- **就绪状态(Ready)**\n\n  一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行\n\n- **等待状态(又称阻塞状态Blocked)**\n\n  一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成\n\n  ![](./3.png)\n\n进程的其他基本状态\n\n- **创建状态(New)**\n\n  一个进程正在被创建，还没被转到就绪状态之前的状态\n\n- **结束状态(Exit)**\n\n  一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致\n\n  ![](./2.png)\n\n  > **时间片**（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。\n\n### 进程挂起\n\n进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。\n\n挂起状态：\n\n- **阻塞挂起状态**（Blocked-suspend）\n\n  进程在外存并等待某事件的出现\n\n- **就绪挂起状态**（Ready-suspend）\n\n  进程在外存，但只要进入内存，即可运行\n\n与挂起相关的状态转换：\n\n- 挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况\n\n  - **阻塞到阻塞挂起**\n\n    没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程\n\n  - **就绪到就绪挂起**\n\n    当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程\n\n  - **运行到就绪挂起**\n\n    对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态\n\n- 在外存时的状态转换\n\n  - **阻塞挂起到就绪挂起**\n\n    当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程\n\n- 解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况\n\n  - **就绪挂起到就绪**\n\n    没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换\n\n  - **阻塞挂起到阻塞**\n\n    当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程\n\n### 状态队列\n\n- 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态\n- 不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)\n- 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列\n\n![](./4.png)\n\n## 线程(Thread)\n\n### 线程的定义\n\n线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。\n\n### 线程的优缺点\n\n优点：\n\n- 一个进程中可以同时存在多个线程\n- 各个线程之间可以并发地执行\n- 各个线程之间可以共享地址空间和文件等资源\n\n缺点：\n\n- 一个线程崩溃，会导致其所属进程的所有线程崩溃\n\n### 线程与进程的比较\n\n- 进程是资源分配单元，线程是CPU调度单元\n- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈\n- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系\n- 线程能减少并发执行的时间和空间开销\n  - 线程的创建时间比进程短\n  - 线程的终止时间比进程短\n  - 同一进程内的线程切换时间比进程短\n  - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信 \n\n### 线程的实现\n\n- 用户线程：在用户空间实现\n  > **用户线程**:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。\n  >\n  > 缺点：\n  >\n  > - 阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待\n  > - 当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行\n  > - 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢\n  \n- 内核线程：在内核中实现\n\n  > **内核线程**：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理\n\n- 轻量级线程：在内核中实现，支持用户线程\n\n  > **轻量级进程**：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持\n\n\n\n用户线程与内核线程的对应关系\n\n- 多对一\n- 一对一\n- 多对多\n\n\n\n## 进程间通信(Inter-process communication)\n\n## 进程互斥与同步\n\n### 基础知识\n\n**临界区**\n\n**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域\n\n**互斥**\n\n当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源\n\n**死锁**\n\n两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去\n\n**饥饿**\n\n一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行\n\n### 实现临界区互斥的基本方法\n\n- 禁用中断(仅限于单处理器)\n\n  当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：**禁止一切中断发生，称之为屏蔽中断或关中断**。\n  因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。\n  **典型模式为：关中断、临界区、开中断**\n\n  **缺点**\n\n  这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。\n\n- **软件方法(复杂)**\n\n  **Peterson算法**\n\n  Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。\n\n  算法使用两个控制变量`flag`与`turn`. 其中`flag[n]`的值为真，表示ID号为`n`的进程希望进入该临界区. 变量`turn`保存有权访问共享资源的进程的ID号.\n\n  ```c++\n  // flag[]是bool数组，turn为int\n  flag[0] = false\n  flag[1] = false;\n  int turn;\n  \n  //P1\n  flag[0] = true;\n  turn = 1;\n  // flag[1] == true时说明另外一个也想运行，\n  while(flag[1] == true && trun == 1)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[0] = false;\n  \n  //同理P2为\n  flag[1] = true;\n  turn = 0;\n  while (flag[0] == true && turn == 0)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[1] = false;\n  ```\n\n  该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）\n\n  **缺点**\n\n  - 复杂：需要两个进程间的共享项\n  - 需要忙等待：浪费CPU时间\n  - 没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令\n\n- **原子操作指令(单处理器或多处理器均可)**\n\n  TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。\n\n  ```c++\n  bool TestAndSet(bool *lock)\n  {\n  \tbool rv = *lock;\n      *lock = true;\n      return rv;\n  }\n  \n  //共享变量lock,true表示正在被占用，false表示没被占用\n  bool lock = false;\n  \n  //进入\n  //如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true->锁的状态不被改变并且需要循环\n  //如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true->锁被设置为被占用状态，并且需要等待完成\n  while(TestAndSet(&lock));\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  Exchange(Swap)指令：交换两个变量的内容\n\n  ```c++\n  void Exchange(bool *a, bool *b)\n  {\n  \tbool temp = *a;\n  \t*a = *b;\n  \t*b = temp;\n  }\n  \n  //共享变量lock，初始化为false\n  bool lock = false;\n  \n  //进入\n  bool key;\n  key = true;\n  while(key == true)\n     Exchange(lock, key);\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  **优点**\n\n  - 适用于单处理器或者共享主存的多处理器中**任意数量的进程**\n  - 简单并且容易证明\n  - 可以用于支持多临界区\n\n  **缺点**\n\n  - 忙等待消耗处理器时间\n\n  - 当进程离开临界区并且多个进程在等待时候可能导致饥饿\n\n  - 死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区\n\n    ps : 优先级反转来解决\n\n## 死锁(Deadlock)\n\n![](/img/1.png)\n\n[^1]: 部分地方称为制约性\n","source":"_posts/操作系统/操作系统.md","raw":"---\nlayout: post\ntitle: 计算机操作系统\ndate: 2021-10-24 19:50:07\ntags: 计算机基础知识\n---\n\n# 进程管理\n\n## 进程(Process)\n\n### 进程的定义\n\n狭义定义：进程是正在运行的程序的实例。\n\n广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的**分配单元**，也是基本的**执行单元**(是系统进行**资源分配**和**调度**的一个独立单位)。\n\n> 描述进程的数据结构：**进程控制块（Process Control Block,PCB）**，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。\n>\n> PCB是进程存在的唯一标志。\n>\n> > PCB含有的信息\n> >\n> > 1. **进程标识信息**\n> >\n> >    如本进程的标识，本进程的产生者标识（父进程标识）；用户标示\n> >\n> > 2. **处理机状态信息**\n> >\n> >    保存进程的运行现场信息：\n> >\n> >    - **用户可见寄存器**，用户程序可以使用的数据，地址等寄存器\n> >    - **控制和状态寄存器**，如程序计数器(PC)，程序状态字(PSW)\n> >    - **栈指针**，过程调用/系统调用/中断处理和返回时需要用到它\n> >\n> > 3. **进程调度信息/进程控制信息**\n> >\n> >    - **调度和状态信息**，用于操作系统调度进程并占用处理机使用\n> >    - **进程间通信信息**，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中\n> >    - **存储管理信息**，包含有指向本进程映像存储空间的数据结构\n> >    - **进程所用资源**，说明由进程打开、使用的系统资源，如打开的文件等\n> >    - **有关数据结构连接信息**，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB\n> >\n> > \n>\n> > 使用PCB\n> >\n> > - 进程的创建：为该进程生成一个PCB\n> > - 进程的终止：回收他的PCB\n> >\n> > - 进程的组织管理：通过对PCB的组织管理来实现\n>\n> > PCB的组织方式\n> >\n> > - **线性表方式**：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。\n> > - **索引表方式**：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。\n> > - **链接表方式**：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。\n\n### 进程的组成\n\n一个计算机系统进程包括下列资料\n\n- 程序的代码\n- 程序处理的数据\n- 程序计数器中的值，指示下一条将运行的指令\n- 一组通用的寄存器的当前值、栈\n- 一组系统资源（如打开的文件）\n\n总之，进程包含了正在运行的一个程序所有状态信息。\n\n### 进程的特点\n\n- 动态性：可动态地创建、结束进程\n- 并发性：进程可以被独立调度并占用处理机运行\n- 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n- 异步性[^1]：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进\n\n> 并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的\n>\n> 并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)\n\n\n\n\n### 进程与程序的联系\n\n- 程序是产生进程的基础\n- 程序的每次运行构成不同的进程\n- 进程是程序功能的体现\n- 通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序\n\n### 进程与程序的区别\n\n- 进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。\n\n- 进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。\n\n- 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程\n\n  状态信息)\n\n  ![](./1.png)\n\n  \n\n## 进程状态(State)\n\n### 进程的生命期管理\n\n- **进程创建**\n\n  引起进程创建的3个主要事件：\n\n  - 系统初始化时\n  - 用户请求创建一个新进程\n  - 正在运行的进程执行了创建进程的系统调用\n\n- **进程运行**\n\n  内核选择一个就绪的进程，让它占用处理机并执行\n\n- **进程等待**\n\n  在以下情况下，进程等待（阻塞）\n\n  - 请求并等待系统服务，无法马上完成\n  - 启动某种操作，无法马上完成\n  - 需要的数据没有到达\n\n  进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生\n\n- **进程唤醒**\n\n  唤醒进程的原因：\n\n  - 被阻塞进程需要的资源可被满足\n  - 被阻塞进程等待的事件到达\n  - 将该进程的PCB插入到就绪队列\n\n  进程只能被别的进程或操作系统唤醒\n\n- **进程结束**\n\n  在以下情况，进程结束：\n\n  - 正常退出（自愿）\n  - 错误退出（自愿）\n  - 致命错误（强制）\n  - 被其他进程所杀（强制）\n\n### 进程状态变化模型\n\n进程的三种基本状态：\n\n- **运行状态(Running)**\n\n  当一个进程正在处理机上运行时\n\n- **就绪状态(Ready)**\n\n  一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行\n\n- **等待状态(又称阻塞状态Blocked)**\n\n  一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成\n\n  ![](./3.png)\n\n进程的其他基本状态\n\n- **创建状态(New)**\n\n  一个进程正在被创建，还没被转到就绪状态之前的状态\n\n- **结束状态(Exit)**\n\n  一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致\n\n  ![](./2.png)\n\n  > **时间片**（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。\n\n### 进程挂起\n\n进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。\n\n挂起状态：\n\n- **阻塞挂起状态**（Blocked-suspend）\n\n  进程在外存并等待某事件的出现\n\n- **就绪挂起状态**（Ready-suspend）\n\n  进程在外存，但只要进入内存，即可运行\n\n与挂起相关的状态转换：\n\n- 挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况\n\n  - **阻塞到阻塞挂起**\n\n    没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程\n\n  - **就绪到就绪挂起**\n\n    当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程\n\n  - **运行到就绪挂起**\n\n    对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态\n\n- 在外存时的状态转换\n\n  - **阻塞挂起到就绪挂起**\n\n    当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程\n\n- 解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况\n\n  - **就绪挂起到就绪**\n\n    没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换\n\n  - **阻塞挂起到阻塞**\n\n    当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程\n\n### 状态队列\n\n- 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态\n- 不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)\n- 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列\n\n![](./4.png)\n\n## 线程(Thread)\n\n### 线程的定义\n\n线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。\n\n### 线程的优缺点\n\n优点：\n\n- 一个进程中可以同时存在多个线程\n- 各个线程之间可以并发地执行\n- 各个线程之间可以共享地址空间和文件等资源\n\n缺点：\n\n- 一个线程崩溃，会导致其所属进程的所有线程崩溃\n\n### 线程与进程的比较\n\n- 进程是资源分配单元，线程是CPU调度单元\n- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈\n- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系\n- 线程能减少并发执行的时间和空间开销\n  - 线程的创建时间比进程短\n  - 线程的终止时间比进程短\n  - 同一进程内的线程切换时间比进程短\n  - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信 \n\n### 线程的实现\n\n- 用户线程：在用户空间实现\n  > **用户线程**:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。\n  >\n  > 缺点：\n  >\n  > - 阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待\n  > - 当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行\n  > - 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢\n  \n- 内核线程：在内核中实现\n\n  > **内核线程**：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理\n\n- 轻量级线程：在内核中实现，支持用户线程\n\n  > **轻量级进程**：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持\n\n\n\n用户线程与内核线程的对应关系\n\n- 多对一\n- 一对一\n- 多对多\n\n\n\n## 进程间通信(Inter-process communication)\n\n## 进程互斥与同步\n\n### 基础知识\n\n**临界区**\n\n**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域\n\n**互斥**\n\n当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源\n\n**死锁**\n\n两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去\n\n**饥饿**\n\n一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行\n\n### 实现临界区互斥的基本方法\n\n- 禁用中断(仅限于单处理器)\n\n  当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：**禁止一切中断发生，称之为屏蔽中断或关中断**。\n  因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。\n  **典型模式为：关中断、临界区、开中断**\n\n  **缺点**\n\n  这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。\n\n- **软件方法(复杂)**\n\n  **Peterson算法**\n\n  Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。\n\n  算法使用两个控制变量`flag`与`turn`. 其中`flag[n]`的值为真，表示ID号为`n`的进程希望进入该临界区. 变量`turn`保存有权访问共享资源的进程的ID号.\n\n  ```c++\n  // flag[]是bool数组，turn为int\n  flag[0] = false\n  flag[1] = false;\n  int turn;\n  \n  //P1\n  flag[0] = true;\n  turn = 1;\n  // flag[1] == true时说明另外一个也想运行，\n  while(flag[1] == true && trun == 1)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[0] = false;\n  \n  //同理P2为\n  flag[1] = true;\n  turn = 0;\n  while (flag[0] == true && turn == 0)\n  {\n      // 忙等待\n  }\n  // 临界区\n  ...\n  // 退出临界区\n  flag[1] = false;\n  ```\n\n  该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）\n\n  **缺点**\n\n  - 复杂：需要两个进程间的共享项\n  - 需要忙等待：浪费CPU时间\n  - 没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令\n\n- **原子操作指令(单处理器或多处理器均可)**\n\n  TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。\n\n  ```c++\n  bool TestAndSet(bool *lock)\n  {\n  \tbool rv = *lock;\n      *lock = true;\n      return rv;\n  }\n  \n  //共享变量lock,true表示正在被占用，false表示没被占用\n  bool lock = false;\n  \n  //进入\n  //如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true->锁的状态不被改变并且需要循环\n  //如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true->锁被设置为被占用状态，并且需要等待完成\n  while(TestAndSet(&lock));\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  Exchange(Swap)指令：交换两个变量的内容\n\n  ```c++\n  void Exchange(bool *a, bool *b)\n  {\n  \tbool temp = *a;\n  \t*a = *b;\n  \t*b = temp;\n  }\n  \n  //共享变量lock，初始化为false\n  bool lock = false;\n  \n  //进入\n  bool key;\n  key = true;\n  while(key == true)\n     Exchange(lock, key);\n  //临界区\n  //离开\n  lock = false;\n  ```\n\n  **优点**\n\n  - 适用于单处理器或者共享主存的多处理器中**任意数量的进程**\n  - 简单并且容易证明\n  - 可以用于支持多临界区\n\n  **缺点**\n\n  - 忙等待消耗处理器时间\n\n  - 当进程离开临界区并且多个进程在等待时候可能导致饥饿\n\n  - 死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区\n\n    ps : 优先级反转来解决\n\n## 死锁(Deadlock)\n\n![](/img/1.png)\n\n[^1]: 部分地方称为制约性\n","slug":"操作系统/操作系统","published":1,"updated":"2021-11-02T04:00:30.238Z","comments":1,"photos":[],"link":"","_id":"ckvhp3k3a00048wuphyd26ad7","content":"<h1>进程管理</h1>\n<h2 id=\"进程-Process\">进程(Process)</h2>\n<h3 id=\"进程的定义\">进程的定义</h3>\n<p>狭义定义：进程是正在运行的程序的实例。</p>\n<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的<strong>分配单元</strong>，也是基本的<strong>执行单元</strong>(是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位)。</p>\n<blockquote>\n<p>描述进程的数据结构：<strong>进程控制块（Process Control Block,PCB）</strong>，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。</p>\n<p>PCB是进程存在的唯一标志。</p>\n<blockquote>\n<p>PCB含有的信息</p>\n<ol>\n<li>\n<p><strong>进程标识信息</strong></p>\n<p>如本进程的标识，本进程的产生者标识（父进程标识）；用户标示</p>\n</li>\n<li>\n<p><strong>处理机状态信息</strong></p>\n<p>保存进程的运行现场信息：</p>\n<ul>\n<li><strong>用户可见寄存器</strong>，用户程序可以使用的数据，地址等寄存器</li>\n<li><strong>控制和状态寄存器</strong>，如程序计数器(PC)，程序状态字(PSW)</li>\n<li><strong>栈指针</strong>，过程调用/系统调用/中断处理和返回时需要用到它</li>\n</ul>\n</li>\n<li>\n<p><strong>进程调度信息/进程控制信息</strong></p>\n<ul>\n<li><strong>调度和状态信息</strong>，用于操作系统调度进程并占用处理机使用</li>\n<li><strong>进程间通信信息</strong>，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中</li>\n<li><strong>存储管理信息</strong>，包含有指向本进程映像存储空间的数据结构</li>\n<li><strong>进程所用资源</strong>，说明由进程打开、使用的系统资源，如打开的文件等</li>\n<li><strong>有关数据结构连接信息</strong>，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>使用PCB</p>\n<ul>\n<li>\n<p>进程的创建：为该进程生成一个PCB</p>\n</li>\n<li>\n<p>进程的终止：回收他的PCB</p>\n</li>\n<li>\n<p>进程的组织管理：通过对PCB的组织管理来实现</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>PCB的组织方式</p>\n<ul>\n<li><strong>线性表方式</strong>：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。</li>\n<li><strong>索引表方式</strong>：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。</li>\n<li><strong>链接表方式</strong>：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。</li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"进程的组成\">进程的组成</h3>\n<p>一个计算机系统进程包括下列资料</p>\n<ul>\n<li>程序的代码</li>\n<li>程序处理的数据</li>\n<li>程序计数器中的值，指示下一条将运行的指令</li>\n<li>一组通用的寄存器的当前值、栈</li>\n<li>一组系统资源（如打开的文件）</li>\n</ul>\n<p>总之，进程包含了正在运行的一个程序所有状态信息。</p>\n<h3 id=\"进程的特点\">进程的特点</h3>\n<ul>\n<li>动态性：可动态地创建、结束进程</li>\n<li>并发性：进程可以被独立调度并占用处理机运行</li>\n<li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位</li>\n<li>异步性<a href=\"%E9%83%A8%E5%88%86%E5%9C%B0%E6%96%B9%E7%A7%B0%E4%B8%BA%E5%88%B6%E7%BA%A6%E6%80%A7\">^1</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li>\n</ul>\n<blockquote>\n<p>并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的</p>\n<p>并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)</p>\n</blockquote>\n<h3 id=\"进程与程序的联系\">进程与程序的联系</h3>\n<ul>\n<li>程序是产生进程的基础</li>\n<li>程序的每次运行构成不同的进程</li>\n<li>进程是程序功能的体现</li>\n<li>通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序</li>\n</ul>\n<h3 id=\"进程与程序的区别\">进程与程序的区别</h3>\n<ul>\n<li>\n<p>进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。</p>\n</li>\n<li>\n<p>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。</p>\n</li>\n<li>\n<p>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程</p>\n<p>状态信息)</p>\n<p><img src=\"./1.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"进程状态-State\">进程状态(State)</h2>\n<h3 id=\"进程的生命期管理\">进程的生命期管理</h3>\n<ul>\n<li>\n<p><strong>进程创建</strong></p>\n<p>引起进程创建的3个主要事件：</p>\n<ul>\n<li>系统初始化时</li>\n<li>用户请求创建一个新进程</li>\n<li>正在运行的进程执行了创建进程的系统调用</li>\n</ul>\n</li>\n<li>\n<p><strong>进程运行</strong></p>\n<p>内核选择一个就绪的进程，让它占用处理机并执行</p>\n</li>\n<li>\n<p><strong>进程等待</strong></p>\n<p>在以下情况下，进程等待（阻塞）</p>\n<ul>\n<li>请求并等待系统服务，无法马上完成</li>\n<li>启动某种操作，无法马上完成</li>\n<li>需要的数据没有到达</li>\n</ul>\n<p>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生</p>\n</li>\n<li>\n<p><strong>进程唤醒</strong></p>\n<p>唤醒进程的原因：</p>\n<ul>\n<li>被阻塞进程需要的资源可被满足</li>\n<li>被阻塞进程等待的事件到达</li>\n<li>将该进程的PCB插入到就绪队列</li>\n</ul>\n<p>进程只能被别的进程或操作系统唤醒</p>\n</li>\n<li>\n<p><strong>进程结束</strong></p>\n<p>在以下情况，进程结束：</p>\n<ul>\n<li>正常退出（自愿）</li>\n<li>错误退出（自愿）</li>\n<li>致命错误（强制）</li>\n<li>被其他进程所杀（强制）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程状态变化模型\">进程状态变化模型</h3>\n<p>进程的三种基本状态：</p>\n<ul>\n<li>\n<p><strong>运行状态(Running)</strong></p>\n<p>当一个进程正在处理机上运行时</p>\n</li>\n<li>\n<p><strong>就绪状态(Ready)</strong></p>\n<p>一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行</p>\n</li>\n<li>\n<p><strong>等待状态(又称阻塞状态Blocked)</strong></p>\n<p>一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成</p>\n<p><img src=\"./3.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>进程的其他基本状态</p>\n<ul>\n<li>\n<p><strong>创建状态(New)</strong></p>\n<p>一个进程正在被创建，还没被转到就绪状态之前的状态</p>\n</li>\n<li>\n<p><strong>结束状态(Exit)</strong></p>\n<p>一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致</p>\n<p><img src=\"./2.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>时间片</strong>（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"进程挂起\">进程挂起</h3>\n<p>进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。</p>\n<p>挂起状态：</p>\n<ul>\n<li>\n<p><strong>阻塞挂起状态</strong>（Blocked-suspend）</p>\n<p>进程在外存并等待某事件的出现</p>\n</li>\n<li>\n<p><strong>就绪挂起状态</strong>（Ready-suspend）</p>\n<p>进程在外存，但只要进入内存，即可运行</p>\n</li>\n</ul>\n<p>与挂起相关的状态转换：</p>\n<ul>\n<li>\n<p>挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>阻塞到阻塞挂起</strong></p>\n<p>没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程</p>\n</li>\n<li>\n<p><strong>就绪到就绪挂起</strong></p>\n<p>当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程</p>\n</li>\n<li>\n<p><strong>运行到就绪挂起</strong></p>\n<p>对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态</p>\n</li>\n</ul>\n</li>\n<li>\n<p>在外存时的状态转换</p>\n<ul>\n<li>\n<p><strong>阻塞挂起到就绪挂起</strong></p>\n<p>当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程</p>\n</li>\n</ul>\n</li>\n<li>\n<p>解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>就绪挂起到就绪</strong></p>\n<p>没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换</p>\n</li>\n<li>\n<p><strong>阻塞挂起到阻塞</strong></p>\n<p>当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"状态队列\">状态队列</h3>\n<ul>\n<li>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态</li>\n<li>不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)</li>\n<li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列</li>\n</ul>\n<p><img src=\"./4.png\" alt=\"\"></p>\n<h2 id=\"线程-Thread\">线程(Thread)</h2>\n<h3 id=\"线程的定义\">线程的定义</h3>\n<p>线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。</p>\n<h3 id=\"线程的优缺点\">线程的优缺点</h3>\n<p>优点：</p>\n<ul>\n<li>一个进程中可以同时存在多个线程</li>\n<li>各个线程之间可以并发地执行</li>\n<li>各个线程之间可以共享地址空间和文件等资源</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>\n</ul>\n<h3 id=\"线程与进程的比较\">线程与进程的比较</h3>\n<ul>\n<li>进程是资源分配单元，线程是CPU调度单元</li>\n<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈</li>\n<li>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系</li>\n<li>线程能减少并发执行的时间和空间开销\n<ul>\n<li>线程的创建时间比进程短</li>\n<li>线程的终止时间比进程短</li>\n<li>同一进程内的线程切换时间比进程短</li>\n<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的实现\">线程的实现</h3>\n<ul>\n<li>\n<p>用户线程：在用户空间实现</p>\n<blockquote>\n<p><strong>用户线程</strong>:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。</p>\n<p>缺点：</p>\n<ul>\n<li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待</li>\n<li>当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行</li>\n<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>内核线程：在内核中实现</p>\n<blockquote>\n<p><strong>内核线程</strong>：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理</p>\n</blockquote>\n</li>\n<li>\n<p>轻量级线程：在内核中实现，支持用户线程</p>\n<blockquote>\n<p><strong>轻量级进程</strong>：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持</p>\n</blockquote>\n</li>\n</ul>\n<p>用户线程与内核线程的对应关系</p>\n<ul>\n<li>多对一</li>\n<li>一对一</li>\n<li>多对多</li>\n</ul>\n<h2 id=\"进程间通信-Inter-process-communication\">进程间通信(Inter-process communication)</h2>\n<h2 id=\"进程互斥与同步\">进程互斥与同步</h2>\n<h3 id=\"基础知识\">基础知识</h3>\n<p><strong>临界区</strong></p>\n<p>**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域</p>\n<p><strong>互斥</strong></p>\n<p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p>\n<p><strong>死锁</strong></p>\n<p>两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去</p>\n<p><strong>饥饿</strong></p>\n<p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p>\n<h3 id=\"实现临界区互斥的基本方法\">实现临界区互斥的基本方法</h3>\n<ul>\n<li>\n<p>禁用中断(仅限于单处理器)</p>\n<p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：<strong>禁止一切中断发生，称之为屏蔽中断或关中断</strong>。<br>\n因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。<br>\n<strong>典型模式为：关中断、临界区、开中断</strong></p>\n<p><strong>缺点</strong></p>\n<p>这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。</p>\n</li>\n<li>\n<p><strong>软件方法(复杂)</strong></p>\n<p><strong>Peterson算法</strong></p>\n<p>Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。</p>\n<p>算法使用两个控制变量<code>flag</code>与<code>turn</code>. 其中<code>flag[n]</code>的值为真，表示ID号为<code>n</code>的进程希望进入该临界区. 变量<code>turn</code>保存有权访问共享资源的进程的ID号.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flag[]是bool数组，turn为int</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//P1</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// flag[1] == true时说明另外一个也想运行，</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[<span class=\"number\">1</span>] == <span class=\"literal\">true</span> &amp;&amp; trun == <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同理P2为</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (flag[<span class=\"number\">0</span>] == <span class=\"literal\">true</span> &amp;&amp; turn == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>复杂：需要两个进程间的共享项</li>\n<li>需要忙等待：浪费CPU时间</li>\n<li>没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令</li>\n</ul>\n</li>\n<li>\n<p><strong>原子操作指令(单处理器或多处理器均可)</strong></p>\n<p>TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">TestAndSet</span><span class=\"params\">(<span class=\"keyword\">bool</span> *lock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> rv = *lock;</span><br><span class=\"line\">    *lock = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock,true表示正在被占用，false表示没被占用</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true-&gt;锁的状态不被改变并且需要循环</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true-&gt;锁被设置为被占用状态，并且需要等待完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">TestAndSet</span>(&amp;lock));</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>Exchange(Swap)指令：交换两个变量的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchange</span><span class=\"params\">(<span class=\"keyword\">bool</span> *a, <span class=\"keyword\">bool</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> temp = *a;</span><br><span class=\"line\">\t*a = *b;</span><br><span class=\"line\">\t*b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock，初始化为false</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> key;</span><br><span class=\"line\">key = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(key == <span class=\"literal\">true</span>)</span><br><span class=\"line\">   <span class=\"built_in\">Exchange</span>(lock, key);</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong></p>\n<ul>\n<li>适用于单处理器或者共享主存的多处理器中<strong>任意数量的进程</strong></li>\n<li>简单并且容易证明</li>\n<li>可以用于支持多临界区</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>\n<p>忙等待消耗处理器时间</p>\n</li>\n<li>\n<p>当进程离开临界区并且多个进程在等待时候可能导致饥饿</p>\n</li>\n<li>\n<p>死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区</p>\n<p>ps : 优先级反转来解决</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"死锁-Deadlock\">死锁(Deadlock)</h2>\n<p><img src=\"/img/1.png\" alt=\"\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/background.png","excerpt":"","more":"<h1>进程管理</h1>\n<h2 id=\"进程-Process\">进程(Process)</h2>\n<h3 id=\"进程的定义\">进程的定义</h3>\n<p>狭义定义：进程是正在运行的程序的实例。</p>\n<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的<strong>分配单元</strong>，也是基本的<strong>执行单元</strong>(是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位)。</p>\n<blockquote>\n<p>描述进程的数据结构：<strong>进程控制块（Process Control Block,PCB）</strong>，操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。</p>\n<p>PCB是进程存在的唯一标志。</p>\n<blockquote>\n<p>PCB含有的信息</p>\n<ol>\n<li>\n<p><strong>进程标识信息</strong></p>\n<p>如本进程的标识，本进程的产生者标识（父进程标识）；用户标示</p>\n</li>\n<li>\n<p><strong>处理机状态信息</strong></p>\n<p>保存进程的运行现场信息：</p>\n<ul>\n<li><strong>用户可见寄存器</strong>，用户程序可以使用的数据，地址等寄存器</li>\n<li><strong>控制和状态寄存器</strong>，如程序计数器(PC)，程序状态字(PSW)</li>\n<li><strong>栈指针</strong>，过程调用/系统调用/中断处理和返回时需要用到它</li>\n</ul>\n</li>\n<li>\n<p><strong>进程调度信息/进程控制信息</strong></p>\n<ul>\n<li><strong>调度和状态信息</strong>，用于操作系统调度进程并占用处理机使用</li>\n<li><strong>进程间通信信息</strong>，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中</li>\n<li><strong>存储管理信息</strong>，包含有指向本进程映像存储空间的数据结构</li>\n<li><strong>进程所用资源</strong>，说明由进程打开、使用的系统资源，如打开的文件等</li>\n<li><strong>有关数据结构连接信息</strong>，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>使用PCB</p>\n<ul>\n<li>\n<p>进程的创建：为该进程生成一个PCB</p>\n</li>\n<li>\n<p>进程的终止：回收他的PCB</p>\n</li>\n<li>\n<p>进程的组织管理：通过对PCB的组织管理来实现</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>PCB的组织方式</p>\n<ul>\n<li><strong>线性表方式</strong>：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。</li>\n<li><strong>索引表方式</strong>：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。</li>\n<li><strong>链接表方式</strong>：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。</li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"进程的组成\">进程的组成</h3>\n<p>一个计算机系统进程包括下列资料</p>\n<ul>\n<li>程序的代码</li>\n<li>程序处理的数据</li>\n<li>程序计数器中的值，指示下一条将运行的指令</li>\n<li>一组通用的寄存器的当前值、栈</li>\n<li>一组系统资源（如打开的文件）</li>\n</ul>\n<p>总之，进程包含了正在运行的一个程序所有状态信息。</p>\n<h3 id=\"进程的特点\">进程的特点</h3>\n<ul>\n<li>动态性：可动态地创建、结束进程</li>\n<li>并发性：进程可以被独立调度并占用处理机运行</li>\n<li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位</li>\n<li>异步性<a href=\"%E9%83%A8%E5%88%86%E5%9C%B0%E6%96%B9%E7%A7%B0%E4%B8%BA%E5%88%B6%E7%BA%A6%E6%80%A7\">^1</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li>\n</ul>\n<blockquote>\n<p>并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的</p>\n<p>并发：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时,微观上仍是顺序执行)</p>\n</blockquote>\n<h3 id=\"进程与程序的联系\">进程与程序的联系</h3>\n<ul>\n<li>程序是产生进程的基础</li>\n<li>程序的每次运行构成不同的进程</li>\n<li>进程是程序功能的体现</li>\n<li>通过多次执行，一个程序可对对应多个进程；用过调用关系一个进程可包括多个程序</li>\n</ul>\n<h3 id=\"进程与程序的区别\">进程与程序的区别</h3>\n<ul>\n<li>\n<p>进程是动态的，程序时静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态。</p>\n</li>\n<li>\n<p>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。</p>\n</li>\n<li>\n<p>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程</p>\n<p>状态信息)</p>\n<p><img src=\"./1.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"进程状态-State\">进程状态(State)</h2>\n<h3 id=\"进程的生命期管理\">进程的生命期管理</h3>\n<ul>\n<li>\n<p><strong>进程创建</strong></p>\n<p>引起进程创建的3个主要事件：</p>\n<ul>\n<li>系统初始化时</li>\n<li>用户请求创建一个新进程</li>\n<li>正在运行的进程执行了创建进程的系统调用</li>\n</ul>\n</li>\n<li>\n<p><strong>进程运行</strong></p>\n<p>内核选择一个就绪的进程，让它占用处理机并执行</p>\n</li>\n<li>\n<p><strong>进程等待</strong></p>\n<p>在以下情况下，进程等待（阻塞）</p>\n<ul>\n<li>请求并等待系统服务，无法马上完成</li>\n<li>启动某种操作，无法马上完成</li>\n<li>需要的数据没有到达</li>\n</ul>\n<p>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生</p>\n</li>\n<li>\n<p><strong>进程唤醒</strong></p>\n<p>唤醒进程的原因：</p>\n<ul>\n<li>被阻塞进程需要的资源可被满足</li>\n<li>被阻塞进程等待的事件到达</li>\n<li>将该进程的PCB插入到就绪队列</li>\n</ul>\n<p>进程只能被别的进程或操作系统唤醒</p>\n</li>\n<li>\n<p><strong>进程结束</strong></p>\n<p>在以下情况，进程结束：</p>\n<ul>\n<li>正常退出（自愿）</li>\n<li>错误退出（自愿）</li>\n<li>致命错误（强制）</li>\n<li>被其他进程所杀（强制）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程状态变化模型\">进程状态变化模型</h3>\n<p>进程的三种基本状态：</p>\n<ul>\n<li>\n<p><strong>运行状态(Running)</strong></p>\n<p>当一个进程正在处理机上运行时</p>\n</li>\n<li>\n<p><strong>就绪状态(Ready)</strong></p>\n<p>一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行</p>\n</li>\n<li>\n<p><strong>等待状态(又称阻塞状态Blocked)</strong></p>\n<p>一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成</p>\n<p><img src=\"./3.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>进程的其他基本状态</p>\n<ul>\n<li>\n<p><strong>创建状态(New)</strong></p>\n<p>一个进程正在被创建，还没被转到就绪状态之前的状态</p>\n</li>\n<li>\n<p><strong>结束状态(Exit)</strong></p>\n<p>一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致</p>\n<p><img src=\"./2.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>时间片</strong>（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"进程挂起\">进程挂起</h3>\n<p>进程在挂起状态时，意味着进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。</p>\n<p>挂起状态：</p>\n<ul>\n<li>\n<p><strong>阻塞挂起状态</strong>（Blocked-suspend）</p>\n<p>进程在外存并等待某事件的出现</p>\n</li>\n<li>\n<p><strong>就绪挂起状态</strong>（Ready-suspend）</p>\n<p>进程在外存，但只要进入内存，即可运行</p>\n</li>\n</ul>\n<p>与挂起相关的状态转换：</p>\n<ul>\n<li>\n<p>挂起(Suspend)：把一个进程从内存转到外存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>阻塞到阻塞挂起</strong></p>\n<p>没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程</p>\n</li>\n<li>\n<p><strong>就绪到就绪挂起</strong></p>\n<p>当有高优先级阻塞（系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程</p>\n</li>\n<li>\n<p><strong>运行到就绪挂起</strong></p>\n<p>对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态</p>\n</li>\n</ul>\n</li>\n<li>\n<p>在外存时的状态转换</p>\n<ul>\n<li>\n<p><strong>阻塞挂起到就绪挂起</strong></p>\n<p>当有阻塞挂起因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程</p>\n</li>\n</ul>\n</li>\n<li>\n<p>解挂/激活(Activate)：把一个进程从外存转到内存，可能有以下几种情况</p>\n<ul>\n<li>\n<p><strong>就绪挂起到就绪</strong></p>\n<p>没有就绪进程或挂起进行优先级高于就绪进程时，会进行这种转换</p>\n</li>\n<li>\n<p><strong>阻塞挂起到阻塞</strong></p>\n<p>当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统会认为很快出现所等待事件)进程转换为阻塞进程</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"状态队列\">状态队列</h3>\n<ul>\n<li>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态</li>\n<li>不同的状态分别用不同的队列来表示(就绪队列、各种类型的阻塞队列)</li>\n<li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列</li>\n</ul>\n<p><img src=\"./4.png\" alt=\"\"></p>\n<h2 id=\"线程-Thread\">线程(Thread)</h2>\n<h3 id=\"线程的定义\">线程的定义</h3>\n<p>线程是操作系统能够进行运算调度的最小单位。在大部分情况下，它被包含在进程之中，是进程中的实际运作单位。</p>\n<h3 id=\"线程的优缺点\">线程的优缺点</h3>\n<p>优点：</p>\n<ul>\n<li>一个进程中可以同时存在多个线程</li>\n<li>各个线程之间可以并发地执行</li>\n<li>各个线程之间可以共享地址空间和文件等资源</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>\n</ul>\n<h3 id=\"线程与进程的比较\">线程与进程的比较</h3>\n<ul>\n<li>进程是资源分配单元，线程是CPU调度单元</li>\n<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器喝栈</li>\n<li>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系</li>\n<li>线程能减少并发执行的时间和空间开销\n<ul>\n<li>线程的创建时间比进程短</li>\n<li>线程的终止时间比进程短</li>\n<li>同一进程内的线程切换时间比进程短</li>\n<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的实现\">线程的实现</h3>\n<ul>\n<li>\n<p>用户线程：在用户空间实现</p>\n<blockquote>\n<p><strong>用户线程</strong>:在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。</p>\n<p>缺点：</p>\n<ul>\n<li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待</li>\n<li>当一个线程开始运行后，除非它主动地交出CPU的使用权，负责它所在的进程当中的其他线程将无法运行</li>\n<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>内核线程：在内核中实现</p>\n<blockquote>\n<p><strong>内核线程</strong>：在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理</p>\n</blockquote>\n</li>\n<li>\n<p>轻量级线程：在内核中实现，支持用户线程</p>\n<blockquote>\n<p><strong>轻量级进程</strong>：它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持</p>\n</blockquote>\n</li>\n</ul>\n<p>用户线程与内核线程的对应关系</p>\n<ul>\n<li>多对一</li>\n<li>一对一</li>\n<li>多对多</li>\n</ul>\n<h2 id=\"进程间通信-Inter-process-communication\">进程间通信(Inter-process communication)</h2>\n<h2 id=\"进程互斥与同步\">进程互斥与同步</h2>\n<h3 id=\"基础知识\">基础知识</h3>\n<p><strong>临界区</strong></p>\n<p>**临界区(Critical section)**是指进程中的一段需要访问共享资源并且的当另一个进程处于相应代码区域时便不会被执行的代码区域</p>\n<p><strong>互斥</strong></p>\n<p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p>\n<p><strong>死锁</strong></p>\n<p>两个或以上的进程，在相互等待完成特定的任务，而最终没法将自身任务进行下去</p>\n<p><strong>饥饿</strong></p>\n<p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p>\n<h3 id=\"实现临界区互斥的基本方法\">实现临界区互斥的基本方法</h3>\n<ul>\n<li>\n<p>禁用中断(仅限于单处理器)</p>\n<p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区的进行访问的最简单的方法是：<strong>禁止一切中断发生，称之为屏蔽中断或关中断</strong>。<br>\n因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程可以一直占据处理机直到临界区代码执行完，从而完成了互斥访问临界区。<br>\n<strong>典型模式为：关中断、临界区、开中断</strong></p>\n<p><strong>缺点</strong></p>\n<p>这种方法限制了处理机交替执行程序的能力，因此系统并发度和吞吐量都会下降。而且将关中断的权利交给用户则很不明智，若一个进程关中断以后，不再开中断，系统可能会因此终止。</p>\n</li>\n<li>\n<p><strong>软件方法(复杂)</strong></p>\n<p><strong>Peterson算法</strong></p>\n<p>Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne 算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。</p>\n<p>算法使用两个控制变量<code>flag</code>与<code>turn</code>. 其中<code>flag[n]</code>的值为真，表示ID号为<code>n</code>的进程希望进入该临界区. 变量<code>turn</code>保存有权访问共享资源的进程的ID号.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flag[]是bool数组，turn为int</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//P1</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// flag[1] == true时说明另外一个也想运行，</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[<span class=\"number\">1</span>] == <span class=\"literal\">true</span> &amp;&amp; trun == <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同理P2为</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">turn = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (flag[<span class=\"number\">0</span>] == <span class=\"literal\">true</span> &amp;&amp; turn == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 忙等待</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 临界区</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 退出临界区</span></span><br><span class=\"line\">flag[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>该算法满足临界区问题的三个必须标准：互斥访问, 进入（即不死锁）, 有限等待（即不饿死）</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>复杂：需要两个进程间的共享项</li>\n<li>需要忙等待：浪费CPU时间</li>\n<li>没有硬件保证的情况下无真正的软件的解决方案：算法需要原子的Load和Store指令</li>\n</ul>\n</li>\n<li>\n<p><strong>原子操作指令(单处理器或多处理器均可)</strong></p>\n<p>TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">TestAndSet</span><span class=\"params\">(<span class=\"keyword\">bool</span> *lock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> rv = *lock;</span><br><span class=\"line\">    *lock = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock,true表示正在被占用，false表示没被占用</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁被占用(忙状态)，那么TestAndSet读取true并将lock设置为true-&gt;锁的状态不被改变并且需要循环</span></span><br><span class=\"line\"><span class=\"comment\">//如果锁没被占用(被释放)，那么TestAndSet读取false并将lock设置为true-&gt;锁被设置为被占用状态，并且需要等待完成</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">TestAndSet</span>(&amp;lock));</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>Exchange(Swap)指令：交换两个变量的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Exchange</span><span class=\"params\">(<span class=\"keyword\">bool</span> *a, <span class=\"keyword\">bool</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> temp = *a;</span><br><span class=\"line\">\t*a = *b;</span><br><span class=\"line\">\t*b = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//共享变量lock，初始化为false</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lock = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进入</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> key;</span><br><span class=\"line\">key = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(key == <span class=\"literal\">true</span>)</span><br><span class=\"line\">   <span class=\"built_in\">Exchange</span>(lock, key);</span><br><span class=\"line\"><span class=\"comment\">//临界区</span></span><br><span class=\"line\"><span class=\"comment\">//离开</span></span><br><span class=\"line\">lock = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong></p>\n<ul>\n<li>适用于单处理器或者共享主存的多处理器中<strong>任意数量的进程</strong></li>\n<li>简单并且容易证明</li>\n<li>可以用于支持多临界区</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>\n<p>忙等待消耗处理器时间</p>\n</li>\n<li>\n<p>当进程离开临界区并且多个进程在等待时候可能导致饥饿</p>\n</li>\n<li>\n<p>死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程页需求，那么高优先级进程会获得处理器并等待临界区</p>\n<p>ps : 优先级反转来解决</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"死锁-Deadlock\">死锁(Deadlock)</h2>\n<p><img src=\"/img/1.png\" alt=\"\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckvhp3k3a00048wuphyd26ad7","tag_id":"ckvhp3k3b00058wuphtx01e9a","_id":"ckvhp3k3c00068wup0pcw3ude"}],"Tag":[{"name":"计算机基础知识","_id":"ckvhp3k3b00058wuphtx01e9a"}]}}